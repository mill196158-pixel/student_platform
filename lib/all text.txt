===== FILE: features\auth\presentation\login_page.dart =====
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import '../../../routes/app_router.dart';
// Р•СЃР»Рё Р±СѓРґРµС‚ lottie-С„Р°Р№Р», СЂР°СЃРєРѕРјРјРµРЅС‚РёСЂСѓР№ РёРјРїРѕСЂС‚ Рё РІРёРґР¶РµС‚ РЅРёР¶Рµ
// import 'package:lottie/lottie.dart';

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});
  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final _noCtrl = TextEditingController();
  final _passCtrl = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Р’С…РѕРґ')),
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const SizedBox(height: 12),
            TextField(
              controller: _noCtrl,
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(
                labelText: 'РЎС‚СѓРґРµРЅС‡РµСЃРєРёР№ РЅРѕРјРµСЂ',
                prefixIcon: Icon(Icons.badge_outlined),
              ),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _passCtrl,
              obscureText: true,
              decoration: const InputDecoration(
                labelText: 'РџР°СЂРѕР»СЊ',
                prefixIcon: Icon(Icons.lock_outline),
              ),
            ),
            const SizedBox(height: 20),
            FilledButton(
              onPressed: () => context.go(AppRoutes.home),
              child: const Text('Р’РѕР№С‚Рё'),
            ),
            const SizedBox(height: 24),

            // РџСЂРёРјРµСЂ Lottie вЂ” РєРѕРіРґР° РїРѕР»РѕР¶РёС€СЊ С„Р°Р№Р», СЂР°СЃРєРѕРјРјРµРЅС‚РёСЂСѓР№
            // Lottie.asset('assets/lottie/splash.json', height: 120),

            const Spacer(),
            Text(
              'Р”РѕР±СЂРѕ РїРѕР¶Р°Р»РѕРІР°С‚СЊ!',
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
          ],
        ),
      ),
    );
  }
}

/// Р”РѕРјР°С€РЅРёР№ СЌРєСЂР°РЅ (РјРёРЅРёРјР°Р»СЊРЅС‹Рµ РєР°СЂС‚РѕС‡РєРё РІ СЃС‚РёР»Рµ Cloudmate)
class HomePage extends StatelessWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final t = Theme.of(context).textTheme;
    return Scaffold(
      appBar: AppBar(title: const Text('РЎРµРіРѕРґРЅСЏ')),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          Text('Р“Р»Р°РІРЅР°СЏ', style: t.titleLarge),
          const SizedBox(height: 12),
          const _CardTile(
            icon: Icons.calendar_today_outlined,
            title: 'РџР°СЂС‹',
            subtitle: 'Р Р°СЃРїРёСЃР°РЅРёРµ РЅР° СЃРµРіРѕРґРЅСЏ',
          ),
          const SizedBox(height: 12),
          const _CardTile(
            icon: Icons.assignment_outlined,
            title: 'Р—Р°РґР°РЅРёСЏ',
            subtitle: 'Р‘Р»РёР¶Р°Р№С€РёРµ РґРµРґР»Р°Р№РЅС‹',
          ),
        ],
      ),
    );
  }
}

class _CardTile extends StatelessWidget {
  final IconData icon;
  final String title;
  final String subtitle;
  const _CardTile({required this.icon, required this.title, required this.subtitle});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Icon(icon),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(title, style: Theme.of(context).textTheme.titleMedium),
                  const SizedBox(height: 4),
                  Text(subtitle, style: Theme.of(context).textTheme.bodyMedium),
                ],
              ),
            ),
            const Icon(Icons.arrow_forward_ios, size: 16),
          ],
        ),
      ),
    );
  }
}



===== FILE: main.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:get_storage/get_storage.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

// РўРµРјС‹
import 'src/themes/themes.dart';
import 'src/themes/theme_service.dart';

// Р­РєСЂР°РЅС‹
import 'src/ui/splash/splash_screen.dart';
import 'src/ui/authentication/authenticate_screen.dart';
import 'src/ui/navigation/navigation_screen.dart';
import 'src/ui/profile/profile_screen.dart';
import 'src/ui/profile/edit_profile_screen.dart';
import 'src/ui/exams/exams_screen.dart';

/// ===== GoRouter =====
final GoRouter appRouter = GoRouter(
  initialLocation: '/splash',
  routes: [
    GoRoute(
      path: '/splash',
      builder: (_, __) => const SplashScreen(),
    ),
    GoRoute(
      path: '/login',
      builder: (_, __) => AuthenticateScreen(),
    ),
    GoRoute(
      path: '/home',
      builder: (_, __) => const NavigationScreen(),
    ),
    GoRoute(
      path: '/profile',
      builder: (_, __) => const ProfileScreen(),
    ),
    GoRoute(
      path: '/edit-profile',
      builder: (_, __) => const EditProfileScreen(),
    ),
    GoRoute(
      path: '/exams',
      builder: (_, __) => const ExamsScreen(),
    ),
  ],
);

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await GetStorage.init(); // Р»РѕРєР°Р»СЊРЅРѕРµ С…СЂР°РЅРёР»РёС‰Рµ

  // === РўР’РћР СЂРµР°Р»СЊРЅС‹Рµ Р·РЅР°С‡РµРЅРёСЏ РёР· Supabase Settings в†’ API ===
  const supabaseUrl = 'https://gwdanmwluhrcfxbnplwd.supabase.co';
  const supabaseAnonKey =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3ZGFubXdsdWhyY2Z4Ym5wbHdkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNjM1MTgsImV4cCI6MjA3MDgzOTUxOH0.tBZ7b_FyOxPWiqkFQf1OIh9c6hJ7Fm2eHyjsDjoBoSA';

  await Supabase.initialize(
    url: supabaseUrl,
    anonKey: supabaseAnonKey,
  );

  runApp(const StudentPlatformApp());
}

class StudentPlatformApp extends StatelessWidget {
  const StudentPlatformApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'Student Platform',
      debugShowCheckedModeBanner: false,
      theme: AppTheme.light().data,
      darkTheme: AppTheme.dark().data,
      themeMode: themeService.getThemeMode(),
      routerConfig: appRouter,

      // Р›РѕРєР°Р»РёР·Р°С†РёСЏ
      locale: const Locale('ru', 'RU'),
      supportedLocales: const [
        Locale('ru', 'RU'),
        Locale('en', 'US'),
      ],
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
      ],
    );
  }
}



===== FILE: routes\app_router.dart =====
import 'package:go_router/go_router.dart';
import '../features/auth/presentation/login_page.dart';

final class AppRoutes {
  static const login = '/login';
  static const home = '/home';
}

final class AppRouter {
  static final router = GoRouter(
    initialLocation: AppRoutes.login,
    routes: [
      GoRoute(path: AppRoutes.login, builder: (_, __) => const LoginPage()),
      // Р”РѕРјР°С€РЅРёР№ СЌРєСЂР°РЅ РѕР±СЉСЏРІР»РµРЅ РІ login_page.dart (С‡С‚РѕР±С‹ СѓР»РѕР¶РёС‚СЊСЃСЏ РІ 5 С„Р°Р№Р»РѕРІ)
    ],
  );
}



===== FILE: src\app.dart =====
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'ui/authentication/screens/login_screen.dart';
import 'ui/navigation/navigation_screen.dart';

class App extends StatefulWidget {
  const App({super.key});
  @override
  State<App> createState() => _AppState();
}

class _AppState extends State<App> {
  Session? _session;

  @override
  void initState() {
    super.initState();
    _session = Supabase.instance.client.auth.currentSession;
    Supabase.instance.client.auth.onAuthStateChange.listen((event) {
      setState(() => _session = event.session);
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      home: _session == null
          ? const LoginScreen()
          : const NavigationScreen(),
    );
  }
}



===== FILE: src\blocs\profile\edit_profile_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloudmate/src/blocs/profile/profile_cubit.dart';
import 'package:cloudmate/src/models/demo_user.dart';

class EditProfileScreen extends StatefulWidget {
  const EditProfileScreen({super.key});

  @override
  State<EditProfileScreen> createState() => _EditProfileScreenState();
}

class _EditProfileScreenState extends State<EditProfileScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _firstName;
  late TextEditingController _lastName;
  late TextEditingController _status;

  @override
  void initState() {
    super.initState();
    final user = profileCubit.state;
    _firstName = TextEditingController(text: user.firstName);
    _lastName  = TextEditingController(text: user.lastName);
    _status    = TextEditingController(text: user.status);
  }

  @override
  void dispose() {
    _firstName.dispose();
    _lastName.dispose();
    _status.dispose();
    super.dispose();
  }

  void _save() {
    if (_formKey.currentState?.validate() ?? false) {
      context.read<ProfileCubit>().update(
        firstName: _firstName.text.trim(),
        lastName: _lastName.text.trim(),
        status: _status.text.trim(),
      );
      Navigator.of(context).pop();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('РџСЂРѕС„РёР»СЊ РѕР±РЅРѕРІР»С‘РЅ')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider.value(
      value: profileCubit,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Р РµРґР°РєС‚РёСЂРѕРІР°С‚СЊ РїСЂРѕС„РёР»СЊ'),
          centerTitle: true,
          actions: [
            IconButton(onPressed: _save, icon: const Icon(Icons.check)),
          ],
        ),
        body: Padding(
          padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
          child: Form(
            key: _formKey,
            child: ListView(
              children: [
                _field(label: 'РРјСЏ', controller: _firstName, validatorMsg: 'Р’РІРµРґРёС‚Рµ РёРјСЏ'),
                _field(label: 'Р¤Р°РјРёР»РёСЏ', controller: _lastName, validatorMsg: 'Р’РІРµРґРёС‚Рµ С„Р°РјРёР»РёСЋ'),
                _field(label: 'РЎС‚Р°С‚СѓСЃ (РёРЅС‚СЂРѕ)', controller: _status, maxLines: 3),
                const SizedBox(height: 24),
                Text(
                  'РџРѕРґСЃРєР°Р·РєР°: СЌС‚Рѕ РѕС„Р»Р°Р№РЅ РґРµРјРѕ. Р”Р°РЅРЅС‹Рµ СЃРѕС…СЂР°РЅСЏСЋС‚СЃСЏ РІ РїР°РјСЏС‚Рё РґРѕ РїРµСЂРµР·Р°РїСѓСЃРєР° РїСЂРёР»РѕР¶РµРЅРёСЏ.',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(color: Colors.black54),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _field({
    required String label,
    required TextEditingController controller,
    String? validatorMsg,
    int maxLines = 1,
  }) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: TextFormField(
        controller: controller,
        maxLines: maxLines,
        decoration: InputDecoration(
          labelText: label,
          border: const OutlineInputBorder(),
        ),
        validator: (v) {
          if ((validatorMsg != null) && (v == null || v.trim().isEmpty)) return validatorMsg;
          return null;
        },
      ),
    );
  }
}



===== FILE: src\blocs\profile\profile_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../models/demo_user.dart';

class ProfileCubit extends Cubit<DemoUser> {
  ProfileCubit() : super(DemoUser.demo());

  void update({
    String? firstName,
    String? lastName,
    String? university,
    String? group,
    String? status,
    String? avatarPath,
  }) {
    emit(state.copyWith(
      firstName: firstName,
      lastName: lastName,
      university: university,
      group: group,
      status: status,
      avatarPath: avatarPath,
    ));
  }
}

// СЃРёРЅРіР»С‚РѕРЅ РґР»СЏ РґРµРјРѕ
final ProfileCubit profileCubit = ProfileCubit();



===== FILE: src\blocs\profile\profile_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:cloudmate/src/blocs/profile/profile_cubit.dart';
import 'package:cloudmate/src/models/demo_user.dart';

class ProfileScreen extends StatelessWidget {
  const ProfileScreen({super.key});

  void _logout(BuildContext context) {
    // GoRouter
    try {
      // РµСЃР»Рё РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ go_router
      // context.go('/login');
      Navigator.of(context).pushNamedAndRemoveUntil('/login', (r) => false);
    } catch (_) {
      Navigator.of(context).pushNamedAndRemoveUntil('/login', (r) => false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider.value(
      value: profileCubit,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('РџСЂРѕС„РёР»СЊ'),
          centerTitle: true,
          leading: IconButton(
            tooltip: 'Р РµРґР°РєС‚РёСЂРѕРІР°С‚СЊ',
            icon: const Icon(Icons.tune),
            onPressed: () {
              Navigator.of(context).pushNamed('/edit-profile');
            },
          ),
          actions: [
            IconButton(
              tooltip: 'Р’С‹Р№С‚Рё',
              icon: const Icon(Icons.logout),
              onPressed: () => _logout(context),
            ),
          ],
        ),
        body: BlocBuilder<ProfileCubit, DemoUser>(
          builder: (context, user) {
            return SingleChildScrollView(
              padding: const EdgeInsets.fromLTRB(16, 24, 16, 24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Center(
                    child: GestureDetector(
                      onTap: () {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('Р”РµРјРѕ-СЂРµР¶РёРј: СЃРјРµРЅР° Р°РІР°С‚Р°СЂР° РїРѕРєР° РЅРµРґРѕСЃС‚СѓРїРЅР°')),
                        );
                      },
                      child: CircleAvatar(
                        radius: 52,
                        backgroundColor: Colors.deepPurple.shade100,
                        backgroundImage:
                        user.avatarUrl != null ? NetworkImage(user.avatarUrl!) : null,
                        child: user.avatarUrl == null
                            ? const Icon(Icons.person, size: 48)
                            : null,
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Text(user.fullName,
                      style: Theme.of(context).textTheme.titleLarge),
                  const SizedBox(height: 6),
                  Text(user.email,
                      style: Theme.of(context)
                          .textTheme
                          .bodyMedium
                          ?.copyWith(color: Colors.black54)),
                  const SizedBox(height: 12),
                  Text(
                    user.status.isEmpty ? 'РЎС‚Р°С‚СѓСЃ РЅРµ СѓРєР°Р·Р°РЅ' : user.status,
                    style: Theme.of(context).textTheme.bodyLarge,
                  ),
                  const SizedBox(height: 24),

                  // РЎС‚Р°С‚РёСЃС‚РёРєР°
                  Row(
                    children: [
                      _StatCard(title: 'РЎРѕРѕР±С‰РµРЅРёСЏ', value: user.messagesCount.toString(), icon: Icons.chat_bubble_outline),
                      const SizedBox(width: 12),
                      _StatCard(title: 'Р”СЂСѓР·СЊСЏ', value: user.friendsCount.toString(), icon: Icons.group_outlined),
                    ],
                  ),

                  const SizedBox(height: 24),
                  // РџРµСЂРµС…РѕРґ Рє "Р—Р°С‡С‘С‚С‹ Рё Р­РєР·Р°РјРµРЅС‹"
                  SizedBox(
                    width: double.infinity,
                    child: ElevatedButton.icon(
                      onPressed: () => Navigator.of(context).pushNamed('/exams'),
                      icon: const Icon(Icons.school_outlined),
                      label: const Text('Р—Р°С‡С‘С‚С‹ Рё СЌРєР·Р°РјРµРЅС‹'),
                    ),
                  ),
                ],
              ),
            );
          },
        ),
        bottomNavigationBar: _DemoBottomNav(currentIndex: 4),
      ),
    );
  }
}

class _StatCard extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  const _StatCard({required this.title, required this.value, required this.icon});

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: Card(
        elevation: 0,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 12),
          child: Column(
            children: [
              Icon(icon),
              const SizedBox(height: 8),
              Text(value, style: Theme.of(context).textTheme.titleLarge),
              const SizedBox(height: 4),
              Text(title, style: const TextStyle(color: Colors.black54)),
            ],
          ),
        ),
      ),
    );
  }
}

// Р—Р°РіР»СѓС€РєР° РЅРёР¶РЅРµР№ РЅР°РІРёРіР°С†РёРё (С‡С‚РѕР±С‹ РІС‹РіР»СЏРґРµР»Рѕ РєР°Рє Сѓ С‚РµР±СЏ РЅР° СЃРєСЂРёРЅРµ)
class _DemoBottomNav extends StatelessWidget {
  final int currentIndex;
  const _DemoBottomNav({required this.currentIndex});
  @override
  Widget build(BuildContext context) {
    return BottomNavigationBar(
      currentIndex: currentIndex,
      type: BottomNavigationBarType.fixed,
      onTap: (_) {},
      items: const [
        BottomNavigationBarItem(icon: Icon(Icons.home_outlined), label: 'Р“Р»Р°РІРЅР°СЏ'),
        BottomNavigationBarItem(icon: Icon(Icons.info_outline), label: 'РџРѕР»РµР·РЅР°СЏ'),
        BottomNavigationBarItem(icon: Icon(Icons.menu_book_outlined), label: 'РћР±СѓС‡РµРЅРёРµ'),
        BottomNavigationBarItem(icon: Icon(Icons.event_note_outlined), label: 'Р Р°СЃРїРёСЃР°РЅРёРµ'),
        BottomNavigationBarItem(icon: Icon(Icons.person_outline), label: 'РџСЂРѕС„РёР»СЊ'),
      ],
    );
  }
}



===== FILE: src\config\supabase_config.dart =====
  static Future<void> init() async {
    if (_inited) return;
    await Supabase.initialize(
      url: const String.fromEnvironment('https://gwdanmwluhrcfxbnplwd.supabase.co'),
      anonKey: const String.fromEnvironment('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3ZGFubXdsdWhyY2Z4Ym5wbHdkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNjM1MTgsImV4cCI6MjA3MDgzOTUxOH0.tBZ7b_FyOxPWiqkFQf1OIh9c6hJ7Fm2eHyjsDjoBoSA'),
      debug: false,
    );
    _inited = true;
  }

  static SupabaseClient get client => Supabase.instance.client;
}

}



===== FILE: src\models\demo_user.dart =====
class DemoUser {
  final String firstName;
  final String lastName;

  /// Р’РЈР— Рё РєСѓСЂСЃ (СЃС‚СЂРѕРєР° СЃ РЅРѕРјРµСЂРѕРј: "1", "2" Рё С‚.Рґ.)
  final String university;
  final String group; // РёСЃРїРѕР»СЊР·СѓРµРј РєР°Рє "РєСѓСЂСЃ"

  /// РЎС‚Р°С‚СѓСЃ/РёРЅС‚СЂРѕ
  final String status;

  /// РЎС‚Р°С‚РёСЃС‚РёРєР°
  final int messagesCount;
  final int friendsCount;

  /// РђРІР°С‚Р°СЂ: Р»РѕРєР°Р»СЊРЅС‹Р№ РїСѓС‚СЊ (РґРµРјРѕ) РёР»Рё url (РЅР° Р±СѓРґСѓС‰РµРµ)
  final String? avatarPath;
  final String? avatarUrl;

  const DemoUser({
    required this.firstName,
    required this.lastName,
    required this.university,
    required this.group,
    required this.status,
    required this.messagesCount,
    required this.friendsCount,
    this.avatarPath,
    this.avatarUrl,
  });

  String get fullName =>
      [firstName, lastName].where((e) => e.trim().isNotEmpty).join(' ').trim();

  DemoUser copyWith({
    String? firstName,
    String? lastName,
    String? university,
    String? group,
    String? status,
    int? messagesCount,
    int? friendsCount,
    String? avatarPath,
    String? avatarUrl,
  }) {
    return DemoUser(
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      university: university ?? this.university,
      group: group ?? this.group,
      status: status ?? this.status,
      messagesCount: messagesCount ?? this.messagesCount,
      friendsCount: friendsCount ?? this.friendsCount,
      avatarPath: avatarPath ?? this.avatarPath,
      avatarUrl: avatarUrl ?? this.avatarUrl,
    );
  }

  factory DemoUser.demo() => const DemoUser(
        firstName: 'РРІР°РЅ',
        lastName: 'РРІР°РЅРѕРІ',
        university: 'РЎРџР±Р“РђРЎРЈ',
        group: '1', // СЃС‚СѓРґРµРЅС‚ 1 РєСѓСЂСЃ
        status: 'Р“РѕС‚РѕРІР»СЋСЃСЊ Рє СЃРµСЃСЃРёРё рџ’Є',
        messagesCount: 42,
        friendsCount: 7,
        avatarPath: null,
        avatarUrl: null,
      );
}



===== FILE: src\screens\calendar_screen.dart =====
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class CalendarScreen extends StatelessWidget {
  const CalendarScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // Р’СЂРµРјРµРЅРЅРѕ РїСѓСЃС‚РѕР№ СЃРїРёСЃРѕРє СЃРѕР±С‹С‚РёР№
    final List<String> events = [];

    return Scaffold(
      appBar: AppBar(
        title: const Text('РљР°Р»РµРЅРґР°СЂСЊ'),
        centerTitle: true,
      ),
      body: events.isEmpty
          ? _buildEmptyState()
          : ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: events.length,
              itemBuilder: (context, index) {
                return Card(
                  elevation: 1,
                  child: ListTile(
                    title: Text(events[index]),
                    subtitle: const Text('Р”РµС‚Р°Р»Рё СЃРѕР±С‹С‚РёСЏ...'),
                  ),
                );
              },
            ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Lottie.asset(
            'assets/lottie/cat_sleeping.json',
            width: 150,
            height: 150,
            repeat: true,
          ),
          const SizedBox(height: 16),
          const Text(
            'Р—РґРµСЃСЊ РїРѕРєР° РїСѓСЃС‚Рѕ',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          const Text(
            'Р”РѕР±Р°РІСЊС‚Рµ СЃРѕР±С‹С‚РёСЏ РІ РєР°Р»РµРЅРґР°СЂСЊ, С‡С‚РѕР±С‹ РѕРЅРѕ РїРѕСЏРІРёР»РѕСЃСЊ Р·РґРµСЃСЊ.',
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 14, color: Colors.grey),
          ),
        ],
      ),
    );
  }
}



===== FILE: src\screens\classes_screen.dart =====
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class ClassesScreen extends StatelessWidget {
  const ClassesScreen({super.key});

  final bool _hasClasses = false; // РґРµРјРѕ: РЅРµС‚ Р·Р°РЅСЏС‚РёР№

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Р—Р°РЅСЏС‚РёСЏ'),
        centerTitle: true,
      ),
      body: _hasClasses ? _buildClassesList() : _buildEmptyState(),
    );
  }

  Widget _buildClassesList() {
    final classes = [
      {'subject': 'РњР°С‚РµРјР°С‚РёРєР°', 'location': 'РђСѓРґ. 203', 'time': '08:30'},
      {'subject': 'РСЃС‚РѕСЂРёСЏ', 'location': 'РђСѓРґ. 105', 'time': '10:20'},
      {'subject': 'Р¤РёР·РёРєР°', 'location': 'РђСѓРґ. 307', 'time': '13:00'},
    ];

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: classes.length,
      itemBuilder: (context, index) {
        final c = classes[index];
        return Card(
          elevation: 1,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          child: ListTile(
            leading: const Icon(Icons.book, color: Colors.blue),
            title: Text(c['subject']!),
            subtitle: Text('${c['location']} вЂў ${c['time']}'),
            trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          ),
        );
      },
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: SingleChildScrollView(
        physics: const NeverScrollableScrollPhysics(),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset(
              'assets/lottie/cat_sleeping.json', // СЂР°Р±РѕС‡Р°СЏ РєРѕС€РєР° РёР· РєР°Р»РµРЅРґР°СЂСЏ
              width: 200,
              height: 200,
              repeat: true,
            ),
            const SizedBox(height: 16),
            const Text(
              'Р—Р°РЅСЏС‚РёР№ РїРѕРєР° РЅРµС‚',
              style: TextStyle(fontSize: 16, color: Colors.grey),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\screens\home_screen.dart =====
import 'package:flutter/material.dart';
import '../widgets/empty_state_widget.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final List<String> news = [];

    return Scaffold(
      appBar: AppBar(
        title: const Text('Р“Р»Р°РІРЅР°СЏ'),
        centerTitle: true,
      ),
      body: news.isEmpty
          ? const SingleChildScrollView(
              physics: NeverScrollableScrollPhysics(),
              child: SizedBox(
                height: 500, // С„РёРєС‚РёРІРЅР°СЏ РІС‹СЃРѕС‚Р° РґР»СЏ С†РµРЅС‚СЂРёСЂРѕРІР°РЅРёСЏ
                child: Center(
                  child: EmptyStateWidget(
                    title: 'Р—РґРµСЃСЊ РїРѕРєР° РїСѓСЃС‚Рѕ',
                    subtitle: 'РќРѕРІРѕСЃС‚Рё РїРѕСЏРІСЏС‚СЃСЏ Р·РґРµСЃСЊ.',
                  ),
                ),
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: news.length,
              itemBuilder: (context, index) {
                return ListTile(
                  title: Text(news[index]),
                );
              },
            ),
    );
  }
}



===== FILE: src\screens\login_screen.dart =====
import 'package:flutter/material.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _studentIdController = TextEditingController();
  final _passwordController = TextEditingController();

  void _loginDemo() {
    Navigator.pushReplacementNamed(context, '/home');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 40),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              const SizedBox(height: 40),
              // Р›РѕРіРѕС‚РёРї
              Image.asset(
                'assets/icons/launcher_icon.png',
                height: 120,
              ),
              const SizedBox(height: 20),
              const Text(
                'Р”РѕР±СЂРѕ РїРѕР¶Р°Р»РѕРІР°С‚СЊ!',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 30),

              // РџРѕР»Рµ СЃС‚СѓРґРµРЅС‡РµСЃРєРѕРіРѕ РЅРѕРјРµСЂР°
              TextField(
                controller: _studentIdController,
                keyboardType: TextInputType.number,
                decoration: InputDecoration(
                  labelText: 'РЎС‚СѓРґРµРЅС‡РµСЃРєРёР№ РЅРѕРјРµСЂ',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  prefixIcon: const Icon(Icons.badge_outlined),
                ),
              ),
              const SizedBox(height: 16),

              // РџРѕР»Рµ РїР°СЂРѕР»СЏ
              TextField(
                controller: _passwordController,
                obscureText: true,
                decoration: InputDecoration(
                  labelText: 'РџР°СЂРѕР»СЊ',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  prefixIcon: const Icon(Icons.lock_outline),
                ),
              ),
              const SizedBox(height: 30),

              // РљРЅРѕРїРєР° РІС…РѕРґР° (РґРµРјРѕ)
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 14),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onPressed: _loginDemo,
                  child: const Text(
                    'Р’РѕР№С‚Рё (РґРµРјРѕ)',
                    style: TextStyle(fontSize: 16),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



===== FILE: src\screens\navigation_screen.dart =====
import 'package:flutter/material.dart';
import 'home_screen.dart';
import 'classes_screen.dart';
import 'teams_screen.dart'; // СѓР±РµРґРёСЃСЊ, С‡С‚Рѕ С„Р°Р№Р» Рё РєР»Р°СЃСЃ РЅР°Р·С‹РІР°СЋС‚СЃСЏ С‚Р°Рє
import 'calendar_screen.dart';
import 'profile_screen.dart';

class NavigationScreen extends StatefulWidget {
  const NavigationScreen({super.key});

  @override
  State<NavigationScreen> createState() => _NavigationScreenState();
}

class _NavigationScreenState extends State<NavigationScreen> {
  int _currentIndex = 0;

  final List<Widget> _screens = const [
    HomeScreen(),
    ClassesScreen(),
    TeamsScreen(), // РЅР°Р·РІР°РЅРёРµ РєР»Р°СЃСЃР° СЃРѕРІРїР°РґР°РµС‚ СЃ С„Р°Р№Р»РѕРј
    CalendarScreen(),
    ProfileScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _screens[_currentIndex],
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        type: BottomNavigationBarType.fixed,
        selectedItemColor: Colors.blue,
        unselectedItemColor: Colors.grey,
        onTap: (index) {
          setState(() {
            _currentIndex = index;
          });
        },
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home_outlined),
            activeIcon: Icon(Icons.home),
            label: 'Р“Р»Р°РІРЅР°СЏ',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.book_outlined),
            activeIcon: Icon(Icons.book),
            label: 'Р—Р°РЅСЏС‚РёСЏ',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.groups_outlined),
            activeIcon: Icon(Icons.groups),
            label: 'РљРѕРјР°РЅРґС‹',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.calendar_today_outlined),
            activeIcon: Icon(Icons.calendar_today),
            label: 'РљР°Р»РµРЅРґР°СЂСЊ',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person_outline),
            activeIcon: Icon(Icons.person),
            label: 'РџСЂРѕС„РёР»СЊ',
          ),
        ],
      ),
    );
  }
}



===== FILE: src\screens\profile_screen.dart =====
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class ProfileScreen extends StatefulWidget {
  const ProfileScreen({super.key});

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  bool _hasProfile = false; // РґРµРјРѕ: РїСЂРѕС„РёР»СЊ РЅРµ Р·Р°РїРѕР»РЅРµРЅ

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('РџСЂРѕС„РёР»СЊ'),
        centerTitle: true,
      ),
      body: _hasProfile ? _buildProfileView() : _buildEmptyState(),
    );
  }

  Widget _buildProfileView() {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const CircleAvatar(
          radius: 50,
          backgroundImage: AssetImage('assets/images/avatar_placeholder.png'),
        ),
        const SizedBox(height: 16),
        const Text(
          'РРІР°РЅ РРІР°РЅРѕРІ',
          style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 8),
        const Text(
          'Р“СЂСѓРїРїР°: РРЎ-21',
          style: TextStyle(color: Colors.grey),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 24),
        ElevatedButton.icon(
          onPressed: () {
            setState(() {
              _hasProfile = false; // Р·РґРµСЃСЊ РјРѕР¶РЅРѕ РјРµРЅСЏС‚СЊ РЅР° true РїСЂРё Р·Р°РіСЂСѓР·РєРµ РґР°РЅРЅС‹С…
            });
          },
          icon: const Icon(Icons.edit),
          label: const Text('Р РµРґР°РєС‚РёСЂРѕРІР°С‚СЊ РїСЂРѕС„РёР»СЊ'),
          style: ElevatedButton.styleFrom(
            minimumSize: const Size.fromHeight(48),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: SingleChildScrollView(
        physics: const NeverScrollableScrollPhysics(),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset(
              'assets/lottie/cat_sleeping.json', // РєРѕС€РєР°
              width: 200,
              height: 200,
              repeat: true,
            ),
            const SizedBox(height: 16),
            const Text(
              'РџСЂРѕС„РёР»СЊ РїРѕРєР° РЅРµ Р·Р°РїРѕР»РЅРµРЅ',
              style: TextStyle(fontSize: 16, color: Colors.grey),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\screens\register_screen.dart =====
import 'package:flutter/material.dart';
import 'login_screen.dart';

class RegisterPage extends StatefulWidget {
  const RegisterPage({super.key});

  @override
  State<RegisterPage> createState() => _RegisterPageState();
}

class _RegisterPageState extends State<RegisterPage> {
  final _emailCtrl = TextEditingController();
  final _passCtrl = TextEditingController();

  void _register() {
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(builder: (_) => const LoginPage()),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.person_add, size: 80, color: Colors.blue),
            const SizedBox(height: 20),
            TextField(
              controller: _emailCtrl,
              decoration: const InputDecoration(
                labelText: 'Email / РЎС‚СѓРґРµРЅС‡РµСЃРєРёР№ РЅРѕРјРµСЂ',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _passCtrl,
              obscureText: true,
              decoration: const InputDecoration(
                labelText: 'РџР°СЂРѕР»СЊ',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _register,
              style: ElevatedButton.styleFrom(
                minimumSize: const Size.fromHeight(50),
              ),
              child: const Text('Р—Р°СЂРµРіРёСЃС‚СЂРёСЂРѕРІР°С‚СЊСЃСЏ'),
            ),
            const SizedBox(height: 12),
            TextButton(
              onPressed: () {
                Navigator.pushReplacement(
                  context,
                  MaterialPageRoute(builder: (_) => const LoginPage()),
                );
              },
              child: const Text('РЈР¶Рµ РµСЃС‚СЊ Р°РєРєР°СѓРЅС‚? Р’РѕР№С‚Рё'),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\screens\splash_screen.dart =====
import 'package:flutter/material.dart';
import 'dart:async';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  Timer? _timer;

  @override
  void initState() {
    super.initState();

    _timer = Timer(const Duration(seconds: 2), () {
      if (mounted) {
        Navigator.pushReplacementNamed(context, '/login');
      }
    });
  }

  @override
  void dispose() {
    _timer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Image.asset(
              'assets/icons/launcher_icon.png',
              width: 120,
              height: 120,
            ),
            const SizedBox(height: 20),
            const Text(
              'Student Platform',
              style: TextStyle(
                fontSize: 22,
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\screens\teams_screen.dart =====
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class TeamsScreen extends StatelessWidget {
  const TeamsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("РљРѕРјР°РЅРґС‹"),
        centerTitle: true,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset(
              'assets/lottie/cat_sleeping.json', // Р·Р°РјРµРЅРёР» РЅР° СЂР°Р±РѕС‡СѓСЋ РєРѕС€РєСѓ РёР· РєР°Р»РµРЅРґР°СЂСЏ
              width: 180,
              height: 180,
              repeat: true,
            ),
            const SizedBox(height: 16),
            const Text(
              "Р—РґРµСЃСЊ Р±СѓРґСѓС‚ РІР°С€Рё РєРѕРјР°РЅРґС‹",
              style: TextStyle(fontSize: 16, color: Colors.grey),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\theme.dart =====
import 'package:flutter/material.dart';

/// ==== Р¦РІРµС‚Р° (РІР·СЏС‚С‹ РёР· Cloudmate СЃС‚РёР»СЏ) ====
const _colorBlack = Color(0xFF121212);
const _colorPrimaryBlack = Color(0xFF14171A);
const _colorPrimary = Color(0xFF1DA1F2);

final Color _mC = Colors.grey.shade100; // background СЃРІРµС‚Р»С‹Р№
final Color _mCL = Colors.white;        // surface
final Color _mCM = Colors.grey.shade200;
final Color _mCH = Colors.grey.shade400;

class CApp {
  final Color primary;
  final Color background;
  final Color accent;
  final Color disabled;
  final Color error;
  final Color divider;
  final Color button;
  final Color text1;
  final Color text2;

  const CApp({
    required this.primary,
    required this.background,
    required this.accent,
    required this.disabled,
    required this.error,
    required this.divider,
    required this.button,
    required this.text1,
    required this.text2,
  });

  factory CApp.light() => CApp(
    primary: _colorPrimary,
    background: _mC,
    accent: const Color(0xFF17C063),
    disabled: Colors.black12,
    error: const Color(0xFFFF7466),
    divider: Colors.black26,
    button: const Color(0xFF657786),
    text1: _colorBlack,
    text2: _colorPrimaryBlack,
  );

  factory CApp.dark() => CApp(
    primary: _colorPrimary,
    background: const Color(0xFF14171A),
    accent: const Color(0xFF17C063),
    disabled: Colors.white12,
    error: const Color(0xFFFF5544),
    divider: Colors.white24,
    button: Colors.white,
    text1: _mCL,
    text2: _mCL,
  );
}

class AppTheme {
  static ThemeData light =
  _themeFrom(CApp.light(), brightness: Brightness.light);
  static ThemeData dark =
  _themeFrom(CApp.dark(), brightness: Brightness.dark);

  static ThemeData _themeFrom(CApp c, {required Brightness brightness}) {
    const uiFont = 'Lato'; // РѕСЃРЅРѕРІРЅРѕР№ С€СЂРёС„С‚ UI

    final scheme = ColorScheme(
      brightness: brightness,
      primary: c.primary,
      onPrimary: Colors.white,
      secondary: c.accent,
      onSecondary: Colors.white,
      error: c.error,
      onError: Colors.white,
      surface: _mCL,
      onSurface: c.text1,
      background: c.background,
      onBackground: c.text1,
      outline: c.divider,
    );

    return ThemeData(
      useMaterial3: true,
      colorScheme: scheme,
      scaffoldBackgroundColor: c.background,
      appBarTheme: AppBarTheme(
        backgroundColor: _mCL,
        elevation: 0,
        scrolledUnderElevation: 0,
        centerTitle: true,
        foregroundColor: c.text1,
        titleTextStyle: TextStyle(
          fontFamily: uiFont,
          fontWeight: FontWeight.w700,
          fontSize: 18,
          color: c.text1,
        ),
      ),
      textTheme: TextTheme(
        displaySmall: TextStyle(
            fontFamily: uiFont,
            fontWeight: FontWeight.w700,
            fontSize: 28,
            color: c.text1),
        titleLarge: TextStyle(
            fontFamily: uiFont,
            fontWeight: FontWeight.w700,
            fontSize: 22,
            color: c.text1),
        titleMedium: TextStyle(
            fontFamily: uiFont,
            fontWeight: FontWeight.w600,
            fontSize: 18,
            color: c.text1),
        bodyLarge: TextStyle(
            fontFamily: uiFont,
            fontWeight: FontWeight.w500,
            fontSize: 16,
            color: c.text2),
        bodyMedium: TextStyle(
            fontFamily: uiFont,
            fontWeight: FontWeight.w400,
            fontSize: 14,
            color: c.text2),
        labelLarge: TextStyle(
            fontFamily: uiFont,
            fontWeight: FontWeight.w600,
            fontSize: 14,
            color: c.text1),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: _mCL,
        contentPadding:
        const EdgeInsets.symmetric(horizontal: 14, vertical: 14),
        hintStyle: TextStyle(color: _mCH),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(16),
          borderSide: BorderSide(color: _mCH),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(16),
          borderSide: BorderSide(color: _mCH),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(16),
          borderSide: BorderSide(color: c.primary, width: 2),
        ),
      ),
      cardTheme: CardThemeData(
        color: _mCL,
        elevation: 0,
        margin: EdgeInsets.zero,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
      ),
      dividerColor: c.divider,
    );
  }
}



===== FILE: src\themes\app_colors.dart =====
import 'package:flutter/material.dart';

var colorBlack = const Color(0xFF121212);
var colorPrimaryBlack = const Color(0xFF14171A);
var colorDarkGrey = const Color(0xFF657786);
var colorPrimary = const Color(0xFF1DA1F2);
var colorTitle = const Color(0xFF2C3D50);

var colorHigh = Colors.redAccent;
var colorMedium = Colors.amber;
var colorLow = colorPrimary;
var colorCompleted = Colors.green;
var colorFailed = colorDarkGrey;
var colorActive = const Color(0xFF00D72F);
var colorGreenLight = const Color(0xFF009E60);
var colorAttendance = const Color(0xFF0CCF4C);

Color mC = Colors.grey.shade100;
Color mCL = Colors.white;
Color mCM = Colors.grey.shade200;
Color mCH = Colors.grey.shade400;
Color mCD = Colors.black.withOpacity(0.075);

class AppColors {
  final Color primary;
  final Color background;
  final Color accent;
  final Color disabled;
  final Color error;
  final Color divider;
  final Color header;
  final Color button;
  final Color contentText1;
  final Color contentText2;

  const AppColors({
    required this.header,
    required this.primary,
    required this.background,
    required this.accent,
    required this.disabled,
    required this.error,
    required this.divider,
    required this.button,
    required this.contentText1,
    required this.contentText2,
  });

  factory AppColors.light() {
    return AppColors(
      header: colorBlack,
      primary: colorPrimary,
      background: mC,
      accent: const Color(0xFF17c063),
      disabled: Colors.black12,
      error: const Color(0xFFFF7466),
      divider: Colors.black26,
      button: colorDarkGrey,
      contentText1: colorBlack,
      contentText2: colorPrimaryBlack,
    );
  }

  factory AppColors.dark() {
    return AppColors(
      header: Colors.white,
      primary: colorPrimary,
      background: colorPrimaryBlack,
      accent: const Color(0xFF17c063),
      disabled: Colors.white12,
      error: const Color(0xFFFF5544),
      divider: Colors.white24,
      button: Colors.white,
      contentText1: mCL,
      contentText2: mCL,
    );
  }
}



===== FILE: src\themes\app_decorations.dart =====
import 'package:flutter/material.dart';
import 'app_colors.dart';

class AppDecoration {
  final BoxDecoration decoration;
  AppDecoration({required this.decoration});

  factory AppDecoration.containerOnlyShadowTop(BuildContext context) {
    if (Theme.of(context).brightness == Brightness.dark) {
      return AppDecoration(
        decoration: BoxDecoration(
          color: colorPrimaryBlack,
          boxShadow: [
            BoxShadow(
              color: colorBlack.withOpacity(.65),
              offset: const Offset(-2, -2),
              blurRadius: 10,
            ),
          ],
        ),
      );
    } else {
      return AppDecoration(
        decoration: BoxDecoration(
          color: mC,
          boxShadow: [
            BoxShadow(
              color: mCL,
              offset: const Offset(-2, -2),
              blurRadius: 10,
            ),
          ],
        ),
      );
    }
  }
}



===== FILE: src\themes\font_family.dart =====
class FontFamily {
  FontFamily._();

  static const String lato = 'Lato';
  static const String allison = 'Allison';
  static const String dancing = 'DancingScript';
}



===== FILE: src\themes\theme_service.dart =====
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get_storage/get_storage.dart';

enum ThemeOptions { light, dark }

class ThemeService extends ChangeNotifier {
  static ThemeOptions themeOptions = ThemeOptions.light;
  static ThemeMode currentTheme = ThemeMode.light;

  static final systemBrightness = const SystemUiOverlayStyle(
    statusBarColor: Colors.transparent,
  );

  final _getStorage = GetStorage();
  final storageKey = 'isDarkMode';

  switchStatusColor() {
    SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarBrightness: Platform.isIOS
          ? (isSavedDarkMode() ? Brightness.dark : Brightness.light)
          : (isSavedDarkMode() ? Brightness.light : Brightness.dark),
      statusBarIconBrightness: Platform.isIOS
          ? (isSavedDarkMode() ? Brightness.dark : Brightness.light)
          : (isSavedDarkMode() ? Brightness.light : Brightness.dark),
    ));
  }

  ThemeMode getThemeMode() {
    switchStatusColor();
    return isSavedDarkMode() ? ThemeMode.dark : ThemeMode.light;
  }

  bool isSavedDarkMode() {
    return _getStorage.read(storageKey) ?? false;
  }

  void saveThemeMode(bool isDarkMode) async {
    _getStorage.write(storageKey, isDarkMode);
  }

  void changeThemeMode() {
    saveThemeMode(!isSavedDarkMode());
    switchStatusColor();
    notifyListeners();
  }
}

ThemeService themeService = ThemeService();



===== FILE: src\themes\themes.dart =====
import 'package:flutter/material.dart';
import 'app_colors.dart';

class AppTheme {
  AppTheme({
    required this.mode,
    required this.data,
    required this.appColors,
  });

  factory AppTheme.light() {
    final mode = ThemeMode.light;
    final appColors = AppColors.light();
    final themeData = ThemeData.light().copyWith(
      primaryColor: appColors.primary,
      scaffoldBackgroundColor: appColors.background,
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: appColors.background,
        selectedItemColor: colorPrimary,
      ),
      appBarTheme: AppBarTheme(
        backgroundColor: appColors.background,
        iconTheme: IconThemeData(color: appColors.contentText1),
      ),
      textTheme: TextTheme(
        displayLarge: TextStyle(color: appColors.header),
        bodyLarge: TextStyle(color: appColors.contentText1),
        bodyMedium: TextStyle(color: appColors.contentText2),
      ),
      dividerColor: appColors.divider,
    );
    return AppTheme(mode: mode, data: themeData, appColors: appColors);
  }

  factory AppTheme.dark() {
    final mode = ThemeMode.dark;
    final appColors = AppColors.dark();
    final themeData = ThemeData.dark().copyWith(
      primaryColor: appColors.primary,
      scaffoldBackgroundColor: appColors.background,
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: appColors.background,
        selectedItemColor: colorPrimary,
      ),
      appBarTheme: AppBarTheme(
        backgroundColor: appColors.background,
        iconTheme: IconThemeData(color: appColors.contentText1),
      ),
      textTheme: TextTheme(
        displayLarge: TextStyle(color: appColors.header),
        bodyLarge: TextStyle(color: appColors.contentText1),
        bodyMedium: TextStyle(color: appColors.contentText2),
      ),
      dividerColor: appColors.divider,
    );
    return AppTheme(mode: mode, data: themeData, appColors: appColors);
  }

  final ThemeMode mode;
  final ThemeData data;
  final AppColors appColors;
}



===== FILE: src\ui\authentication\authenticate_screen.dart =====
import 'package:flutter/material.dart';
import 'screens/login_screen.dart';
import 'screens/register_screen.dart';

class AuthenticateScreen extends StatefulWidget {
  const AuthenticateScreen({super.key});

  @override
  State<AuthenticateScreen> createState() => _AuthenticateScreenState();
}

class _AuthenticateScreenState extends State<AuthenticateScreen> {
  bool _signIn = true;

  void _toggle() => setState(() => _signIn = !_signIn);

  @override
  Widget build(BuildContext context) {
    return _signIn
        ? LoginScreen(toggleView: _toggle)
        : RegisterScreen(toggleView: _toggle);
  }
}



===== FILE: src\ui\authentication\screens\login_screen.dart =====
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:go_router/go_router.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key, required this.toggleView});
  final VoidCallback toggleView;

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _loginCtrl = TextEditingController();   // Р»РѕРіРёРЅ (в„– Р·Р°С‡С‘С‚РєРё) РёР»Рё email
  final _passCtrl  = TextEditingController();
  bool _hidePassword = true;
  bool _loading = false;

  final _sb = Supabase.instance.client;

  // === РњР°РїРїРёРЅРі Р»РѕРіРёРЅР° РІ email РґР»СЏ Auth ===
  // Р•СЃР»Рё РїРѕР»СЊР·РѕРІР°С‚РµР»СЊ РІРІС‘Р» "13015@app.local" вЂ” Р±РµСЂС‘Рј РєР°Рє РµСЃС‚СЊ.
  // Р•СЃР»Рё РІРІС‘Р» "13015" вЂ” РґРѕР±Р°РІР»СЏРµРј "@app.local".
  static const _authDomain = 'app.local';
  String _loginToEmail(String input) {
    final v = input.trim().toLowerCase();
    if (v.contains('@')) return v;
    return '$v@$_authDomain';
  }

  Future<void> _doLogin() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _loading = true);
    final login = _loginCtrl.text.trim();
    final pass  = _passCtrl.text;

    try {
      // 1) Auth login
      final email = _loginToEmail(login);
      await _sb.auth.signInWithPassword(email: email, password: pass);

      // 2) РџСЂРѕС„РёР»СЊ РёР· public.users РїРѕ auth.uid()
      final uid = _sb.auth.currentUser?.id;
      if (uid == null) throw 'РќРµ СѓРґР°Р»РѕСЃСЊ РїРѕР»СѓС‡РёС‚СЊ СЃРµСЃСЃРёСЋ';

      final row = await _sb
          .from('users')
          .select('id, login, name, surname, university, group_name, avatar_url, status, role')
          .eq('id', uid)
          .maybeSingle();

      if (row == null) throw 'РџСЂРѕС„РёР»СЊ РЅРµ РЅР°Р№РґРµРЅ';

      final data = Map<String, dynamic>.from(row as Map);

      // 3) РЎРѕС…СЂР°РЅСЏРµРј Р»РѕРєР°Р»СЊРЅРѕ Рё СѓС…РѕРґРёРј РЅР° /home
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool('loggedIn', true);
      await prefs.setString('user', jsonEncode(data));

      if (!mounted) return;
      try {
        context.go('/home');
      } catch (_) {
        Navigator.of(context).pushReplacementNamed('/home');
      }
    } on AuthException catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(e.message)),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('$e')),
      );
    } finally {
      if (mounted) setState(() => _loading = false); // СЃРїРёРЅРЅРµСЂ РІСЃРµРіРґР° РіР°СЃРёРј
    }
  }

  @override
  void dispose() {
    _loginCtrl.dispose();
    _passCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      resizeToAvoidBottomInset: false,
      appBar: AppBar(
        title: const Text('Р’С…РѕРґ'),
        centerTitle: true,
      ),
      body: SafeArea(
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              const SizedBox(height: 8),
              SizedBox(
                height: 200,
                child: Lottie.asset('assets/lottie/cat_sleeping.json'),
              ),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: Container(
                  decoration: BoxDecoration(
                    color: theme.cardColor,
                    borderRadius: BorderRadius.circular(12),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 10,
                      ),
                    ],
                  ),
                  child: Column(
                    children: [
                      const SizedBox(height: 8),
                      _buildField(
                        label: 'Р›РѕРіРёРЅ (в„– Р·Р°С‡С‘С‚РєРё) РёР»Рё email',
                        controller: _loginCtrl,
                        keyboardType: TextInputType.text,
                        validator: (v) =>
                            (v == null || v.trim().isEmpty)
                                ? 'Р’РІРµРґРёС‚Рµ Р»РѕРіРёРЅ'
                                : null,
                      ),
                      const Divider(height: 1),
                      _buildField(
                        label: 'РџР°СЂРѕР»СЊ',
                        controller: _passCtrl,
                        obscure: _hidePassword,
                        validator: (v) =>
                            (v == null || v.trim().length < 4)
                                ? 'РњРёРЅРёРјСѓРј 4 СЃРёРјРІРѕР»Р°'
                                : null,
                        suffix: IconButton(
                          onPressed: () =>
                              setState(() => _hidePassword = !_hidePassword),
                          icon: Icon(
                            _hidePassword
                                ? Icons.visibility_off
                                : Icons.visibility,
                          ),
                        ),
                      ),
                      const SizedBox(height: 8),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 12),
              TextButton(
                onPressed: widget.toggleView,
                child: const Text('РќРµС‚ Р°РєРєР°СѓРЅС‚Р°? Р—Р°СЂРµРіРёСЃС‚СЂРёСЂРѕРІР°С‚СЊСЃСЏ'),
              ),
              const SizedBox(height: 6),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: SizedBox(
                  width: double.infinity,
                  height: 48,
                  child: FilledButton(
                    onPressed: _loading ? null : _doLogin,
                    child: _loading
                        ? const SizedBox(
                            width: 20,
                            height: 20,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Text('Р’РѕР№С‚Рё'),
                  ),
                ),
              ),
              const Spacer(),
              Padding(
                padding: const EdgeInsets.only(bottom: 12),
                child: Text(
                  'В© ${DateTime.now().year} Student Platform',
                  style: theme.textTheme.bodySmall,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildField({
    required String label,
    required TextEditingController controller,
    String? Function(String?)? validator,
    TextInputType? keyboardType,
    bool obscure = false,
    Widget? suffix,
  }) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 12, 8, 12),
      child: TextFormField(
        controller: controller,
        validator: validator,
        keyboardType: keyboardType,
        obscureText: obscure,
        decoration: InputDecoration(
          labelText: label,
          border: InputBorder.none,
          suffixIcon: suffix,
        ),
      ),
    );
  }
}



===== FILE: src\ui\authentication\screens\register_screen.dart =====
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class RegisterScreen extends StatefulWidget {
  const RegisterScreen({super.key, required this.toggleView});
  final VoidCallback toggleView;

  @override
  State<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends State<RegisterScreen> {
  final _formKey = GlobalKey<FormState>();
  final _firstName = TextEditingController();
  final _lastName  = TextEditingController();
  final _email     = TextEditingController();
  final _password  = TextEditingController();
  final _confirm   = TextEditingController();
  bool _hidePassword = true;

  @override
  void dispose() {
    _firstName.dispose();
    _lastName.dispose();
    _email.dispose();
    _password.dispose();
    _confirm.dispose();
    super.dispose();
  }

  void _register() {
    if (!_formKey.currentState!.validate()) return;
    // DEMO: РїСЂРѕСЃС‚Рѕ РїРѕРєР°Р·С‹РІР°РµРј СЃРЅРµРє Рё РїРµСЂРµРєР»СЋС‡Р°РµРјСЃСЏ РЅР° СЌРєСЂР°РЅ РІС…РѕРґР°
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('РђРєРєР°СѓРЅС‚ СЃРѕР·РґР°РЅ (РґРµРјРѕ)')),
    );
    widget.toggleView();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Р РµРіРёСЃС‚СЂР°С†РёСЏ'),
        centerTitle: true,
      ),
      body: SafeArea(
        child: Form(
          key: _formKey,
          child: ListView(
            padding: const EdgeInsets.fromLTRB(16, 8, 16, 16),
            children: [
              SizedBox(
                height: 140,
                child: Lottie.asset('assets/lottie/cat_sleeping.json'),
              ),
              const SizedBox(height: 8),
              _buildField(
                label: 'Р¤Р°РјРёР»РёСЏ',
                controller: _firstName,
                validator: (v) =>
                    (v == null || v.trim().isEmpty) ? 'Р—Р°РїРѕР»РЅРёС‚Рµ РїРѕР»Рµ' : null,
              ),
              const Divider(height: 1),
              _buildField(
                label: 'РРјСЏ',
                controller: _lastName,
                validator: (v) =>
                    (v == null || v.trim().isEmpty) ? 'Р—Р°РїРѕР»РЅРёС‚Рµ РїРѕР»Рµ' : null,
              ),
              const Divider(height: 1),
              _buildField(
                label: 'Email',
                controller: _email,
                keyboardType: TextInputType.emailAddress,
                validator: (v) =>
                    (v == null || !v.contains('@')) ? 'Р’РІРµРґРёС‚Рµ РєРѕСЂСЂРµРєС‚РЅС‹Р№ email' : null,
              ),
              const Divider(height: 1),
              _buildField(
                label: 'РџР°СЂРѕР»СЊ',
                controller: _password,
                obscure: _hidePassword,
                validator: (v) =>
                    (v == null || v.trim().length < 4) ? 'РњРёРЅРёРјСѓРј 4 СЃРёРјРІРѕР»Р°' : null,
                suffix: IconButton(
                  onPressed: () => setState(() => _hidePassword = !_hidePassword),
                  icon: Icon(_hidePassword ? Icons.visibility_off : Icons.visibility),
                ),
              ),
              const Divider(height: 1),
              _buildField(
                label: 'РџРѕРІС‚РѕСЂРёС‚Рµ РїР°СЂРѕР»СЊ',
                controller: _confirm,
                obscure: true,
                validator: (v) => (v != _password.text) ? 'РџР°СЂРѕР»Рё РЅРµ СЃРѕРІРїР°РґР°СЋС‚' : null,
              ),
              const SizedBox(height: 16),
              SizedBox(
                height: 48,
                child: FilledButton(
                  onPressed: _register,
                  child: const Text('Р—Р°СЂРµРіРёСЃС‚СЂРёСЂРѕРІР°С‚СЊСЃСЏ'),
                ),
              ),
              const SizedBox(height: 8),
              Center(
                child: TextButton(
                  onPressed: widget.toggleView,
                  child: const Text('РЈР¶Рµ РµСЃС‚СЊ Р°РєРєР°СѓРЅС‚? Р’РѕР№С‚Рё'),
                ),
              ),
              const SizedBox(height: 12),
              Center(
                child: Text(
                  'В© ${DateTime.now().year} Student Platform',
                  style: theme.textTheme.bodySmall,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildField({
    required String label,
    required TextEditingController controller,
    String? Function(String?)? validator,
    TextInputType? keyboardType,
    bool obscure = false,
    Widget? suffix,
  }) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(8, 10, 8, 10),
      child: TextFormField(
        controller: controller,
        validator: validator,
        keyboardType: keyboardType,
        obscureText: obscure,
        decoration: InputDecoration(
          labelText: label,
          border: InputBorder.none,
          suffixIcon: suffix,
        ),
      ),
    );
  }
}



===== FILE: src\ui\exams\exams_screen.dart =====
import 'package:flutter/material.dart';

class ExamsScreen extends StatelessWidget {
  const ExamsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // СЃСЋРґР° РїРѕС‚РѕРј РїСЂРёРєСЂСѓС‚РёРј СЂРµР°Р»СЊРЅС‹Рµ РґР°РЅРЅС‹Рµ/С‚Р°Р±Р»РёС†Сѓ
    return Scaffold(
      appBar: AppBar(title: const Text('Р—Р°С‡С‘С‚С‹ Рё СЌРєР·Р°РјРµРЅС‹')),
      body: const Center(
        child: Text('РўСѓС‚ Р±СѓРґРµС‚ СЃРїРёСЃРѕРє Р·Р°С‡С‘С‚РѕРІ Рё СЌРєР·Р°РјРµРЅРѕРІ (РґРµРјРѕ)'),
      ),
    );
  }
}



===== FILE: src\ui\home\home_screen.dart =====
import 'package:flutter/material.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Р“Р»Р°РІРЅР°СЏ')),
      body: const Center(
        child: Text(
          'Р”РѕР±СЂРѕ РїРѕР¶Р°Р»РѕРІР°С‚СЊ!',
          style: TextStyle(fontSize: 20),
        ),
      ),
    );
  }
}



===== FILE: src\ui\info\info_screen.dart =====
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class InfoScreen extends StatelessWidget {
  const InfoScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('РџРѕР»РµР·РЅР°СЏ РёРЅС„РѕСЂРјР°С†РёСЏ')),
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Lottie.asset(
              'assets/lottie/cat_sleeping.json',
              width: 180,
              height: 180,
              repeat: true,
            ),
            const SizedBox(height: 12),
            const Text(
              'Р—РґРµСЃСЊ РїРѕРєР° РїСѓСЃС‚Рѕ',
              style: TextStyle(fontSize: 14, color: Colors.grey),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\ui\learning\assignment_details_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart' as services;
import 'package:flutter_bloc/flutter_bloc.dart';

import 'state/team_cubit.dart';
import 'models/assignment.dart';

class AssignmentDetailsScreen extends StatelessWidget {
  final String assignmentId;
  const AssignmentDetailsScreen({super.key, required this.assignmentId});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF6F7FB),
      appBar: AppBar(
        title: const Text('Р—Р°РґР°РЅРёРµ'),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.more_vert),
            onPressed: () => _showMore(context),
            tooltip: 'Р•С‰С‘',
          ),
        ],
      ),

      body: BlocBuilder<TeamCubit, TeamState>(
        builder: (context, state) {
          final st = state;
          final a = _pickAssignment(st, assignmentId);

          final isDraft = st.pending?.id == a.id;
          final isDone = context.read<TeamCubit>().isAssignmentDone(a.id);

          final link = _findLink(a);                 // СЃСЃС‹Р»РєР° РёР· РјРѕРґРµР»Рё/РІР»РѕР¶РµРЅРёР№/РѕРїРёСЃР°РЅРёСЏ
          final files = _extractAttachments(a);      // СѓРЅРёРІРµСЂСЃР°Р»СЊРЅС‹Р№ РїР°СЂСЃРµСЂ РІР»РѕР¶РµРЅРёР№

          return SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(16, 12, 16, 120),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _AssignmentHeaderCard(
                  assignment: a,
                  isDraft: isDraft,
                  isDone: isDone,
                ),
                const SizedBox(height: 16),

                if (link != null) ...[
                  _SectionCard(
                    title: 'РЎСЃС‹Р»РєР°',
                    child: ListTile(
                      contentPadding: EdgeInsets.zero,
                      leading: const Icon(Icons.link),
                      title: Text(
                        link,
                        style: const TextStyle(
                          decoration: TextDecoration.underline,
                          color: Color(0xFF1D4ED8),
                        ),
                      ),
                      subtitle: const Text('РќР°Р¶РјРё, С‡С‚РѕР±С‹ СЃРєРѕРїРёСЂРѕРІР°С‚СЊ'),
                      onTap: () async {
                        await services.Clipboard.setData(
                          services.ClipboardData(text: link),
                        );
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('РЎСЃС‹Р»РєР° СЃРєРѕРїРёСЂРѕРІР°РЅР°')),
                        );
                      },
                    ),
                  ),
                  const SizedBox(height: 12),
                ],

                _SectionCard(
                  title: 'РћРїРёСЃР°РЅРёРµ',
                  child: Text(
                    (a.description.trim().isEmpty) ? 'РћРїРёСЃР°РЅРёСЏ РЅРµС‚.' : a.description,
                    style: const TextStyle(
                      fontSize: 16,
                      height: 1.42,
                      color: Color(0xFF111827),
                    ),
                  ),
                ),

                if (files.isNotEmpty) ...[
                  const SizedBox(height: 12),
                  _SectionCard(
                    title: 'Р’Р»РѕР¶РµРЅРёСЏ',
                    child: Column(
                      children: files
                          .map((f) => _AttachmentTile(
                                name: f['name'] ?? '',
                                path: f['path'] ?? '',
                              ))
                          .toList(),
                    ),
                  ),
                ],
              ],
            ),
          );
        },
      ),

      bottomNavigationBar: BlocBuilder<TeamCubit, TeamState>(
        builder: (context, state) {
          final st = state;
          final a = _pickAssignment(st, assignmentId);

          final isDraft = st.pending?.id == a.id;
          final isDone = context.read<TeamCubit>().isAssignmentDone(a.id);

          return SafeArea(
            top: false,
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 10, 16, 16),
              child: Row(
                children: [
                  if (isDraft && st.isStarosta)
                    Expanded(
                      child: _BigButton.icon(
                        icon: Icons.publish_outlined,
                        label: 'РћРїСѓР±Р»РёРєРѕРІР°С‚СЊ',
                        onPressed: () {
                          context.read<TeamCubit>().publishPendingManually();
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(content: Text('Р—Р°РґР°РЅРёРµ РѕРїСѓР±Р»РёРєРѕРІР°РЅРѕ')),
                          );
                          Navigator.of(context).pop();
                        },
                      ),
                    ),
                  if (isDraft && !st.isStarosta)
                    Expanded(
                      child: _BigButton.tonalIcon(
                        icon: Icons.how_to_vote_outlined,
                        label: 'Р“РѕР»РѕСЃРѕРІР°С‚СЊ В«Р·Р°В»',
                        onPressed: () => context.read<TeamCubit>().voteForPending(),
                      ),
                    ),
                  if (!isDraft)
                    Expanded(
                      child: _BigButton.icon(
                        icon: isDone ? Icons.check_box : Icons.check_box_outline_blank,
                        label: isDone ? 'Р’С‹РїРѕР»РЅРµРЅРѕ' : 'РћС‚РјРµС‚РёС‚СЊ РєР°Рє РІС‹РїРѕР»РЅРµРЅРѕ',
                        bgColor: isDone ? const Color(0xFF16A34A) : null,
                        onPressed: () {
                          // С‚РѕС‚ Р¶Рµ РјРµС‚РѕРґ, С‡С‚Рѕ Рё РІ СЃРїРёСЃРєРµ вЂ” СЃРѕСЃС‚РѕСЏРЅРёСЏ СЃРёРЅС…СЂРѕРЅРёР·РёСЂСѓСЋС‚СЃСЏ РјРіРЅРѕРІРµРЅРЅРѕ
                          context.read<TeamCubit>().toggleCompleted(a.id);
                          Navigator.of(context).pop(); // РЅР°Р·Р°Рґ Рє СЃРїРёСЃРєСѓ
                        },
                      ),
                    ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Assignment _pickAssignment(TeamState st, String id) {
    return (st.assignments).firstWhere(
      (x) => x.id == id,
      orElse: () => st.published.isNotEmpty ? st.published.last : st.assignments.first,
    );
  }

  // --- РЈРЅРёРІРµСЂСЃР°Р»СЊРЅС‹Р№ РїРѕРёСЃРє СЃСЃС‹Р»РєРё ---
  String? _findLink(Assignment a) {
    // 1) РџСЂСЏРјРѕ РёР· РјРѕРґРµР»Рё: link/url/href (С‡РµСЂРµР· dynamic, С‡С‚РѕР±С‹ РЅРµ РїР°РґР°С‚СЊ, РµСЃР»Рё РїРѕР»СЏ РЅРµС‚)
    try {
      final dyn = a as dynamic;
      final fromModel = dyn.link ?? dyn.url ?? dyn.href;
      if (fromModel is String && fromModel.trim().isNotEmpty) return fromModel.trim();
    } catch (_) {}

    // 2) РР· РІР»РѕР¶РµРЅРёР№
    for (final f in _extractAttachments(a)) {
      final p = f['path'] ?? '';
      if (p.startsWith('http://') || p.startsWith('https://')) return p;
    }

    // 3) РџРµСЂРІР°СЏ http(s)-СЃСЃС‹Р»РєР° РІ РѕРїРёСЃР°РЅРёРё
    final rx = RegExp(r'(https?:\/\/[^\s]+)');
    final m = rx.firstMatch(a.description);
    if (m != null) return m.group(0);

    return null;
  }

  // --- РЈРЅРёРІРµСЂСЃР°Р»СЊРЅРѕРµ РёР·РІР»РµС‡РµРЅРёРµ РІР»РѕР¶РµРЅРёР№ РёР· СЂР°Р·РЅС‹С… СЃС‚СЂСѓРєС‚СѓСЂ РјРѕРґРµР»Рё ---
  List<Map<String, String>> _extractAttachments(Assignment a) {
    final List<Map<String, String>> out = [];

    void addItem(dynamic item) {
      if (item == null) return;
      if (item is Map) {
        final name = (item['name'] ?? item['filename'] ?? item['title'] ?? item['file'] ?? '').toString();
        final path = (item['path'] ?? item['url'] ?? item['link'] ?? item['href'] ?? '').toString();
        if (name.isNotEmpty || path.isNotEmpty) {
          out.add({'name': name, 'path': path});
        }
      } else if (item is String) {
        final base = item.split('/').last.split('\\').last;
        out.add({'name': base, 'path': item});
      }
    }

    try {
      final dyn = a as dynamic;

      // СЃС‚Р°РЅРґР°СЂС‚РЅРѕРµ РїРѕР»Рµ
      final attachments = dyn.attachments;
      if (attachments is Iterable) {
        for (final it in attachments) addItem(it);
      } else if (attachments != null) {
        addItem(attachments);
      }

      // РІРѕР·РјРѕР¶РЅС‹Рµ Р°Р»СЊС‚РµСЂРЅР°С‚РёРІС‹
      final files = dyn.files ?? dyn.fileList;
      if (files is Iterable) {
        for (final it in files) addItem(it);
      } else if (files != null) {
        addItem(files);
      }
    } catch (_) {}

    return out;
  }

  void _showMore(BuildContext context) {
    showModalBottomSheet(
      context: context,
      showDragHandle: true,
      builder: (_) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.share_outlined),
              title: const Text('РџРѕРґРµР»РёС‚СЊСЃСЏ'),
              onTap: () => Navigator.pop(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// вЂ”вЂ”вЂ” РљР°СЂС‚РѕС‡РєР° В«С€Р°РїРєРёВ»: СЃС‚Р°С‚СѓСЃРЅС‹Рµ С‡РёРїС‹, Р·Р°РіРѕР»РѕРІРѕРє, СЃСЂРѕРє
class _AssignmentHeaderCard extends StatelessWidget {
  final Assignment assignment;
  final bool isDraft;
  final bool isDone;

  const _AssignmentHeaderCard({
    required this.assignment,
    required this.isDraft,
    required this.isDone,
  });

  @override
  Widget build(BuildContext context) {
    final stripe = isDraft
        ? const Color(0xFFF59E0B)
        : (isDone ? const Color(0xFF16A34A) : Theme.of(context).colorScheme.primary);

    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: const Color(0xFFE5E7EB)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(.06),
            blurRadius: 16,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      clipBehavior: Clip.antiAlias,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(height: 6, color: stripe),
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 14, 16, 16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    if (isDraft)
                      _StatusChip(
                        icon: Icons.edit_note,
                        label: 'Р§РµСЂРЅРѕРІРёРє',
                        bg: const Color(0xFFFFF3CD),
                        border: const Color(0xFFF59E0B),
                        fgIcon: const Color(0xFFB45309),
                      ),
                    if (!isDraft)
                      _StatusChip(
                        icon: Icons.rocket_launch_outlined,
                        label: 'РћРїСѓР±Р»РёРєРѕРІР°РЅРѕ',
                        bg: const Color(0xFFEFFAF1),
                        border: const Color(0xFF16A34A),
                        fgIcon: const Color(0xFF166534),
                      ),
                    if (isDone)
                      _StatusChip(
                        icon: Icons.check_circle,
                        label: 'Р’С‹РїРѕР»РЅРµРЅРѕ',
                        bg: const Color(0xFFEFFAF1),
                        border: const Color(0xFF16A34A),
                        fgIcon: const Color(0xFF166534),
                      ),
                  ],
                ),
                const SizedBox(height: 12),
                Text(
                  assignment.title,
                  style: const TextStyle(
                    fontSize: 22,
                    fontWeight: FontWeight.w800,
                    letterSpacing: -.1,
                    color: Color(0xFF111827),
                    height: 1.15,
                  ),
                ),
                if (assignment.due != null && '${assignment.due}'.trim().isNotEmpty) ...[
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      const Icon(Icons.event_outlined, size: 18, color: Color(0xFF6B7280)),
                      const SizedBox(width: 6),
                      Text(
                        'РЎСЂРѕРє: ${_formatDue(assignment.due)}',
                        style: const TextStyle(
                          fontSize: 14,
                          color: Color(0xFF374151),
                        ),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }

  static String _formatDue(dynamic due) {
    if (due is DateTime) {
      String two(int v) => v < 10 ? '0$v' : '$v';
      return '${two(due.day)}.${two(due.month)}.${due.year} ${two(due.hour)}:${two(due.minute)}';
    }
    return '$due';
  }
}

class _StatusChip extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color bg;
  final Color border;
  final Color fgIcon;

  const _StatusChip({
    required this.icon,
    required this.label,
    required this.bg,
    required this.border,
    required this.fgIcon,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: border, width: 1),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16, color: fgIcon),
          const SizedBox(width: 6),
          Text(
            label,
            style: const TextStyle(
              fontSize: 12.5,
              fontWeight: FontWeight.w600,
              color: Color(0xFF111827),
            ),
          ),
        ],
      ),
    );
  }
}

class _SectionCard extends StatelessWidget {
  final String title;
  final Widget child;

  const _SectionCard({required this.title, required this.child});

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: const Color(0xFFE5E7EB)),
      ),
      padding: const EdgeInsets.fromLTRB(16, 14, 16, 16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(
              fontSize: 15,
              fontWeight: FontWeight.w800,
              color: Color(0xFF111827),
            ),
          ),
          const SizedBox(height: 10),
          child,
        ],
      ),
    );
  }
}

class _AttachmentTile extends StatelessWidget {
  final String name;
  final String path;
  const _AttachmentTile({required this.name, required this.path});

  @override
  Widget build(BuildContext context) {
    final ext = name.split('.').last.toLowerCase();
    IconData icon = Icons.insert_drive_file_outlined;
    if (['pdf'].contains(ext)) icon = Icons.picture_as_pdf_outlined;
    if (['png', 'jpg', 'jpeg', 'webp', 'gif'].contains(ext)) icon = Icons.image_outlined;
    if (['xls', 'xlsx', 'csv'].contains(ext)) icon = Icons.table_chart_outlined;
    if (['doc', 'docx'].contains(ext)) icon = Icons.description_outlined;
    if (['zip', 'rar', '7z'].contains(ext)) icon = Icons.archive_outlined;

    final showName = name.isNotEmpty ? name : (path.isNotEmpty ? path.split('/').last.split('\\').last : 'Р¤Р°Р№Р»');

    return ListTile(
      dense: false,
      contentPadding: EdgeInsets.zero,
      minVerticalPadding: 6,
      leading: Icon(icon, color: const Color(0xFF6B7280)),
      title: Text(
        showName,
        style: const TextStyle(
          fontSize: 15,
          fontWeight: FontWeight.w600,
          color: Color(0xFF111827),
        ),
      ),
      subtitle: path.isNotEmpty
          ? Text(
              path,
              style: const TextStyle(fontSize: 12.5, color: Color(0xFF6B7280)),
            )
          : null,
      trailing: IconButton(
        icon: const Icon(Icons.more_horiz),
        onPressed: () {},
        tooltip: 'Р”РµР№СЃС‚РІРёСЏ',
      ),
      onTap: () {},
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    );
  }
}

class _BigButton extends StatelessWidget {
  final VoidCallback onPressed;
  final String label;
  final IconData? icon;
  final Color? bgColor;
  final bool tonal;

  const _BigButton._({
    required this.onPressed,
    required this.label,
    this.icon,
    this.bgColor,
    this.tonal = false,
  });

  factory _BigButton.icon({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
    Color? bgColor,
  }) =>
      _BigButton._(icon: icon, label: label, onPressed: onPressed, bgColor: bgColor);

  factory _BigButton.tonalIcon({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
  }) =>
      _BigButton._(
        icon: icon,
        label: label,
        onPressed: onPressed,
        tonal: true,
      );

  @override
  Widget build(BuildContext context) {
    final scheme = Theme.of(context).colorScheme;
    final bg = tonal ? scheme.secondaryContainer : (bgColor ?? scheme.primary);
    final fg = tonal ? scheme.onSecondaryContainer : Colors.white;

    return SizedBox(
      height: 52,
      child: ElevatedButton.icon(
        onPressed: onPressed,
        icon: Icon(icon),
        label: Text(label),
        style: const ButtonStyle(
          shape: MaterialStatePropertyAll(StadiumBorder()),
          textStyle: MaterialStatePropertyAll(
            TextStyle(fontSize: 16, fontWeight: FontWeight.w700),
          ),
          elevation: MaterialStatePropertyAll(0),
        ).copyWith(
          backgroundColor: MaterialStatePropertyAll(bg),
          foregroundColor: MaterialStatePropertyAll(fg),
        ),
      ),
    );
  }
}



===== FILE: src\ui\learning\data\learning_repository.dart =====
import '../models/team.dart';
import '../models/message.dart';
import '../models/file_item.dart';
import '../models/assignment.dart';

abstract class LearningRepository {
  Future<List<Team>> loadTeams(String groupCode);
  Future<void> saveTeams(List<Team> teams);

  Future<List<Message>> loadChat(String teamId);
  Future<void> saveChat(String teamId, List<Message> messages);

  Future<List<FileItem>> loadFiles(String teamId);
  Future<void> saveFiles(String teamId, List<FileItem> files);

  Future<Set<String>> loadHiddenTeamIds();
  Future<void> saveHiddenTeamIds(Set<String> ids);
  Future<String> loadViewMode();
  Future<void> saveViewMode(String mode);

  Future<List<Assignment>> loadAssignments(String teamId);
  Future<void> saveAssignments(String teamId, List<Assignment> items);
}



===== FILE: src\ui\learning\data\local_learning_repository.dart =====
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';

import 'package:student_platform/src/ui/learning/models/team.dart';
import 'package:student_platform/src/ui/learning/models/message.dart';
import 'package:student_platform/src/ui/learning/models/file_item.dart';
import 'package:student_platform/src/ui/learning/models/assignment.dart';
import 'package:student_platform/src/ui/learning/data/learning_repository.dart';

class LocalLearningRepository implements LearningRepository {
  static const _teamsKey     = 'learning_teams_v1';
  static const _chatPrefix   = 'learning_chat_';
  static const _filesPrefix  = 'learning_files_';
  static const _assignPrefix = 'learning_assign_';
  static const _hiddenKey    = 'learning_hidden_v1';
  static const _viewModeKey  = 'learning_view_mode_v1';

  // РљРѕРјР°РЅРґС‹
  @override
  Future<List<Team>> loadTeams(String groupCode) async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_teamsKey);
    if (raw != null) {
      final list = Team.decodeList(raw);
      return list.where((t) => t.groupCode == groupCode).toList();
    }
    final demo = <Team>[
      Team(id: 't1', name: 'Р”РµР»РѕРІРѕР№ РёРЅРѕСЃС‚СЂР°РЅРЅС‹Р№ СЏР·С‹Рє', teacher: 'РЎР°С…Р°СЂРѕРІР° Рў.Р•.', groupCode: groupCode, icon: 'Р”РЎ', unread: 1),
      Team(id: 't2', name: 'РРЅР¶.-С‚РµС…РЅРѕР»РѕРіРёС‡РµСЃРєР°СЏ СЂРµРєРѕРЅСЃС‚СЂСѓРєС†РёСЏ СЃРёСЃС‚РµРј Р’Рљ', teacher: 'РљРёСЂРёР»Р»РѕРІ Рђ.Рђ.', groupCode: groupCode, icon: 'рџ§¬'),
      Team(id: 't3', name: 'РћСЃРЅРѕРІС‹ РЅР°СѓС‡РЅС‹С… РёСЃСЃР»РµРґРѕРІР°РЅРёР№', teacher: 'Р¤РµРґРѕСЂРѕРІ РЎ.Р’.', groupCode: groupCode, icon: 'рџ“Љ'),
    ];
    await prefs.setString(_teamsKey, Team.encodeList(demo));
    return demo;
  }

  @override
  Future<void> saveTeams(List<Team> teams) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_teamsKey, Team.encodeList(teams));
  }

  // Р§Р°С‚
  @override
  Future<List<Message>> loadChat(String teamId) async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString('$_chatPrefix$teamId');
    if (raw == null) return [];
    final list = (jsonDecode(raw) as List).map((e) => Message.fromJson(Map<String, dynamic>.from(e))).toList();
    list.sort((a, b) => a.at.compareTo(b.at));
    return list;
  }

  @override
  Future<void> saveChat(String teamId, List<Message> messages) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('$_chatPrefix$teamId', jsonEncode(messages.map((e) => e.toJson()).toList()));
  }

  // Р¤Р°Р№Р»С‹
  @override
  Future<List<FileItem>> loadFiles(String teamId) async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString('$_filesPrefix$teamId');
    if (raw == null) return [];
    return (jsonDecode(raw) as List).map((e) => FileItem.fromJson(Map<String, dynamic>.from(e))).toList();
  }

  @override
  Future<void> saveFiles(String teamId, List<FileItem> files) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('$_filesPrefix$teamId', jsonEncode(files.map((e) => e.toJson()).toList()));
  }

  // РЎРєСЂС‹С‚С‹Рµ/СЂРµР¶РёРј
  @override
  Future<Set<String>> loadHiddenTeamIds() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_hiddenKey);
    if (raw == null) return {};
    return (jsonDecode(raw) as List).map((e) => e.toString()).toSet();
  }

  @override
  Future<void> saveHiddenTeamIds(Set<String> ids) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_hiddenKey, jsonEncode(ids.toList()));
  }

  @override
  Future<String> loadViewMode() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_viewModeKey) ?? 'list';
  }

  @override
  Future<void> saveViewMode(String mode) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_viewModeKey, mode);
  }

  // Р—Р°РґР°РЅРёСЏ
  @override
  Future<List<Assignment>> loadAssignments(String teamId) async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString('$_assignPrefix$teamId');
    if (raw == null) return [];
    return (jsonDecode(raw) as List)
        .map((e) => Assignment.fromJson(Map<String, dynamic>.from(e)))
        .toList();
  }

  @override
  Future<void> saveAssignments(String teamId, List<Assignment> items) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('$_assignPrefix$teamId', jsonEncode(items.map((e) => e.toJson()).toList()));
  }
}



===== FILE: src\ui\learning\learning_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'state/learning_cubit.dart';
import 'state/learning_state.dart';
import 'team_details_screen.dart';
import 'models/team.dart';
import 'manage/manage_teams_screen.dart';

class LearningScreen extends StatelessWidget {
  const LearningScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocProvider<LearningCubit>(
      create: (_) => LearningCubit()..load(getCurrentGroupCodeSync(context)),
      child: const _Body(),
    );
  }
}

/// Р—Р°РіР»СѓС€РєР°: Р±РµСЂС‘Рј С‚РµРєСѓС‰СѓСЋ РіСЂСѓРїРїСѓ Р»РѕРєР°Р»СЊРЅРѕ (РїРѕС‚РѕРј СЃРІСЏР¶РµРј СЃ РїСЂРѕС„РёР»РµРј)
String getCurrentGroupCodeSync(BuildContext context) => '1-РЎРј(Р’Р’)-1';

class _Body extends StatelessWidget {
  const _Body();

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('РљРѕРјР°РЅРґС‹'),
        centerTitle: true,
        // СЃР»РµРІР° вЂ” РїРµСЂРµРєР»СЋС‡Р°С‚РµР»СЊ СЃРїРёСЃРѕРє/РїР»РёС‚РєР°
        leading: BlocBuilder<LearningCubit, LearningState>(
          builder: (context, state) {
            final isGrid = state.viewMode == ViewMode.grid;
            return IconButton(
              tooltip: isGrid ? 'РЎРїРёСЃРѕРє' : 'РџР»РёС‚РєР°',
              icon: Icon(isGrid ? Icons.view_list : Icons.grid_view_rounded),
              onPressed: () => context.read<LearningCubit>().toggleViewMode(),
            );
          },
        ),
        actions: [
          // СЃРїСЂР°РІР° вЂ” РїРµСЂРµС…РѕРґ РІ СЌРєСЂР°РЅ СѓРїСЂР°РІР»РµРЅРёСЏ (РєР°Рє РЅР° С‚РІРѕС‘Рј СЃРєСЂРёРЅРµ)
          IconButton(
            tooltip: 'РЈРїСЂР°РІР»РµРЅРёРµ РєРѕРјР°РЅРґР°РјРё',
            icon: const Icon(Icons.settings_outlined),
            onPressed: () {
              final cubit = context.read<LearningCubit>();
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (_) => BlocProvider.value(
                    value: cubit,
                    child: ManageTeamsScreen(
                      groupCode: getCurrentGroupCodeSync(context),
                    ),
                  ),
                ),
              );
            },
          ),
        ],
      ),
      body: BlocBuilder<LearningCubit, LearningState>(
        builder: (context, state) {
          if (state.loading) {
            return const Center(child: CircularProgressIndicator());
          }

          final items = context.read<LearningCubit>().visibleTeams;

          if (items.isEmpty) {
            return Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text('РџРѕРєР° РЅРµС‚ РєРѕРјР°РЅРґ РґР»СЏ РІР°С€РµР№ РіСЂСѓРїРїС‹',
                      style: theme.textTheme.bodyMedium),
                  const SizedBox(height: 12),
                  OutlinedButton.icon(
                    onPressed: () {
                      final cubit = context.read<LearningCubit>();
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (_) => BlocProvider.value(
                            value: cubit,
                            child: ManageTeamsScreen(
                              groupCode: getCurrentGroupCodeSync(context),
                            ),
                          ),
                        ),
                      );
                    },
                    icon: const Icon(Icons.settings_outlined),
                    label: const Text('РЈРїСЂР°РІР»РµРЅРёРµ РєРѕРјР°РЅРґР°РјРё'),
                  ),
                ],
              ),
            );
          }

          // РїРµСЂРµРєР»СЋС‡РµРЅРёРµ РјР°РєРµС‚Р°
          if (state.viewMode == ViewMode.grid) {
            return Padding(
              padding: const EdgeInsets.all(12),
              child: GridView.builder(
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 2, // РєР°Рє РёРєРѕРЅРєРё РЅР° С‚РµР»РµС„РѕРЅРµ
                  mainAxisSpacing: 12,
                  crossAxisSpacing: 12,
                  childAspectRatio: 1.2,
                ),
                itemCount: items.length,
                itemBuilder: (_, i) => _TeamGridCard(items[i]),
              ),
            );
          }

          return ListView.separated(
            padding: const EdgeInsets.all(16),
            itemCount: items.length,
            separatorBuilder: (_, __) => const SizedBox(height: 12),
            itemBuilder: (_, i) => _TeamTile(items[i]),
          );
        },
      ),
    );
  }
}

class _TeamTile extends StatelessWidget {
  final Team team;
  const _TeamTile(this.team);

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () => Navigator.of(context).push(
        MaterialPageRoute(builder: (_) => TeamDetailsScreen(team: team)),
      ),
      borderRadius: BorderRadius.circular(16),
      child: Container(
        padding: const EdgeInsets.all(14),
        decoration: BoxDecoration(
          color: Theme.of(context).cardColor,
          borderRadius: BorderRadius.circular(16),
        ),
        child: Row(
          children: [
            _Avatar(text: team.icon),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(team.name,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(fontWeight: FontWeight.w600)),
                  const SizedBox(height: 4),
                  Text(team.teacher, style: TextStyle(color: Colors.grey.shade400)),
                ],
              ),
            ),
            if (team.unread > 0)
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: Colors.blueAccent,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text('${team.unread}',
                    style: const TextStyle(color: Colors.white)),
              ),
          ],
        ),
      ),
    );
  }
}

class _TeamGridCard extends StatelessWidget {
  final Team team;
  const _TeamGridCard(this.team);

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () => Navigator.of(context).push(
        MaterialPageRoute(builder: (_) => TeamDetailsScreen(team: team)),
      ),
      borderRadius: BorderRadius.circular(16),
      child: Container(
        decoration: BoxDecoration(
          color: Theme.of(context).cardColor,
          borderRadius: BorderRadius.circular(16),
        ),
        padding: const EdgeInsets.all(14),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _Avatar(text: team.icon),
            const SizedBox(height: 10),
            Text(team.name,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(fontWeight: FontWeight.w600)),
            const Spacer(),
            Text(team.teacher, maxLines: 1, overflow: TextOverflow.ellipsis,
                style: TextStyle(color: Colors.grey.shade400)),
          ],
        ),
      ),
    );
  }
}

class _Avatar extends StatelessWidget {
  final String text;
  const _Avatar({required this.text});

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 44,
      width: 44,
      decoration: BoxDecoration(
        color: Colors.grey.shade800,
        borderRadius: BorderRadius.circular(12),
      ),
      alignment: Alignment.center,
      child: Text(text, style: const TextStyle(fontWeight: FontWeight.w700)),
    );
  }
}



===== FILE: src\ui\learning\manage\manage_teams_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../state/learning_cubit.dart';
import '../state/learning_state.dart';
import '../models/team.dart';

class ManageTeamsScreen extends StatefulWidget {
  final String groupCode;
  const ManageTeamsScreen({super.key, required this.groupCode});

  @override
  State<ManageTeamsScreen> createState() => _ManageTeamsScreenState();
}

class _ManageTeamsScreenState extends State<ManageTeamsScreen> {
  String _query = '';

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('РЈРїСЂР°РІР»РµРЅРёРµ РєРѕРјР°РЅРґР°РјРё'),
        actions: [
          IconButton(
            tooltip: 'Р”РѕР±Р°РІРёС‚СЊ РїРѕ РєРѕРґСѓ',
            icon: const Icon(Icons.add),
            onPressed: () async {
              final code = await _askCode(context);
              if (code != null && code.trim().isNotEmpty) {
                await context.read<LearningCubit>()
                    .addTeamByCode(code.trim(), widget.groupCode);
                if (!mounted) return;
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('РљРѕРјР°РЅРґР° $code РґРѕР±Р°РІР»РµРЅР° (РґРµРјРѕ)')),
                );
              }
            },
          ),
        ],
      ),
      body: BlocBuilder<LearningCubit, LearningState>(
        builder: (context, state) {
          final teams = state.teams
              .where((t) =>
                  _query.isEmpty ||
                  t.name.toLowerCase().contains(_query.toLowerCase()) ||
                  t.teacher.toLowerCase().contains(_query.toLowerCase()))
              .toList();

          return Column(
            children: [
              Padding(
                padding: const EdgeInsets.fromLTRB(12, 12, 12, 0),
                child: TextField(
                  decoration: const InputDecoration(
                    prefixIcon: Icon(Icons.search),
                    hintText: 'РџРѕРёСЃРє РїРѕ РЅР°Р·РІР°РЅРёСЋ/РїСЂРµРїРѕРґР°РІР°С‚РµР»СЋвЂ¦',
                  ),
                  onChanged: (v) => setState(() => _query = v),
                ),
              ),
              const SizedBox(height: 8),
              Expanded(
                child: ListView.separated(
                  padding: const EdgeInsets.all(12),
                  itemCount: teams.length,
                  separatorBuilder: (_, __) => const SizedBox(height: 8),
                  itemBuilder: (_, i) {
                    final team = teams[i];
                    final hidden =
                        state.hiddenIds.contains(team.id);

                    return InkWell(
                      onLongPress: () => _showMore(context, team),
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Theme.of(context).cardColor,
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Row(
                          children: [
                            _Avatar(text: team.icon),
                            const SizedBox(width: 10),
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(team.name,
                                      maxLines: 2,
                                      overflow: TextOverflow.ellipsis,
                                      style: const TextStyle(
                                          fontWeight: FontWeight.w600)),
                                  const SizedBox(height: 4),
                                  Text(team.teacher,
                                      style: TextStyle(
                                          color: Colors.grey.shade400)),
                                ],
                              ),
                            ),
                            const SizedBox(width: 8),
                            IconButton(
                              tooltip: 'Р•С‰С‘',
                              icon: const Icon(Icons.more_horiz),
                              onPressed: () => _showMore(context, team),
                            ),
                            const SizedBox(width: 4),
                            Checkbox(
                              value: !hidden,
                              onChanged: (_) => context
                                  .read<LearningCubit>()
                                  .toggleHidden(team.id),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Future<void> _showMore(BuildContext context, Team team) async {
    showModalBottomSheet(
      context: context,
      showDragHandle: true,
      builder: (_) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.group_outlined),
              title: const Text('РџРѕРєР°Р·Р°С‚СЊ СѓС‡Р°СЃС‚РЅРёРєРѕРІ'),
              onTap: () {
                Navigator.pop(context);
                _showParticipants(context, team);
              },
            ),
            ListTile(
              leading: const Icon(Icons.sell_outlined),
              title: const Text('РЈРїСЂР°РІР»РµРЅРёРµ С‚РµРіР°РјРё'),
              subtitle: const Text('Р—Р°РіР»СѓС€РєР°'),
              onTap: () => Navigator.pop(context),
            ),
            ListTile(
              leading: const Icon(Icons.forum_outlined),
              title: const Text('РџСЂРѕСЃРјРѕС‚СЂРµС‚СЊ РєР°РЅР°Р»С‹'),
              subtitle: const Text('Р—Р°РіР»СѓС€РєР°'),
              onTap: () => Navigator.pop(context),
            ),
          ],
        ),
      ),
    );
  }

  void _showParticipants(BuildContext context, Team team) {
    final participants = [
      'РРІР°РЅРѕРІ Р.Р.',
      'РџРµС‚СЂРѕРІ Рџ.Рџ.',
      'РЎРёРґРѕСЂРѕРІ РЎ.РЎ.',
      'РљСѓР·РЅРµС†РѕРІР° Рђ.Рђ.',
      'Р’С‹ вЂ” СЃС‚Р°СЂРѕСЃС‚Р° (РґРµРјРѕ)',
    ];
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: Text('РЈС‡Р°СЃС‚РЅРёРєРё вЂ” ${team.name}'),
        content: SizedBox(
          width: double.maxFinite,
          child: ListView.builder(
            shrinkWrap: true,
            itemCount: participants.length,
            itemBuilder: (_, i) => ListTile(
              leading: const Icon(Icons.person_outline),
              title: Text(participants[i]),
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Р—Р°РєСЂС‹С‚СЊ'),
          )
        ],
      ),
    );
  }

  Future<String?> _askCode(BuildContext context) async {
    final ctrl = TextEditingController();
    return showDialog<String>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text('Р”РѕР±Р°РІРёС‚СЊ РїРѕ РєРѕРґСѓ'),
        content: TextField(
          autofocus: true,
          controller: ctrl,
          decoration: const InputDecoration(
            hintText: 'Р’РІРµРґРёС‚Рµ РєРѕРґ РєРѕРјР°РЅРґС‹вЂ¦',
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('РћС‚РјРµРЅР°'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, ctrl.text),
            child: const Text('Р”РѕР±Р°РІРёС‚СЊ'),
          ),
        ],
      ),
    );
  }
}

class _Avatar extends StatelessWidget {
  final String text;
  const _Avatar({required this.text});

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 40, width: 40,
      decoration: BoxDecoration(
        color: Colors.grey.shade800,
        borderRadius: BorderRadius.circular(10),
      ),
      alignment: Alignment.center,
      child: Text(text, style: const TextStyle(fontWeight: FontWeight.w700)),
    );
  }
}



===== FILE: src\ui\learning\models\assignment.dart =====
class Assignment {
  final String id;
  final String title;          // РќР°Р·РІР°РЅРёРµ
  final String description;    // Р§С‚Рѕ СЃРґРµР»Р°С‚СЊ
  final String? link;          // РЎСЃС‹Р»РєР° (РѕРїС†.)
  final String? due;           // РЎСЂРѕРє (РѕРїС†.)
  final List<Map<String, String>> attachments; // [{name, path}]
  final bool published;        // РћРїСѓР±Р»РёРєРѕРІР°РЅРѕ
  final int votes;             // Р“РѕР»РѕСЃР° "Р·Р°" РґР»СЏ РїСѓР±Р»РёРєР°С†РёРё
  final bool completedByMe;    // РњРѕСЏ РѕС‚РјРµС‚РєР° РІС‹РїРѕР»РЅРµРЅРёСЏ
  final String createdBy;      // 'me' | 'student' | 'starosta'
  final DateTime createdAt;

  const Assignment({
    required this.id,
    required this.title,
    required this.description,
    this.link,
    this.due,
    this.attachments = const [],
    required this.published,
    required this.votes,
    required this.completedByMe,
    required this.createdBy,
    required this.createdAt,
  });

  Assignment copyWith({
    String? id,
    String? title,
    String? description,
    String? link,
    String? due,
    List<Map<String, String>>? attachments,
    bool? published,
    int? votes,
    bool? completedByMe,
    String? createdBy,
    DateTime? createdAt,
  }) {
    return Assignment(
      id: id ?? this.id,
      title: title ?? this.title,
      description: description ?? this.description,
      link: link ?? this.link,
      due: due ?? this.due,
      attachments: attachments ?? this.attachments,
      published: published ?? this.published,
      votes: votes ?? this.votes,
      completedByMe: completedByMe ?? this.completedByMe,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'description': description,
        'link': link,
        'due': due,
        'attachments': attachments,
        'published': published,
        'votes': votes,
        'completedByMe': completedByMe,
        'createdBy': createdBy,
        'createdAt': createdAt.toIso8601String(),
      };

  factory Assignment.fromJson(Map<String, dynamic> j) => Assignment(
        id: j['id'],
        title: j['title'],
        description: j['description'] ?? '',
        link: j['link'],
        due: j['due'],
        attachments: (j['attachments'] as List?)
                ?.map((e) => (e as Map).map((k, v) => MapEntry('$k', '$v')))
                .toList() ??
            const [],
        published: (j['published'] ?? false) as bool,
        votes: (j['votes'] ?? 0) as int,
        completedByMe: (j['completedByMe'] ?? false) as bool,
        createdBy: j['createdBy'] ?? 'student',
        createdAt: DateTime.parse(j['createdAt']),
      );
}



===== FILE: src\ui\learning\models\file_item.dart =====
class FileItem {
  final String id;
  final String name;
  final String path; // Р»РѕРєР°Р»СЊРЅС‹Р№ РїСѓС‚СЊ

  FileItem({required this.id, required this.name, required this.path});

  Map<String, dynamic> toJson() => {'id': id, 'name': name, 'path': path};

  factory FileItem.fromJson(Map<String, dynamic> j) =>
      FileItem(id: j['id'], name: j['name'], path: j['path']);
}



===== FILE: src\ui\learning\models\message.dart =====
enum MessageType { text, assignmentDraft, assignmentPublished }

class Message {
  final String id;
  final String author;      // 'me' / 'other' / 'system'
  final String authorName;  // РРјСЏ Р°РІС‚РѕСЂР°
  final String text;
  final DateTime at;

  // РѕРїС†РёРѕРЅР°Р»СЊРЅРѕ
  final String? imagePath;  // С„РѕС‚Рѕ
  final String? replyToId;  // РѕС‚РІРµС‚ РЅР° СЃРѕРѕР±С‰РµРЅРёРµ
  final String? assignmentId; // РґР»СЏ РєР°СЂС‚РѕС‡РµРє Р·Р°РґР°РЅРёР№
  final MessageType type;

  Message({
    required this.id,
    required this.author,
    required this.authorName,
    required this.text,
    required this.at,
    this.imagePath,
    this.replyToId,
    this.assignmentId,
    this.type = MessageType.text,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'author': author,
        'authorName': authorName,
        'text': text,
        'at': at.toIso8601String(),
        'imagePath': imagePath,
        'replyToId': replyToId,
        'assignmentId': assignmentId,
        'type': type.name,
      };

  factory Message.fromJson(Map<String, dynamic> j) => Message(
        id: j['id'],
        author: j['author'] ?? 'other',
        authorName: j['authorName'] ?? 'РЎС‚СѓРґРµРЅС‚',
        text: j['text'] ?? '',
        at: DateTime.parse(j['at']),
        imagePath: j['imagePath'],
        replyToId: j['replyToId'],
        assignmentId: j['assignmentId'],
        type: _parseType(j['type']),
      );

  static MessageType _parseType(dynamic s) {
    if (s is String) {
      return MessageType.values
          .firstWhere((e) => e.name == s, orElse: () => MessageType.text);
    }
    return MessageType.text;
  }
}



===== FILE: src\ui\learning\models\team.dart =====
import 'dart:convert';

class Team {
  final String id;
  final String name;       // РќР°Р·РІР°РЅРёРµ РєРѕРјР°РЅРґС‹/РїСЂРµРґРјРµС‚Р°
  final String teacher;    // РџСЂРµРїРѕРґР°РІР°С‚РµР»СЊ
  final String groupCode;  // Р“СЂСѓРїРїР°/РєСѓСЂСЃ РїСЂРёРІСЏР·РєРё
  final String icon;       // Р­РјРѕРґР·Рё/РєСЂР°С‚РєР°СЏ РјРµС‚РєР° РІ Р°РІР°С‚Р°СЂРµ
  final int  unread;       // РќРµРїСЂРѕС‡РёС‚Р°РЅРЅС‹Рµ (РґРµРјРѕ)
  final bool pollApproved; // Р Р°Р·СЂРµС€РµРЅС‹ "Р—Р°РґР°РЅРёСЏ" РїРѕСЃР»Рµ РіРѕР»РѕСЃРѕРІР°РЅРёСЏ

  const Team({
    required this.id,
    required this.name,
    required this.teacher,
    required this.groupCode,
    required this.icon,
    this.unread = 0,
    this.pollApproved = false,
  });

  Team copyWith({
    String? id,
    String? name,
    String? teacher,
    String? groupCode,
    String? icon,
    int? unread,
    bool? pollApproved,
  }) {
    return Team(
      id: id ?? this.id,
      name: name ?? this.name,
      teacher: teacher ?? this.teacher,
      groupCode: groupCode ?? this.groupCode,
      icon: icon ?? this.icon,
      unread: unread ?? this.unread,
      pollApproved: pollApproved ?? this.pollApproved,
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'teacher': teacher,
    'groupCode': groupCode,
    'icon': icon,
    'unread': unread,
    'pollApproved': pollApproved,
  };

  factory Team.fromJson(Map<String, dynamic> j) => Team(
    id: j['id'] as String,
    name: j['name'] as String,
    teacher: j['teacher'] as String,
    groupCode: j['groupCode'] as String,
    icon: j['icon'] as String,
    unread: (j['unread'] ?? 0) as int,
    pollApproved: (j['pollApproved'] ?? false) as bool,
  );

  static String encodeList(List<Team> items) =>
      jsonEncode(items.map((e) => e.toJson()).toList());

  static List<Team> decodeList(String raw) =>
      (jsonDecode(raw) as List).map((e) => Team.fromJson(e)).toList();
}



===== FILE: src\ui\learning\state\learning_cubit.dart =====
import 'package:flutter_bloc/flutter_bloc.dart';

import 'package:student_platform/src/ui/learning/data/learning_repository.dart';
import 'package:student_platform/src/ui/learning/data/local_learning_repository.dart';
import 'package:student_platform/src/ui/learning/state/learning_state.dart';
import 'package:student_platform/src/ui/learning/models/team.dart';

class LearningCubit extends Cubit<LearningState> {
  final LearningRepository repo;

  LearningCubit({LearningRepository? repository})
      : repo = repository ?? LocalLearningRepository(),
        super(const LearningState());

  Future<void> load(String groupCode) async {
    emit(state.copyWith(loading: true));
    final teams = await repo.loadTeams(groupCode);
    final hidden = await repo.loadHiddenTeamIds();
    final modeStr = await repo.loadViewMode();
    final viewMode =
        modeStr == 'grid' ? ViewMode.grid : ViewMode.list;

    emit(state.copyWith(
      loading: false,
      teams: teams,
      hiddenIds: hidden,
      viewMode: viewMode,
    ));
  }

  List<Team> get visibleTeams =>
      state.teams.where((t) => !state.hiddenIds.contains(t.id)).toList();

  Future<void> toggleHidden(String teamId) async {
    final set = {...state.hiddenIds};
    if (set.contains(teamId)) {
      set.remove(teamId);
    } else {
      set.add(teamId);
    }
    await repo.saveHiddenTeamIds(set);
    emit(state.copyWith(hiddenIds: set));
  }

  Future<void> toggleViewMode() async {
    final next =
        state.viewMode == ViewMode.list ? ViewMode.grid : ViewMode.list;
    await repo.saveViewMode(next == ViewMode.grid ? 'grid' : 'list');
    emit(state.copyWith(viewMode: next));
  }

  // РґРµРјРѕ-РґРѕР±Р°РІР»РµРЅРёРµ РєРѕРјР°РЅРґС‹ РїРѕ РєРѕРґСѓ
  Future<void> addTeamByCode(String code, String groupCode) async {
    final t = Team(
      id: 'code_$code',
      name: 'РљРѕРјР°РЅРґР° $code',
      teacher: 'РџСЂРµРїРѕРґР°РІР°С‚РµР»СЊ',
      groupCode: groupCode,
      icon: code.length >= 2 ? code.substring(0, 2).toUpperCase() : 'РљРґ',
    );
    final list = [...state.teams, t];
    await repo.saveTeams(list);
    emit(state.copyWith(teams: list));
  }
}



===== FILE: src\ui\learning\state\learning_state.dart =====
import '../models/team.dart';

enum ViewMode { list, grid }

class LearningState {
  final bool loading;
  final List<Team> teams;
  final Set<String> hiddenIds; // СЃРєСЂС‹С‚С‹Рµ
  final bool manageMode;       // РѕСЃС‚Р°РІРёР» РЅР° Р±СѓРґСѓС‰РµРµ (РЅРµ РёСЃРїРѕР»СЊР·СѓРµС‚СЃСЏ)
  final ViewMode viewMode;     // СЃРїРёСЃРѕРє / РїР»РёС‚РєР°

  const LearningState({
    this.loading = false,
    this.teams = const [],
    this.hiddenIds = const {},
    this.manageMode = false,
    this.viewMode = ViewMode.list,
  });

  LearningState copyWith({
    bool? loading,
    List<Team>? teams,
    Set<String>? hiddenIds,
    bool? manageMode,
    ViewMode? viewMode,
  }) =>
      LearningState(
        loading: loading ?? this.loading,
        teams: teams ?? this.teams,
        hiddenIds: hiddenIds ?? this.hiddenIds,
        manageMode: manageMode ?? this.manageMode,
        viewMode: viewMode ?? this.viewMode,
      );
}



===== FILE: src\ui\learning\state\team_cubit.dart =====
// lib/src/ui/learning/state/team_cubit.dart
import 'dart:math';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'package:student_platform/src/ui/learning/data/learning_repository.dart';
import 'package:student_platform/src/ui/learning/data/local_learning_repository.dart';
import 'package:student_platform/src/ui/learning/models/message.dart';
import 'package:student_platform/src/ui/learning/models/file_item.dart';
import 'package:student_platform/src/ui/learning/models/team.dart';
import 'package:student_platform/src/ui/learning/models/assignment.dart';

/// ===== STATE ==================================================================
class TeamState {
  final Team team;
  final List<Message> chat;
  final List<FileItem> files;
  final List<Assignment> assignments;
  final bool loading;
  final int votes;
  final bool isStarosta;

  /// id Р·Р°РґР°РЅРёР№, РѕС‚РјРµС‡РµРЅРЅС‹С… РїРѕР»СЊР·РѕРІР°С‚РµР»РµРј РєР°Рє РІС‹РїРѕР»РЅРµРЅРЅС‹Рµ (Р»РѕРєР°Р»СЊРЅРѕ)
  final Set<String> doneAssignmentIds;

  List<Assignment> get published =>
      assignments.where((a) => a.published).toList();

  Assignment? get pending {
    for (int i = assignments.length - 1; i >= 0; i--) {
      if (!assignments[i].published) return assignments[i];
    }
    return null;
  }

  bool get hasPending => pending != null;

  const TeamState({
    required this.team,
    this.chat = const [],
    this.files = const [],
    this.assignments = const [],
    this.loading = false,
    this.votes = 0,
    this.isStarosta = true,
    this.doneAssignmentIds = const {},
  });

  TeamState copyWith({
    Team? team,
    List<Message>? chat,
    List<FileItem>? files,
    List<Assignment>? assignments,
    bool? loading,
    int? votes,
    bool? isStarosta,
    Set<String>? doneAssignmentIds,
  }) {
    return TeamState(
      team: team ?? this.team,
      chat: chat ?? this.chat,
      files: files ?? this.files,
      assignments: assignments ?? this.assignments,
      loading: loading ?? this.loading,
      votes: votes ?? this.votes,
      isStarosta: isStarosta ?? this.isStarosta,
      doneAssignmentIds: doneAssignmentIds ?? this.doneAssignmentIds,
    );
  }
}

/// ===== CUBIT ==================================================================
class TeamCubit extends Cubit<TeamState> {
  final LearningRepository repo;

  TeamCubit(Team team, {LearningRepository? repository})
      : repo = repository ?? LocalLearningRepository(),
        super(TeamState(team: team));

  Future<void> init() async {
    emit(state.copyWith(loading: true));
    final chat = await repo.loadChat(state.team.id);
    final files = await repo.loadFiles(state.team.id);
    final ass = await repo.loadAssignments(state.team.id);
    emit(state.copyWith(
      loading: false,
      chat: chat,
      files: files,
      assignments: ass,
    ));
  }

  // ---------------------------------------------------------------------------
  // Р§РђРў
  // ---------------------------------------------------------------------------

  Future<void> sendMessage(
    String author,
    String text, {
    String? authorName,
    String? imagePath,
    String? replyToId,
    MessageType type = MessageType.text,
    String? assignmentId,
  }) async {
    final t = text.trim();
    if (t.isEmpty && imagePath == null && type == MessageType.text) return;

    final m = Message(
      id: '${DateTime.now().millisecondsSinceEpoch}${Random().nextInt(999)}',
      author: author,
      authorName: authorName ?? (author == 'me' ? 'Р’С‹' : 'РЎС‚СѓРґРµРЅС‚'),
      text: t,
      at: DateTime.now(),
      imagePath: imagePath,
      replyToId: replyToId,
      type: type,
      assignmentId: assignmentId,
    );

    final list = [...state.chat, m];
    await repo.saveChat(state.team.id, list);

    final votes = list.where((x) => x.text.toLowerCase().contains('Р·Р°')).length;
    emit(state.copyWith(chat: list, votes: votes));
  }

  /// Р›РѕРєР°Р»СЊРЅРѕРµ СѓРґР°Р»РµРЅРёРµ СЃРѕРѕР±С‰РµРЅРёСЏ РїРѕ id
  void removeMessage(String id) {
    final idx = state.chat.indexWhere((m) => m.id == id);
    if (idx == -1) return;
    final updated = List<Message>.from(state.chat)..removeAt(idx);
    emit(state.copyWith(chat: updated));
    // РїСЂРё Р¶РµР»Р°РЅРёРё СЃРѕС…СЂР°РЅРёРј Рё РІ Р»РѕРєР°Р»СЊРЅРѕРµ С…СЂР°РЅРёР»РёС‰Рµ
    repo.saveChat(state.team.id, updated);
  }

  // ---------------------------------------------------------------------------
  // Р—РђР”РђРќРРЇ
  // ---------------------------------------------------------------------------

  Future<void> proposeAssignment({
    required String title,
    required String description,
    String? link,
    String? due,
    List<Map<String, String>> attachments = const [],
  }) async {
    final a = Assignment(
      id: 'a_${DateTime.now().millisecondsSinceEpoch}',
      title: title.trim(),
      description: description.trim(),
      link: link?.trim().isEmpty == true ? null : link?.trim(),
      due: due?.trim().isEmpty == true ? null : due?.trim(),
      attachments: attachments,
      published: false,
      votes: 0,
      completedByMe: false,
      createdBy: 'me',
      createdAt: DateTime.now(),
    );

    final items = [...state.assignments, a];
    await repo.saveAssignments(state.team.id, items);
    emit(state.copyWith(assignments: items));

    // РЎРѕРѕР±С‰РµРЅРёРµ Рѕ С‡РµСЂРЅРѕРІРёРєРµ (РѕРґРЅРѕ!)
    await sendMessage(
      'system',
      'Р§РµСЂРЅРѕРІРёРє Р·Р°РґР°РЅРёСЏ: ${a.title}',
      type: MessageType.assignmentDraft,
      assignmentId: a.id,
    );
  }

  /// Р“РѕР»РѕСЃ "Р·Р°" С‡РµСЂРЅРѕРІРёРє вЂ” РїСЂРё РґРѕСЃС‚РёР¶РµРЅРёРё РїРѕСЂРѕРіР° РїСѓР±Р»РёРєСѓРµРј.
  Future<void> voteForPending() async {
    final items = [...state.assignments];
    final idx = items.lastIndexWhere((a) => !a.published);
    if (idx < 0) return;

    final updated = items[idx].copyWith(votes: items[idx].votes + 1);
    items[idx] = updated;

    if (updated.votes >= 3) {
      items[idx] = updated.copyWith(published: true);
      await repo.saveAssignments(state.team.id, items);
      emit(state.copyWith(assignments: items));

      // Р’РјРµСЃС‚Рѕ РЅРѕРІРѕРіРѕ СЃРѕРѕР±С‰РµРЅРёСЏ вЂ” РїСЂРµРІСЂР°С‰Р°РµРј СЃСѓС‰РµСЃС‚РІСѓСЋС‰РёР№ "С‡РµСЂРЅРѕРІРёРє"
      // РІ "РѕРїСѓР±Р»РёРєРѕРІР°РЅРѕ", С‡С‚РѕР±С‹ РЅРµ Р±С‹Р»Рѕ РґСѓР±Р»СЏР¶Р°.
      await _markDraftBubblePublished(updated.id);
    } else {
      await repo.saveAssignments(state.team.id, items);
      emit(state.copyWith(assignments: items));
    }
  }

  /// Р СѓС‡РЅР°СЏ РїСѓР±Р»РёРєР°С†РёСЏ РїРѕСЃР»РµРґРЅРµРіРѕ С‡РµСЂРЅРѕРІРёРєР°
  Future<void> publishPendingManually() async {
    final items = [...state.assignments];
    final idx = items.lastIndexWhere((a) => !a.published);
    if (idx < 0) return;

    final pub = items[idx].copyWith(published: true);
    items[idx] = pub;

    await repo.saveAssignments(state.team.id, items);
    emit(state.copyWith(assignments: items));

    // РџРµСЂРµРІРѕРґРёРј РїСѓР·С‹СЂСЊ "Р§РµСЂРЅРѕРІРёРє" -> "РћРїСѓР±Р»РёРєРѕРІР°РЅРѕ" Р±РµР· РІС‚РѕСЂРѕРіРѕ СЃРѕРѕР±С‰РµРЅРёСЏ.
    await _markDraftBubblePublished(pub.id);
  }

  /// РџРѕРјРµС‚РєР° "РІС‹РїРѕР»РЅРµРЅРѕ" (Р»РѕРєР°Р»СЊРЅРѕ)
  void markAssignmentDone({
    required String assignmentId,
    required bool done,
  }) {
    final set = {...state.doneAssignmentIds};
    if (done) {
      set.add(assignmentId);
    } else {
      set.remove(assignmentId);
    }
    emit(state.copyWith(doneAssignmentIds: set));
  }

  bool isAssignmentDone(String id) => state.doneAssignmentIds.contains(id);

  Future<void> toggleCompleted(String id) async {
    final items = state.assignments.map((a) {
      if (a.id == id) return a.copyWith(completedByMe: !a.completedByMe);
      return a;
    }).toList();
    await repo.saveAssignments(state.team.id, items);
    emit(state.copyWith(assignments: items));
  }

  /// Р РµРґР°РєС‚РёСЂРѕРІР°РЅРёРµ Р·Р°РґР°РЅРёСЏ
  Future<void> updateAssignment(
    String id, {
    String? title,
    String? description,
    String? link,
    String? due,
    List<Map<String, String>>? attachments,
  }) async {
    final items = [...state.assignments];
    final idx = items.indexWhere((e) => e.id == id);
    if (idx < 0) return;

    final src = items[idx];
    items[idx] = src.copyWith(
      title: title ?? src.title,
      description: description ?? src.description,
      link: link ?? src.link,
      due: due ?? src.due,
      attachments: attachments ?? src.attachments,
    );

    await repo.saveAssignments(state.team.id, items);
    emit(state.copyWith(assignments: items));
  }

  /// РЈРґР°Р»РµРЅРёРµ Р·Р°РґР°РЅРёСЏ + СЃРІСЏР·Р°РЅРЅС‹С… СЃ РЅРёРј СЃРѕРѕР±С‰РµРЅРёР№ РІ С‡Р°С‚Рµ
  Future<void> removeAssignment(String id) async {
    final items = state.assignments.where((e) => e.id != id).toList();
    final chat = state.chat.where((m) => m.assignmentId != id).toList();
    await repo.saveAssignments(state.team.id, items);
    await repo.saveChat(state.team.id, chat);
    emit(state.copyWith(assignments: items, chat: chat));
  }

  // ---------------------------------------------------------------------------
  // Р¤РђР™Р›Р«
  // ---------------------------------------------------------------------------

  Future<void> setFiles(List<FileItem> files) async {
    await repo.saveFiles(state.team.id, files);
    emit(state.copyWith(files: files));
  }

  // ---------------------------------------------------------------------------
  // Р’РќРЈРўР Р•РќРќР•Р•: РєРѕРЅРІРµСЂС‚Р°С†РёСЏ РїСѓР·С‹СЂСЏ "С‡РµСЂРЅРѕРІРёРє" РІ "РѕРїСѓР±Р»РёРєРѕРІР°РЅРѕ"
  // ---------------------------------------------------------------------------

  Future<void> _markDraftBubblePublished(String assignmentId) async {
    final chat = [...state.chat];
    for (int i = chat.length - 1; i >= 0; i--) {
      final m = chat[i];
      if (m.assignmentId == assignmentId &&
          m.type == MessageType.assignmentDraft) {
        // РµСЃР»Рё Сѓ Message РµСЃС‚СЊ copyWith(type: ...), РјРѕР¶РµС€СЊ Р·Р°РјРµРЅРёС‚СЊ РЅРёР¶Рµ РЅР° m.copyWith(...)
        final updated = Message(
          id: m.id,
          author: m.author,
          authorName: m.authorName,
          text: m.text,
          at: m.at,
          imagePath: m.imagePath,
          replyToId: m.replyToId,
          type: MessageType.assignmentPublished,
          assignmentId: m.assignmentId,
        );
        chat[i] = updated;
        break;
      }
    }
    await repo.saveChat(state.team.id, chat);
    emit(state.copyWith(chat: chat));
  }
}



===== FILE: src\ui\learning\tabs\assignment_details_screen.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'state/team_cubit.dart';
import 'models/assignment.dart';

class AssignmentDetailsScreen extends StatelessWidget {
  final String assignmentId;
  const AssignmentDetailsScreen({super.key, required this.assignmentId});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      // СЃРІРµС‚Р»С‹Р№ РєРѕРЅС‚СЂР°СЃС‚РЅС‹Р№ С„РѕРЅ В«РєР°Рє Сѓ KeepВ»
      backgroundColor: const Color(0xFFF6F7FB),
      appBar: AppBar(
        title: const Text('Р—Р°РґР°РЅРёРµ'),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.more_vert),
            onPressed: () => _showMore(context),
            tooltip: 'Р•С‰С‘',
          ),
        ],
      ),

      body: BlocBuilder<TeamCubit, TeamState>(
        builder: (context, state) {
          final st = state;
          final a = _pickAssignment(st, assignmentId);

          final isDraft = st.pending?.id == a.id;
          final isDone = context.read<TeamCubit>().isAssignmentDone(a.id);

          return SingleChildScrollView(
            padding: const EdgeInsets.fromLTRB(16, 12, 16, 120),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _AssignmentHeaderCard(
                  assignment: a,
                  isDraft: isDraft,
                  isDone: isDone,
                ),
                const SizedBox(height: 16),
                _SectionCard(
                  title: 'РћРїРёСЃР°РЅРёРµ',
                  child: Text(
                    (a.description.trim().isEmpty)
                        ? 'РћРїРёСЃР°РЅРёСЏ РЅРµС‚.'
                        : a.description,
                    style: const TextStyle(
                      fontSize: 16,
                      height: 1.42,
                      color: Color(0xFF111827), // РїРѕС‡С‚Рё-С‡С‘СЂРЅС‹Р№
                    ),
                  ),
                ),
                if ((a.attachments).isNotEmpty) ...[
                  const SizedBox(height: 12),
                  _SectionCard(
                    title: 'Р’Р»РѕР¶РµРЅРёСЏ',
                    child: Column(
                      children: a.attachments
                          .map((f) => _AttachmentTile(
                                name: f['name'] ?? '',
                                path: f['path'] ?? '',
                              ))
                          .toList(),
                    ),
                  ),
                ],
              ],
            ),
          );
        },
      ),

      // РћР”РќРђ Р±РѕР»СЊС€Р°СЏ РєРЅРѕРїРєР° СЃРЅРёР·Сѓ
      bottomNavigationBar: BlocBuilder<TeamCubit, TeamState>(
        builder: (context, state) {
          final st = state;
          final a = _pickAssignment(st, assignmentId);

          final isDraft = st.pending?.id == a.id;
          final isDone = context.read<TeamCubit>().isAssignmentDone(a.id);

          return SafeArea(
            top: false,
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 10, 16, 16),
              child: Row(
                children: [
                  if (isDraft && st.isStarosta)
                    Expanded(
                      child: _BigButton.icon(
                        icon: Icons.publish_outlined,
                        label: 'РћРїСѓР±Р»РёРєРѕРІР°С‚СЊ',
                        onPressed: () {
                          context.read<TeamCubit>().publishPendingManually();
                          ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(content: Text('Р—Р°РґР°РЅРёРµ РѕРїСѓР±Р»РёРєРѕРІР°РЅРѕ')),
                          );
                        },
                      ),
                    ),
                  if (isDraft && !st.isStarosta)
                    Expanded(
                      child: _BigButton.tonalIcon(
                        icon: Icons.how_to_vote_outlined,
                        label: 'Р“РѕР»РѕСЃРѕРІР°С‚СЊ В«Р·Р°В»',
                        onPressed: () => context.read<TeamCubit>().voteForPending(),
                      ),
                    ),
                  if (!isDraft)
                    Expanded(
                      child: _BigButton.icon(
                        icon: isDone ? Icons.check_circle : Icons.task_alt,
                        label: isDone ? 'Р’С‹РїРѕР»РЅРµРЅРѕ' : 'РћС‚РјРµС‚РёС‚СЊ РєР°Рє РІС‹РїРѕР»РЅРµРЅРѕ',
                        bgColor: isDone ? const Color(0xFF16A34A) : null, // Р·РµР»С‘РЅС‹Р№ РµСЃР»Рё СѓР¶Рµ РІС‹РїРѕР»РЅРµРЅРѕ
                        onPressed: () => context
                            .read<TeamCubit>()
                            .markAssignmentDone(assignmentId: a.id, done: !isDone),
                      ),
                    ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  TeamAssignment _pickAssignment(TeamState st, String id) {
    return (st.assignments).firstWhere(
      (x) => x.id == id,
      orElse: () => st.published.isNotEmpty ? st.published.last : st.assignments.first,
    );
  }

  void _showMore(BuildContext context) {
    showModalBottomSheet(
      context: context,
      showDragHandle: true,
      builder: (_) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.share_outlined),
              title: const Text('РџРѕРґРµР»РёС‚СЊСЃСЏ'),
              onTap: () => Navigator.pop(context),
            ),
          ],
        ),
      ),
    );
  }
}

/// вЂ”вЂ”вЂ” РљР°СЂС‚РѕС‡РєР° В«С€Р°РїРєРёВ»: СЃС‚Р°С‚СѓСЃРЅС‹Рµ С‡РёРїС‹, Р·Р°РіРѕР»РѕРІРѕРє, СЃСЂРѕРє
class _AssignmentHeaderCard extends StatelessWidget {
  final TeamAssignment assignment;
  final bool isDraft;
  final bool isDone;

  const _AssignmentHeaderCard({
    required this.assignment,
    required this.isDraft,
    required this.isDone,
  });

  @override
  Widget build(BuildContext context) {
    final stripe = isDraft
        ? const Color(0xFFF59E0B) // amber-500
        : (isDone ? const Color(0xFF16A34A) : Theme.of(context).colorScheme.primary);

    return Container(
      decoration: BoxDecoration(
        color: Colors.white, // РЇРІРЅРѕ Р±РµР»Р°СЏ РєР°СЂС‚РѕС‡РєР°
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: const Color(0xFFE5E7EB)), // gray-200
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(.06),
            blurRadius: 16,
            offset: const Offset(0, 6),
          ),
        ],
      ),
      clipBehavior: Clip.antiAlias,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // С†РІРµС‚РЅР°СЏ РїРѕР»РѕСЃРєР° СЃРІРµСЂС…Сѓ
          Container(height: 6, color: stripe),
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 14, 16, 16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: [
                    if (isDraft)
                      _StatusChip(
                        icon: Icons.edit_note,
                        label: 'Р§РµСЂРЅРѕРІРёРє',
                        bg: const Color(0xFFFFF3CD),
                        border: const Color(0xFFF59E0B),
                        fgIcon: const Color(0xFFB45309),
                      ),
                    if (!isDraft)
                      _StatusChip(
                        icon: Icons.rocket_launch_outlined,
                        label: 'РћРїСѓР±Р»РёРєРѕРІР°РЅРѕ',
                        bg: const Color(0xFFEFFAF1),
                        border: const Color(0xFF16A34A),
                        fgIcon: const Color(0xFF166534),
                      ),
                    if (isDone)
                      _StatusChip(
                        icon: Icons.check_circle,
                        label: 'Р’С‹РїРѕР»РЅРµРЅРѕ',
                        bg: const Color(0xFFEFFAF1),
                        border: const Color(0xFF16A34A),
                        fgIcon: const Color(0xFF166534),
                      ),
                  ],
                ),
                const SizedBox(height: 12),
                Text(
                  assignment.title,
                  style: const TextStyle(
                    fontSize: 22,
                    fontWeight: FontWeight.w800,
                    letterSpacing: -.1,
                    color: Color(0xFF111827), // РїРѕС‡С‚Рё-С‡С‘СЂРЅС‹Р№
                    height: 1.15,
                  ),
                ),
                if (assignment.due != null) ...[
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      const Icon(Icons.event_outlined, size: 18, color: Color(0xFF6B7280)),
                      const SizedBox(width: 6),
                      Text(
                        'РЎСЂРѕРє: ${_formatDue(assignment.due)}',
                        style: const TextStyle(
                          fontSize: 14,
                          color: Color(0xFF374151),
                        ),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        ],
      ),
    );
  }

  static String _formatDue(dynamic due) {
    if (due is DateTime) {
      String two(int v) => v < 10 ? '0$v' : '$v';
      return '${two(due.day)}.${two(due.month)}.${due.year} ${two(due.hour)}:${two(due.minute)}';
    }
    return '$due';
    // РµСЃР»Рё Сѓ С‚РµР±СЏ СЃС‚СЂРѕРєР° С‚РёРїР° "15.09" вЂ” РѕРЅР° РѕС‚РѕР±СЂР°Р·РёС‚СЃСЏ РєР°Рє РµСЃС‚СЊ
  }
}

class _StatusChip extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color bg;
  final Color border;
  final Color fgIcon;

  const _StatusChip({
    required this.icon,
    required this.label,
    required this.bg,
    required this.border,
    required this.fgIcon,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: border, width: 1),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 16, color: fgIcon),
          const SizedBox(width: 6),
          const Text(
            // С‚С‘РјРЅС‹Р№ С‚РµРєСЃС‚
            // (Р¶С‘СЃС‚РєРѕ, С‡С‚РѕР±С‹ РЅРµ РїРѕР±РµР»РµР» РІ С‚С‘РјРЅРѕР№ С‚РµРјРµ)
            '',
          ),
          Text(
            label,
            style: const TextStyle(
              fontSize: 12.5,
              fontWeight: FontWeight.w600,
              color: Color(0xFF111827),
            ),
          ),
        ],
      ),
    );
  }
}

class _SectionCard extends StatelessWidget {
  final String title;
  final Widget child;

  const _SectionCard({required this.title, required this.child});

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white, // Р±РµР»Р°СЏ СЃРµРєС†РёСЏ
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: const Color(0xFFE5E7EB)),
      ),
      padding: const EdgeInsets.fromLTRB(16, 14, 16, 16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(
              fontSize: 15,
              fontWeight: FontWeight.w800,
              color: Color(0xFF111827),
            ),
          ),
          const SizedBox(height: 10),
          child,
        ],
      ),
    );
  }
}

class _AttachmentTile extends StatelessWidget {
  final String name;
  final String path;
  const _AttachmentTile({required this.name, required this.path});

  @override
  Widget build(BuildContext context) {
    final ext = name.split('.').last.toLowerCase();
    IconData icon = Icons.insert_drive_file_outlined;
    if (['pdf'].contains(ext)) icon = Icons.picture_as_pdf_outlined;
    if (['png', 'jpg', 'jpeg', 'webp', 'gif'].contains(ext)) icon = Icons.image_outlined;
    if (['xls', 'xlsx', 'csv'].contains(ext)) icon = Icons.table_chart_outlined;
    if (['doc', 'docx'].contains(ext)) icon = Icons.description_outlined;
    if (['zip', 'rar', '7z'].contains(ext)) icon = Icons.archive_outlined;

    return ListTile(
      dense: false,
      contentPadding: EdgeInsets.zero,
      minVerticalPadding: 6,
      leading: Icon(icon, color: const Color(0xFF6B7280)),
      title: Text(
        name,
        style: const TextStyle(
          fontSize: 15,
          fontWeight: FontWeight.w600,
          color: Color(0xFF111827),
        ),
      ),
      subtitle: Text(
        path,
        style: const TextStyle(
          fontSize: 12.5,
          color: Color(0xFF6B7280),
        ),
      ),
      trailing: IconButton(
        icon: const Icon(Icons.more_horiz),
        onPressed: () {},
        tooltip: 'Р”РµР№СЃС‚РІРёСЏ',
      ),
      onTap: () {},
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    );
  }
}

/// РљСЂР°СЃРёРІР°СЏ В«Р±РѕР»СЊС€Р°СЏ РєРЅРѕРїРєР°В» (Stadium/СЂР°РґРёСѓСЃ 28, РІС‹СЃРѕС‚Р° 52)
class _BigButton extends StatelessWidget {
  final VoidCallback onPressed;
  final String label;
  final IconData? icon;
  final Color? bgColor;
  final bool tonal;

  const _BigButton._({
    required this.onPressed,
    required this.label,
    this.icon,
    this.bgColor,
    this.tonal = false,
  });

  factory _BigButton.icon({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
    Color? bgColor,
  }) =>
      _BigButton._(icon: icon, label: label, onPressed: onPressed, bgColor: bgColor);

  factory _BigButton.tonalIcon({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
  }) =>
      _BigButton._(
        icon: icon,
        label: label,
        onPressed: onPressed,
        tonal: true,
      );

  @override
  Widget build(BuildContext context) {
    final scheme = Theme.of(context).colorScheme;
    final bg = tonal ? scheme.secondaryContainer : (bgColor ?? scheme.primary);
    final fg = tonal ? scheme.onSecondaryContainer : Colors.white;

    return SizedBox(
      height: 52,
      child: ElevatedButton.icon(
        onPressed: onPressed,
        icon: Icon(icon),
        label: Text(label),
        style: ButtonStyle(
          backgroundColor: MaterialStatePropertyAll(bg),
          foregroundColor: MaterialStatePropertyAll(fg),
          shape: MaterialStatePropertyAll(
            const StadiumBorder(),
          ),
          textStyle: const MaterialStatePropertyAll(
            TextStyle(fontSize: 16, fontWeight: FontWeight.w700),
          ),
          elevation: const MaterialStatePropertyAll(0),
        ),
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\assignments\assignment_card.dart =====
import 'package:flutter/material.dart';
import '../../models/assignment.dart';

class AssignmentCard extends StatelessWidget {
  final Assignment assignment;
  final bool isDraft;
  final bool canPublish;
  final VoidCallback onOpen;
  final VoidCallback? onPublish;
  final VoidCallback? onVote;
  final VoidCallback? onEdit;
  final VoidCallback? onDelete;

  const AssignmentCard({
    super.key,
    required this.assignment,
    required this.onOpen,
    this.onPublish,
    this.onVote,
    this.onEdit,
    this.onDelete,
    this.isDraft = false,
    this.canPublish = false,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final bg = isDraft ? Colors.amber.withOpacity(.14) : cs.surfaceContainerHigh;
    final border = isDraft ? Colors.orangeAccent : cs.outlineVariant;

    return Container(
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: border.withOpacity(.6), width: .5),
      ),
      padding: const EdgeInsets.all(12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(isDraft ? Icons.edit_note_outlined : Icons.assignment_outlined, color: isDraft ? Colors.orangeAccent : cs.primary),
              const SizedBox(width: 8),
              Expanded(
                child: Text(assignment.title, style: const TextStyle(fontWeight: FontWeight.w700)),
              ),
              PopupMenuButton<String>(
                itemBuilder: (_) => const [
                  PopupMenuItem(value: 'open', child: Text('РћС‚РєСЂС‹С‚СЊ')),
                  PopupMenuItem(value: 'edit', child: Text('Р РµРґР°РєС‚РёСЂРѕРІР°С‚СЊ')),
                  PopupMenuItem(value: 'delete', child: Text('РЈРґР°Р»РёС‚СЊ')),
                ],
                onSelected: (v) {
                  if (v == 'open') onOpen();
                  if (v == 'edit') onEdit?.call();
                  if (v == 'delete') onDelete?.call();
                },
              ),
            ],
          ),
          if (assignment.due != null)
            Padding(
              padding: const EdgeInsets.only(top: 4),
              child: Text('РґРѕ ${assignment.due}', style: Theme.of(context).textTheme.bodySmall),
            ),
          if (assignment.description.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 8),
              child: Text(assignment.description, maxLines: 3, overflow: TextOverflow.ellipsis),
            ),
          const SizedBox(height: 8),
          Row(
            children: [
              TextButton(onPressed: onOpen, child: const Text('РћС‚РєСЂС‹С‚СЊ')),
              const Spacer(),
              if (isDraft && !canPublish)
                OutlinedButton.icon(onPressed: onVote, icon: const Icon(Icons.how_to_vote_outlined, size: 18), label: const Text('Р—Р°')),
              if (canPublish)
                FilledButton.icon(onPressed: onPublish, icon: const Icon(Icons.publish_outlined, size: 18), label: const Text('РћРїСѓР±Р»РёРєРѕРІР°С‚СЊ')),
              if (isDraft) ...[
                const SizedBox(width: 8),
                Chip(label: Text('${assignment.votes}/3'), visualDensity: VisualDensity.compact),
              ],
            ],
          ),
        ],
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\assignments\assignments_tab.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../state/team_cubit.dart';
import '../../models/assignment.dart';
import '../../assignment_details_screen.dart';
import 'assignment_card.dart';

enum _Filter { all, active, overdue, draft }

class AssignmentsTab extends StatefulWidget {
  final Object? team; // СЃРѕРІРјРµСЃС‚РёРјРѕСЃС‚СЊ СЃ РІС‹Р·РѕРІРѕРј AssignmentsTab(team: state.team)
  const AssignmentsTab({super.key, this.team});

  @override
  State<AssignmentsTab> createState() => _AssignmentsTabState();
}

class _AssignmentsTabState extends State<AssignmentsTab> {
  _Filter _filter = _Filter.all;

  @override
  Widget build(BuildContext context) {
    final st = context.watch<TeamCubit>().state;
    final items = _apply(st);

    return Column(
      children: [
        const SizedBox(height: 8),
        _Filters(
          value: _filter,
          hasDraft: st.hasPending,
          onChanged: (v) => setState(() => _filter = v),
        ),
        Expanded(
          child: ListView.separated(
            padding: const EdgeInsets.fromLTRB(12, 8, 12, 12),
            itemCount: items.length,
            separatorBuilder: (_, __) => const SizedBox(height: 10),
            itemBuilder: (_, i) {
              final a = items[i];
              final isDraft = st.pending?.id == a.id;
              return AssignmentCard(
                assignment: a,
                isDraft: isDraft,
                canPublish: isDraft && st.isStarosta,
                onOpen: () => Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (_) => BlocProvider.value(
                      value: context.read<TeamCubit>(),
                      child: AssignmentDetailsScreen(assignmentId: a.id),
                    ),
                  ),
                ),
                onPublish: () => context.read<TeamCubit>().publishPendingManually(),
                onVote: () => context.read<TeamCubit>().voteForPending(),
                onEdit: () async {
                  final res = await _editAssignmentDialog(context, a);
                  if (res == null) return;
                  await context.read<TeamCubit>().updateAssignment(
                        a.id,
                        title: res.$1,
                        description: res.$2,
                        link: res.$3,
                        due: res.$4,
                        attachments: res.$5,
                      );
                },
                onDelete: () => context.read<TeamCubit>().removeAssignment(a.id),
              );
            },
          ),
        ),
      ],
    );
  }

  List<Assignment> _apply(TeamState st) {
    final now = DateTime.now();
    bool overdue(Assignment a) {
      if (a.due == null) return false;
      final parts = a.due!.split('.');
      if (parts.length != 2) return false;
      final d = int.tryParse(parts[0]) ?? 1;
      final m = int.tryParse(parts[1]) ?? 1;
      final due = DateTime(now.year, m, d);
      return due.isBefore(DateTime(now.year, now.month, now.day));
    }

    Iterable<Assignment> base = st.assignments;
    switch (_filter) {
      case _Filter.all:
        break;
      case _Filter.active:
        base = base.where((a) => !overdue(a));
        break;
      case _Filter.overdue:
        base = base.where(overdue);
        break;
      case _Filter.draft:
        final p = st.pending;
        base = p == null ? const Iterable.empty() : [p];
        break;
    }
    return base.toList();
  }

  Future<(String, String, String?, String?, List<Map<String, String>>)?> _editAssignmentDialog(
      BuildContext context, Assignment a) async {
    final title = TextEditingController(text: a.title);
    final desc  = TextEditingController(text: a.description);
    final link  = TextEditingController(text: a.link ?? '');
    final due   = TextEditingController(text: a.due ?? '');
    final files = [...a.attachments];

    return showDialog<(String, String, String?, String?, List<Map<String, String>>)>(
      context: context,
      builder: (_) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Center(child: Text('Р РµРґР°РєС‚РёСЂРѕРІР°С‚СЊ Р·Р°РґР°РЅРёРµ', style: TextStyle(fontWeight: FontWeight.w700))),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(controller: title, decoration: const InputDecoration(labelText: 'РќР°Р·РІР°РЅРёРµ')),
                const SizedBox(height: 8),
                TextField(controller: desc, minLines: 3, maxLines: 6, decoration: const InputDecoration(labelText: 'Р§С‚Рѕ СЃРґРµР»Р°С‚СЊ')),
                const SizedBox(height: 8),
                TextField(controller: link, decoration: const InputDecoration(labelText: 'РЎСЃС‹Р»РєР° (РѕРїС†.)')),
                const SizedBox(height: 8),
                TextField(controller: due, decoration: const InputDecoration(labelText: 'РЎСЂРѕРє (РЅР°РїСЂ. 20.09)')),
                const SizedBox(height: 8),
                for (final f in files)
                  ListTile(
                    dense: true,
                    leading: const Icon(Icons.insert_drive_file_outlined),
                    title: Text(f['name'] ?? ''),
                    subtitle: Text(f['path'] ?? ''),
                  ),
              ],
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context), child: const Text('РћС‚РјРµРЅР°')),
            FilledButton(
              onPressed: () {
                if (title.text.trim().isEmpty || desc.text.trim().isEmpty) return;
                Navigator.pop(context, (
                  title.text.trim(),
                  desc.text.trim(),
                  link.text.trim().isEmpty ? null : link.text.trim(),
                  due.text.trim().isEmpty ? null : due.text.trim(),
                  files
                ));
              },
              child: const Text('РЎРѕС…СЂР°РЅРёС‚СЊ'),
            ),
          ],
        ),
      ),
    );
  }
}

class _Filters extends StatelessWidget {
  final _Filter value;
  final bool hasDraft;
  final ValueChanged<_Filter> onChanged;
  const _Filters({required this.value, required this.hasDraft, required this.onChanged});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    Widget chip(_Filter f, String label) {
      final sel = value == f;
      return ChoiceChip(
        label: Text(label),
        selected: sel,
        onSelected: (_) => onChanged(f),
        selectedColor: cs.primary.withOpacity(.12),
      );
    }

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      padding: const EdgeInsets.symmetric(horizontal: 12),
      child: Row(
        children: [
          chip(_Filter.all, 'Р’СЃРµ'),
          const SizedBox(width: 8),
          chip(_Filter.active, 'РђРєС‚РёРІРЅС‹Рµ'),
          const SizedBox(width: 8),
          chip(_Filter.overdue, 'РџСЂРѕСЃСЂРѕС‡РµРЅРЅС‹Рµ'),
          if (hasDraft) ...[
            const SizedBox(width: 8),
            chip(_Filter.draft, 'Р§РµСЂРЅРѕРІРёРє'),
          ],
        ],
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\assignments\view_mode.dart =====
import 'package:flutter/foundation.dart';

/// Р•РґРёРЅР°СЏ С‚РѕС‡РєР° РїСЂР°РІРґС‹ РґР»СЏ СЂРµР¶РёРјР° РѕС‚РѕР±СЂР°Р¶РµРЅРёСЏ Р·Р°РґР°РЅРёР№.
/// false = СЃРїРёСЃРѕРє, true = СЃРµС‚РєР°
class AssignmentsViewMode {
  static final ValueNotifier<bool> grid = ValueNotifier<bool>(false);
}



===== FILE: src\ui\learning\tabs\assignments_tab.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../state/team_cubit.dart';
import '../models/assignment.dart';
import '../models/team.dart';
import '../assignment_details_screen.dart';

// РѕР±С‰РёР№ notifier
import 'assignments/view_mode.dart';

class AssignmentsTab extends StatelessWidget {
  final Team team;
  const AssignmentsTab({super.key, required this.team});

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<bool>(
      valueListenable: AssignmentsViewMode.grid,
      builder: (context, asGrid, _) {
        return BlocBuilder<TeamCubit, TeamState>(
          builder: (context, state) {
            final items = [...state.assignments];

            int rank(Assignment x) {
              if (!x.published) return 0;
              if (!x.completedByMe) return 1;
              return 2;
            }

            items.sort((a, b) {
              final r = rank(a) - rank(b);
              if (r != 0) return r;
              return a.createdAt.compareTo(b.createdAt);
            });

            if (items.isEmpty) {
              return const Center(child: Text('РџРѕРєР° РЅРµС‚ Р·Р°РґР°РЅРёР№'));
            }

            if (asGrid) {
              return GridView.builder(
                padding: const EdgeInsets.fromLTRB(12, 8, 12, 12),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 2,
                  mainAxisSpacing: 10,
                  crossAxisSpacing: 10,
                  childAspectRatio: 1.05,
                ),
                itemCount: items.length,
                itemBuilder: (context, i) => _AssignmentCardTile(
                  a: items[i],
                  onOpen: () => _openDetails(context, items[i].id),
                  onToggle: () => context.read<TeamCubit>().toggleCompleted(items[i].id),
                ),
              );
            }

            // СЃРїРёСЃРѕРє
            return ListView.separated(
              padding: const EdgeInsets.all(12),
              itemCount: items.length,
              separatorBuilder: (_, __) => const SizedBox(height: 8),
              itemBuilder: (context, i) => _AssignmentRowTile(
                a: items[i],
                onOpen: () => _openDetails(context, items[i].id),
                onToggle: () => context.read<TeamCubit>().toggleCompleted(items[i].id),
              ),
            );
          },
        );
      },
    );
  }

  void _openDetails(BuildContext context, String id) {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (_) => BlocProvider.value(
          value: context.read<TeamCubit>(),
          child: AssignmentDetailsScreen(assignmentId: id),
        ),
      ),
    );
  }
}

class _AssignmentRowTile extends StatelessWidget {
  final Assignment a;
  final VoidCallback onOpen;
  final VoidCallback onToggle;

  const _AssignmentRowTile({
    required this.a,
    required this.onOpen,
    required this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    final isDraft = !a.published;
    final isDone = a.completedByMe;
    final cs = Theme.of(context).colorScheme;

    Color cardColor() {
      if (isDraft) return cs.surfaceContainerHighest.withOpacity(.5);
      if (isDone) return Colors.green.withOpacity(.10);
      return cs.surface;
    }

    return InkWell(
      borderRadius: BorderRadius.circular(14),
      onTap: onOpen,
      child: Container(
        decoration: BoxDecoration(
          color: cardColor(),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(
            color: isDone ? Colors.green : cs.outlineVariant.withOpacity(.6),
            width: 1,
          ),
        ),
        padding: const EdgeInsets.all(12),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Icon(
              isDraft ? Icons.pending_outlined : Icons.assignment_outlined,
              color: isDone ? Colors.green : cs.primary,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Expanded(
                        child: Text(
                          a.title,
                          style: const TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w700,
                            color: Colors.black87,
                          ),
                        ),
                      ),
                      const SizedBox(width: 8),
                      if ((a.due ?? '').isNotEmpty)
                        Text('РґРѕ ${a.due!}',
                            style: const TextStyle(fontSize: 13, color: Colors.black54)),
                    ],
                  ),
                  if (a.description.isNotEmpty) ...[
                    const SizedBox(height: 6),
                    Text(
                      a.description,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(fontSize: 14, color: Colors.black87),
                    ),
                  ],
                  const SizedBox(height: 10),
                  Row(
                    children: [
                      _statusChip(context, isDraft, isDone),
                      const Spacer(),
                      if (!isDraft)
                        OutlinedButton.icon(
                          icon: Icon(isDone
                              ? Icons.check_box
                              : Icons.check_box_outline_blank),
                          label: Text(isDone ? 'РќРµ РІС‹РїРѕР»РЅРµРЅРѕ' : 'Р’С‹РїРѕР»РЅРµРЅРѕ'),
                          onPressed: onToggle,
                        ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _statusChip(BuildContext context, bool isDraft, bool isDone) {
    final cs = Theme.of(context).colorScheme;
    if (isDraft) {
      return Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: cs.secondaryContainer,
          borderRadius: BorderRadius.circular(8),
        ),
        child: const Text('Р§РµСЂРЅРѕРІРёРє', style: TextStyle(fontSize: 12)),
      );
    }
    if (isDone) {
      return Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: Colors.green.withOpacity(.15),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: Colors.green),
        ),
        child: const Text('Р’С‹РїРѕР»РЅРµРЅРѕ', style: TextStyle(fontSize: 12, color: Colors.green)),
      );
    }
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: cs.primaryContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: const Text('РћРїСѓР±Р»РёРєРѕРІР°РЅРѕ', style: TextStyle(fontSize: 12)),
    );
  }
}

class _AssignmentCardTile extends StatelessWidget {
  final Assignment a;
  final VoidCallback onOpen;
  final VoidCallback onToggle;

  const _AssignmentCardTile({
    required this.a,
    required this.onOpen,
    required this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    final isDraft = !a.published;
    final isDone = a.completedByMe;
    final cs = Theme.of(context).colorScheme;

    Color cardColor() {
      if (isDraft) return cs.surfaceContainerHighest.withOpacity(.5);
      if (isDone) return Colors.green.withOpacity(.10);
      return cs.surface;
    }

    return InkWell(
      borderRadius: BorderRadius.circular(14),
      onTap: onOpen,
      child: Container(
        decoration: BoxDecoration(
          color: cardColor(),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(
            color: isDone ? Colors.green : cs.outlineVariant.withOpacity(.6),
            width: 1,
          ),
        ),
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  isDraft ? Icons.pending_outlined : Icons.assignment_outlined,
                  color: isDone ? Colors.green : cs.primary,
                ),
                const Spacer(),
                if (!isDraft)
                  IconButton(
                    tooltip: isDone ? 'РћС‚РјРµС‚РёС‚СЊ РєР°Рє РЅРµ РІС‹РїРѕР»РЅРµРЅРѕ' : 'РћС‚РјРµС‚РёС‚СЊ РєР°Рє РІС‹РїРѕР»РЅРµРЅРѕ',
                    icon: Icon(isDone ? Icons.check_box : Icons.check_box_outline_blank, size: 22),
                    onPressed: onToggle,
                  ),
              ],
            ),
            const SizedBox(height: 8),
            Expanded(
              child: Text(
                a.title,
                maxLines: 4,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w800,
                  color: Colors.black87,
                  height: 1.2,
                ),
              ),
            ),
            const SizedBox(height: 6),
            Row(
              children: [
                _statusMini(isDraft, isDone, cs),
                const Spacer(),
                if ((a.due ?? '').isNotEmpty)
                  Text('РґРѕ ${a.due!}', style: const TextStyle(fontSize: 12, color: Colors.black54)),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _statusMini(bool isDraft, bool isDone, ColorScheme cs) {
    Color bg;
    String text;
    Color? border;
    if (isDraft) {
      bg = cs.secondaryContainer; text = 'Р§РµСЂРЅРѕРІРёРє';
    } else if (isDone) {
      bg = Colors.green.withOpacity(.12); text = 'Р’С‹РїРѕР»РЅРµРЅРѕ'; border = Colors.green;
    } else {
      bg = cs.primaryContainer; text = 'РћРїСѓР±Р»РёРєРѕРІР°РЅРѕ';
    }
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(8),
        border: border != null ? Border.all(color: border) : null,
      ),
      child: Text(text, style: const TextStyle(fontSize: 11)),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat\assignment_bubble.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../state/team_cubit.dart';
import '../../models/message.dart';
import '../../models/assignment.dart';

class AssignmentBubble extends StatelessWidget {
  final Message message;
  final bool isDraft; // true -> С‡РµСЂРЅРѕРІРёРє, false -> РѕРїСѓР±Р»РёРєРѕРІР°РЅРѕ
  final String time;
  final VoidCallback? onOpen;
  final VoidCallback? onPublish; // РґР»СЏ СЃС‚Р°СЂРѕСЃС‚С‹
  final VoidCallback? onVote;    // РґР»СЏ РѕР±С‹С‡РЅС‹С…
  final VoidCallback? onLongPress;
  final VoidCallback? onPin;

  const AssignmentBubble({
    super.key,
    required this.message,
    required this.isDraft,
    required this.time,
    this.onOpen,
    this.onPublish,
    this.onVote,
    this.onLongPress,
    this.onPin,
  });

  @override
  Widget build(BuildContext context) {
    final st = context.watch<TeamCubit>().state;

    Assignment? a;
    final byId = st.assignments.where((e) => e.id == message.assignmentId);
    if (byId.isNotEmpty) a = byId.first;
    else if (st.published.isNotEmpty) a = st.published.last;
    if (a == null) return const SizedBox.shrink();

    final cs = Theme.of(context).colorScheme;
    final isMe = false; // СЃРёСЃС‚РµРјРЅРѕРµ СЃРѕРѕР±С‰РµРЅРёРµ
    final bg   = isDraft ? cs.secondaryContainer.withOpacity(.35)
                         : cs.primary.withOpacity(.10);
    final border = isDraft ? Colors.amber : cs.primary;

    final titleColor = Colors.black.withOpacity(.92);
    final dueColor   = Colors.black.withOpacity(.60);

    return GestureDetector(
      onLongPress: onLongPress,
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          _systemAvatar(),
          const SizedBox(width: 8),
          Flexible(
            child: Container(
              padding: const EdgeInsets.fromLTRB(12, 10, 12, 8),
              decoration: BoxDecoration(
                color: bg,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: border.withOpacity(.45), width: .7),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Р·Р°РіРѕР»РѕРІРѕРє-СЃС‚СЂРѕРєР°
                  Row(
                    children: [
                      Icon(isDraft ? Icons.edit_note_outlined : Icons.assignment_outlined,
                          size: 18, color: border),
                      const SizedBox(width: 6),
                      Text(
                        isDraft ? 'Р§РµСЂРЅРѕРІРёРє Р·Р°РґР°РЅРёСЏ' : 'Р—Р°РґР°РЅРёРµ',
                        style: const TextStyle(fontWeight: FontWeight.w700),
                      ),
                      const Spacer(),
                      Text(time, style: TextStyle(fontSize: 12, color: Colors.grey.shade700)),
                      const SizedBox(width: 4),
                      _More(onPin: onPin, onLongPress: onLongPress),
                    ],
                  ),
                  const SizedBox(height: 8),

                  // РєРѕРЅС‚РµРЅС‚
                  Text(a.title,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        fontWeight: FontWeight.w600,
                        color: titleColor,
                      )),
                  if (a.due != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 2),
                      child: Text('РґРѕ ${a.due}',
                          style: TextStyle(fontSize: 12, color: dueColor)),
                    ),
                  if ((a.description).trim().isNotEmpty) ...[
                    const SizedBox(height: 6),
                    Text(a.description,
                        maxLines: 3,
                        overflow: TextOverflow.ellipsis,
                        style: TextStyle(color: Colors.black.withOpacity(.85))),
                  ],

                  const SizedBox(height: 8),
                  Row(
                    children: [
                      TextButton(onPressed: onOpen, child: const Text('РћС‚РєСЂС‹С‚СЊ')),

                      const Spacer(),

                      if (isDraft && st.isStarosta) // СЃС‚Р°СЂРѕСЃС‚Р° РїСѓР±Р»РёРєСѓРµС‚
                        FilledButton.icon(
                          onPressed: onPublish,
                          icon: const Icon(Icons.upload_rounded, size: 18),
                          label: const Text('РћРїСѓР±Р»РёРєРѕРІР°С‚СЊ'),
                        ),

                      if (isDraft && !st.isStarosta) // СѓС‡Р°СЃС‚РЅРёРє РіРѕР»РѕСЃСѓРµС‚
                        OutlinedButton.icon(
                          onPressed: onVote,
                          icon: const Icon(Icons.how_to_vote_outlined, size: 18),
                          label: const Text('Р—Р°'),
                        ),

                      if (!isDraft)
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                          decoration: BoxDecoration(
                            color: Colors.green.withOpacity(.12),
                            borderRadius: BorderRadius.circular(20),
                            border: Border.all(color: Colors.green.withOpacity(.35)),
                          ),
                          child: Row(
                            children: const [
                              Icon(Icons.check_circle, size: 16, color: Colors.green),
                              SizedBox(width: 6),
                              Text('РћРїСѓР±Р»РёРєРѕРІР°РЅРѕ',
                                  style: TextStyle(fontWeight: FontWeight.w600, color: Colors.green)),
                            ],
                          ),
                        ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _systemAvatar() {
    return const CircleAvatar(
      radius: 14,
      child: Text('РЎР', style: TextStyle(fontSize: 11)),
    );
  }
}

class _More extends StatelessWidget {
  final VoidCallback? onPin;
  final VoidCallback? onLongPress;
  const _More({this.onPin, this.onLongPress});

  @override
  Widget build(BuildContext context) {
    return PopupMenuButton<String>(
      tooltip: 'Р”РµР№СЃС‚РІРёСЏ',
      onSelected: (v) {
        if (v == 'pin' && onPin != null) onPin!();
        if (v == 'more' && onLongPress != null) onLongPress!();
      },
      itemBuilder: (c) => [
        const PopupMenuItem(value: 'pin', child: Text('Р—Р°РєСЂРµРїРёС‚СЊ')),
        const PopupMenuItem(value: 'more', child: Text('Р•С‰С‘вЂ¦')),
      ],
      child: const Padding(
        padding: EdgeInsets.all(4.0),
        child: Icon(Icons.more_vert, size: 18),
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat\composer.dart =====
import 'dart:io';
import 'package:flutter/material.dart';

class Composer extends StatelessWidget {
  final TextEditingController controller;
  final String? pickedImagePath;
  final Widget? leftButton;
  final VoidCallback onOpenEmoji;     // РѕС‚РєСЂС‹С‚СЊ СЃРёСЃС‚РµРјРЅСѓСЋ РєР»Р°РІРёР°С‚СѓСЂСѓ / С„РѕРєСѓСЃ
  final VoidCallback onSend;
  final VoidCallback onClearPicked;
  final Future<void> Function() onPickImage;
  final FocusNode? focusNode;

  const Composer({
    super.key,
    required this.controller,
    required this.pickedImagePath,
    required this.onOpenEmoji,
    required this.onSend,
    required this.onClearPicked,
    required this.onPickImage,
    this.leftButton,
    this.focusNode,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return SafeArea(
      top: false,
      child: Padding(
        // Р±РµР· С…РёРЅС‚РѕРІ/РїРѕРґРїРёСЃРµР№ СЃРЅРёР·Сѓ
        padding: const EdgeInsets.fromLTRB(12, 10, 12, 12),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (pickedImagePath != null)
              Container(
                margin: const EdgeInsets.only(bottom: 8),
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: theme.colorScheme.surface,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: theme.colorScheme.outline.withOpacity(.2)),
                ),
                child: Row(
                  children: [
                    ClipRRect(
                      borderRadius: BorderRadius.circular(8),
                      child: Image.file(
                        File(pickedImagePath!),
                        height: 44,
                        width: 44,
                        fit: BoxFit.cover,
                      ),
                    ),
                    const SizedBox(width: 10),
                    const Expanded(child: Text('Р’Р»РѕР¶РµРЅРёРµ РіРѕС‚РѕРІРѕ')),
                    IconButton(icon: const Icon(Icons.close), onPressed: onClearPicked),
                  ],
                ),
              ),

            Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                leftButton ?? const SizedBox(width: 0),
                if (leftButton != null) const SizedBox(width: 8),

                Expanded(
                  child: Container(
                    decoration: BoxDecoration(
                      color: theme.colorScheme.surface,
                      borderRadius: BorderRadius.circular(24),
                      border: Border.all(color: theme.colorScheme.outline.withOpacity(.2)),
                    ),
                    padding: const EdgeInsets.symmetric(horizontal: 10),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.end,
                      children: [
                        IconButton(
                          icon: const Icon(Icons.emoji_emotions_outlined),
                          onPressed: onOpenEmoji, // РїСЂРѕСЃС‚Рѕ РѕС‚РєСЂС‹РІР°РµРј РєР»Р°РІРёР°С‚СѓСЂСѓ/РґР°С‘Рј С„РѕРєСѓСЃ
                          tooltip: 'Р­РјРѕРґР·Рё',
                        ),

                        // РѕРґРЅР° СЃС‚СЂРѕРєР° в†’ Р°РІС‚Рѕ-СЂРѕСЃС‚ РґРѕ 6 (Р±РµР· РіРѕСЂРёР·РѕРЅС‚Р°Р»СЊРЅРѕРіРѕ СЃРєСЂРѕР»Р»Р°)
                        Expanded(
                          child: TextField(
                            focusNode: focusNode,
                            controller: controller,
                            keyboardType: TextInputType.multiline,
                            textInputAction: TextInputAction.send, // Enter вЂ” РѕС‚РїСЂР°РІРєР°
                            minLines: 1,
                            maxLines: 6,
                            decoration: const InputDecoration(
                              hintText: 'РЎРѕРѕР±С‰РµРЅРёРµ',
                              border: InputBorder.none,
                              isCollapsed: true,
                              contentPadding: EdgeInsets.symmetric(vertical: 12),
                            ),
                            onSubmitted: (_) => onSend(),
                          ),
                        ),

                        IconButton(
                          icon: const Icon(Icons.camera_alt_outlined),
                          onPressed: () => onPickImage(), // РёР· РіР°Р»РµСЂРµРё (gif РїРѕРґРґРµСЂР¶РёРІР°СЋС‚СЃСЏ РєР°Рє С„Р°Р№Р»)
                          tooltip: 'РР·РѕР±СЂР°Р¶РµРЅРёРµ',
                        ),
                      ],
                    ),
                  ),
                ),

                const SizedBox(width: 8),
                IconButton(
                  icon: const Icon(Icons.send_rounded),
                  onPressed: onSend,
                  tooltip: 'РћС‚РїСЂР°РІРёС‚СЊ',
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat\emoji_sheet.dart =====
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:emoji_picker_flutter/emoji_picker_flutter.dart';

/// РњРѕРґР°Р»СЊРЅРѕРµ РѕРєРЅРѕ СЃ СЌРјРѕРґР·Рё (СЃРѕРІСЂРµРјРµРЅРЅС‹Р№ UX):
/// - СЃРІРµСЂС…Сѓ РїР°РЅРµР»СЊ СЃ РєРЅРѕРїРєРѕР№ В«РєР»Р°РІРёР°С‚СѓСЂР°В» вЂ” Р·Р°РєСЂС‹РІР°РµС‚ РјРѕРґР°Р»РєСѓ Рё СЃСЂР°Р·Сѓ С„РѕРєСѓСЃРёС‚ РїРѕР»Рµ РІРІРѕРґР°;
/// - СЌРјРѕРґР·Рё РІСЃС‚Р°РІР»СЏСЋС‚СЃСЏ РёРјРµРЅРЅРѕ РІ РїРѕР·РёС†РёСЋ РєСѓСЂСЃРѕСЂР°.
void showEmojiPickerSheet(
  BuildContext context, {
  required TextEditingController controller,
  FocusNode? textFieldFocus, // С‡С‚РѕР±С‹ РІРµСЂРЅСѓС‚СЊ РєР»Р°РІРёР°С‚СѓСЂСѓ РїРѕ РєРЅРѕРїРєРµ
}) {
  showModalBottomSheet(
    context: context,
    useSafeArea: true,
    isScrollControlled: true,
    showDragHandle: true,
    builder: (sheetCtx) => SizedBox(
      height: 340,
      child: Column(
        children: [
          // Р’РµСЂС…РЅСЏСЏ РїР°РЅРµР»СЊ РґРµР№СЃС‚РІРёР№ (Р»РµРіРєРѕРµ РїРµСЂРµРєР»СЋС‡РµРЅРёРµ РЅР° РєР»Р°РІРёР°С‚СѓСЂСѓ)
          Row(
            children: [
              const SizedBox(width: 12),
              const Padding(
                padding: EdgeInsets.symmetric(vertical: 10),
                child: Text('Р­РјРѕРґР·Рё', style: TextStyle(fontWeight: FontWeight.w600)),
              ),
              const Spacer(),
              IconButton(
                tooltip: 'РљР»Р°РІРёР°С‚СѓСЂР°',
                onPressed: () {
                  Navigator.pop(sheetCtx);
                  // РІРµСЂРЅСѓС‚СЊ С„РѕРєСѓСЃ РІ РїРѕР»Рµ; РєР»Р°РІРёР°С‚СѓСЂР° РїРѕРґРЅРёРјРµС‚СЃСЏ СЃР°РјР°
                  if (textFieldFocus != null) {
                    // С‡СѓС‚РєР° РѕС‚Р»РѕР¶РёРј, С‡С‚РѕР±С‹ РјРѕРґР°Р»РєР° СѓСЃРїРµР»Р° Р·Р°РєСЂС‹С‚СЊСЃСЏ
                    Future.microtask(() => textFieldFocus.requestFocus());
                  }
                },
                icon: const Icon(Icons.keyboard_alt_outlined),
              ),
            ],
          ),
          const Divider(height: 0),

          // РЎР°Рј РїРёРєРµСЂ
          Expanded(
            child: EmojiPicker(
              onEmojiSelected: (_, emoji) {
                final sel = controller.selection;
                final text = controller.text;
                final start = sel.start >= 0 ? sel.start : text.length;
                final end   = sel.end   >= 0 ? sel.end   : text.length;
                controller.value = TextEditingValue(
                  text: text.replaceRange(start, end, emoji.emoji),
                  selection: TextSelection.collapsed(offset: start + emoji.emoji.length),
                );
              },
              config: const Config(
                bottomActionBarConfig: BottomActionBarConfig(enabled: true),
                emojiViewConfig: EmojiViewConfig(emojiSizeMax: 32),
                categoryViewConfig: CategoryViewConfig(
                  indicatorColor: Colors.grey,
                  iconColorSelected: Colors.white,
                ),
              ),
            ),
          ),
        ],
      ),
    ),
  );
}



===== FILE: src\ui\learning\tabs\chat\keyboard_capture.dart =====
import 'dart:io';
import 'package:flutter/services.dart' as services;
import 'package:flutter/widgets.dart';

const _channel = services.MethodChannel('keyboard_image_channel');

class KeyboardCaptureController {
  Future<void> focus() async {
    if (Platform.isAndroid) {
      await _channel.invokeMethod('focus');
    }
  }

  Future<void> dispose() async {
    if (Platform.isAndroid) {
      await _channel.invokeMethod('dispose');
    }
  }
}

typedef KeyboardPicked = void Function(String path);

class KeyboardCapture extends StatefulWidget {
  final KeyboardCaptureController controller;
  final KeyboardPicked onPicked;

  const KeyboardCapture({
    super.key,
    required this.controller,
    required this.onPicked,
  });

  @override
  State<KeyboardCapture> createState() => _KeyboardCaptureState();
}

class _KeyboardCaptureState extends State<KeyboardCapture> {
  @override
  void initState() {
    super.initState();
    _channel.setMethodCallHandler((call) async {
      if (call.method == 'onPicked') {
        final path = call.arguments as String;
        widget.onPicked(path);
      }
    });
  }

  @override
  Widget build(BuildContext context) => const SizedBox.shrink();

  @override
  void dispose() {
    _channel.setMethodCallHandler(null);
    super.dispose();
  }
}



===== FILE: src\ui\learning\tabs\chat\message_bubble.dart =====
import 'dart:io';
import 'dart:math' as math;
import 'package:flutter/material.dart';

import '../../models/message.dart';
import 'profile_avatar.dart';

class MessageBubble extends StatelessWidget {
  final Message message;
  final String time;
  final String? replyPreview;
  final String? imagePath;
  final Map<String, int>? reactions;
  final VoidCallback? onLongPress;
  final void Function(String emoji)? onReact;

  const MessageBubble({
    super.key,
    required this.message,
    required this.time,
    this.replyPreview,
    this.imagePath,
    this.reactions,
    this.onLongPress,
    this.onReact,
  });

  @override
  Widget build(BuildContext context) {
    final isMe = message.author == 'me';
    final isSystem = message.author == 'system';
    final theme = Theme.of(context);
    final maxW = math.min(MediaQuery.of(context).size.width * 0.78, 420.0);

    final bg = isSystem
        ? theme.colorScheme.tertiaryContainer.withOpacity(.6)
        : (isMe ? theme.colorScheme.primary : theme.colorScheme.surfaceContainerHighest);

    final textColor = isSystem
        ? theme.colorScheme.onTertiaryContainer
        : (isMe ? Colors.white : theme.colorScheme.onSurface);

    final bubble = ConstrainedBox(
      constraints: BoxConstraints(maxWidth: maxW),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
        decoration: BoxDecoration(
          color: bg,
          borderRadius: BorderRadius.circular(18),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (!isMe && !isSystem)
              Padding(
                padding: const EdgeInsets.only(bottom: 2),
                child: Text(
                  message.authorName,
                  style: TextStyle(
                    fontWeight: FontWeight.w700,
                    color: theme.colorScheme.primary,
                    fontSize: 12,
                  ),
                ),
              ),
            if (replyPreview != null && replyPreview!.isNotEmpty)
              Container(
                margin: const EdgeInsets.only(bottom: 6),
                padding: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: isMe ? Colors.black.withOpacity(.12) : Colors.black12,
                  borderRadius: BorderRadius.circular(12),
                  border: Border(left: BorderSide(color: textColor.withOpacity(.4), width: 3)),
                ),
                child: Text(
                  replyPreview!,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                  style: TextStyle(color: textColor.withOpacity(.85), fontStyle: FontStyle.italic),
                ),
              ),
            if (imagePath != null) ...[
              ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: ConstrainedBox(
                  constraints: BoxConstraints(maxWidth: maxW),
                  child: Image.file(File(imagePath!), fit: BoxFit.cover),
                ),
              ),
              if (message.text.isNotEmpty) const SizedBox(height: 6),
            ],
            Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              mainAxisSize: MainAxisSize.min,
              children: [
                Flexible(
                  child: Text(message.text, style: TextStyle(color: textColor, height: 1.24)),
                ),
                const SizedBox(width: 8),
                Text(time, style: TextStyle(color: textColor.withOpacity(.75), fontSize: 11)),
              ],
            ),
            if (reactions != null && reactions!.isNotEmpty) ...[
              const SizedBox(height: 6),
              Wrap(
                spacing: 6,
                runSpacing: 4,
                children: reactions!.entries
                    .map((e) => Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: Colors.black.withOpacity(isMe ? .15 : .08),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Text('${e.key} ${e.value}',
                              style: TextStyle(color: textColor, fontSize: 12)),
                        ))
                    .toList(),
              ),
            ],
          ],
        ),
      ),
    );

    return GestureDetector(
      onLongPress: onLongPress,
      child: Row(
        mainAxisAlignment: isMe ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (!isMe) ProfileAvatar(name: message.authorName, imageUrl: null),
          if (!isMe) const SizedBox(width: 8),
          Flexible(child: bubble),
          if (isMe) const SizedBox(width: 8),
          if (isMe) const ProfileAvatar(name: 'Р’С‹'),
        ],
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat\pinned_assignment_bar.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../state/team_cubit.dart';
import '../../models/assignment.dart';
import '../../assignment_details_screen.dart';

class PinnedAssignmentBar extends StatelessWidget {
  const PinnedAssignmentBar({super.key});

  @override
  Widget build(BuildContext context) {
    final st = context.watch<TeamCubit>().state;
    final pending = st.pending;
    final lastPublished = st.published.isNotEmpty ? st.published.last : null;
    final isDraft = pending != null;

    final title = isDraft ? pending!.title : (lastPublished?.title ?? '');
    final due = isDraft ? pending!.due : lastPublished?.due;

    final theme = Theme.of(context);
    final bg = isDraft ? Colors.amber.withOpacity(.15) : theme.colorScheme.primary.withOpacity(.12);
    final border = isDraft ? Colors.orangeAccent : theme.colorScheme.primary;

    return Container(
      margin: const EdgeInsets.fromLTRB(12, 12, 12, 6),
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: border.withOpacity(.6), width: .6),
      ),
      child: Row(
        children: [
          Icon(isDraft ? Icons.edit_note_outlined : Icons.push_pin_outlined, color: border),
          const SizedBox(width: 10),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(isDraft ? 'Р§РµСЂРЅРѕРІРёРє Р·Р°РґР°РЅРёСЏ' : 'Р—Р°РєСЂРµРїР»РµРЅРѕ: Р·Р°РґР°РЅРёРµ',
                    style: const TextStyle(fontWeight: FontWeight.w700)),
                const SizedBox(height: 4),
                Text(
                  title + (due != null ? ' (РґРѕ $due)' : ''),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
          TextButton(
            onPressed: () {
              final id = isDraft ? pending!.id : (lastPublished?.id ?? '');
              if (id.isEmpty) return;
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (_) => BlocProvider.value(
                    value: context.read<TeamCubit>(),
                    child: AssignmentDetailsScreen(assignmentId: id),
                  ),
                ),
              );
            },
            child: const Text('РћС‚РєСЂС‹С‚СЊ'),
          ),
        ],
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat\pinned_strip.dart =====
import 'package:flutter/material.dart';

enum PinType { text, message, assignment }

class PinEntry {
  final String id;
  final PinType type;
  final String title;
  final String? subtitle;
  final String? refId;
  final bool isAuto;

  const PinEntry._({
    required this.id,
    required this.type,
    required this.title,
    this.subtitle,
    this.refId,
    this.isAuto = false,
  });

  factory PinEntry.text({required String id, required String title}) =>
      PinEntry._(id: id, type: PinType.text, title: title);

  factory PinEntry.message({required String id, required String title, String? subtitle, required String messageId}) =>
      PinEntry._(id: id, type: PinType.message, title: title, subtitle: subtitle, refId: messageId);

  factory PinEntry.assignment({required String id, required String title, String? subtitle, required String assignmentId, bool isAuto = false}) =>
      PinEntry._(id: id, type: PinType.assignment, title: title, subtitle: subtitle, refId: assignmentId, isAuto: isAuto);

  IconData get icon => switch (type) {
        PinType.text => Icons.push_pin_outlined,
        PinType.message => Icons.chat_bubble_outline,
        PinType.assignment => Icons.assignment_outlined,
      };
}

class PinnedStrip extends StatelessWidget {
  final List<PinEntry> entries;
  final ValueChanged<PinEntry> onOpen;
  final ValueChanged<PinEntry> onUnpin;
  final VoidCallback onMore;

  const PinnedStrip({
    super.key,
    required this.entries,
    required this.onOpen,
    required this.onUnpin,
    required this.onMore,
  });

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Container(
      margin: const EdgeInsets.fromLTRB(12, 10, 12, 4),
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
      decoration: BoxDecoration(
        color: cs.surfaceContainerHigh,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: cs.outlineVariant.withOpacity(.6), width: .5),
      ),
      child: Row(
        children: [
          Icon(Icons.push_pin, size: 18, color: cs.primary),
          const SizedBox(width: 8),
          Expanded(
            child: SizedBox(
              height: 36,
              child: ListView.separated(
                scrollDirection: Axis.horizontal,
                itemCount: entries.length,
                separatorBuilder: (_, __) => const SizedBox(width: 8),
                itemBuilder: (_, i) => _ChipItem(
                  entry: entries[i],
                  onTap: () => onOpen(entries[i]),
                  onClose: () => onUnpin(entries[i]),
                ),
              ),
            ),
          ),
          const SizedBox(width: 4),
          InkWell(
            onTap: onMore,
            borderRadius: BorderRadius.circular(20),
            child: const Padding(
              padding: EdgeInsets.all(6),
              child: Icon(Icons.more_vert, size: 20),
            ),
          ),
        ],
      ),
    );
  }
}

class _ChipItem extends StatelessWidget {
  final PinEntry entry;
  final VoidCallback onTap;
  final VoidCallback onClose;
  const _ChipItem({required this.entry, required this.onTap, required this.onClose});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Material(
      color: cs.primary.withOpacity(.10),
      shape: const StadiumBorder(),
      child: InkWell(
        onTap: onTap,
        customBorder: const StadiumBorder(),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
          child: Row(
            children: [
              Icon(entry.icon, size: 16, color: cs.primary),
              const SizedBox(width: 6),
              ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 220),
                child: Text(
                  entry.subtitle != null ? '${entry.title}  вЂў  ${entry.subtitle}' : entry.title,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              if (!entry.isAuto) ...[
                const SizedBox(width: 6),
                GestureDetector(
                  onTap: onClose,
                  child: const Icon(Icons.close, size: 16),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat\plus_button.dart =====
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';

class PlusButton extends StatelessWidget {
  final void Function(String text)? onPinText;
  final Future<void> Function(
    String title,
    String description,
    String? link,
    String? due,
    List<Map<String, String>> attachments,
  )? onPropose;

  const PlusButton({super.key, this.onPinText, this.onPropose});

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.add_circle_outline),
      onPressed: () async {
        showModalBottomSheet(
          context: context,
          showDragHandle: true,
          builder: (_) => SafeArea(
            child: Wrap(
              children: [
                ListTile(
                  leading: const Icon(Icons.post_add_outlined),
                  title: const Text('РџСЂРµРґР»РѕР¶РёС‚СЊ Р·Р°РґР°РЅРёРµ'),
                  onTap: () async {
                    Navigator.pop(context);
                    final res = await _askAssignment(context);
                    if (res == null) return;
                    await onPropose?.call(res.$1, res.$2, res.$3, res.$4, res.$5);
                  },
                ),
                if (onPinText != null)
                  ListTile(
                    leading: const Icon(Icons.push_pin_outlined),
                    title: const Text('Р—Р°РєСЂРµРїРёС‚СЊ Р·Р°РјРµС‚РєСѓ'),
                    onTap: () async {
                      Navigator.pop(context);
                      final txt = await _askText(context);
                      if (txt != null && txt.trim().isNotEmpty) onPinText!(txt.trim());
                    },
                  ),
              ],
            ),
          ),
        );
      },
    );
  }

  Future<String?> _askText(BuildContext context) async {
    final c = TextEditingController();
    return showDialog<String>(
      context: context,
      builder: (_) => AlertDialog(
        title: const Center(child: Text('Р—Р°РєСЂРµРїРёС‚СЊ Р·Р°РјРµС‚РєСѓ', style: TextStyle(fontWeight: FontWeight.w700))),
        content: TextField(controller: c, maxLines: 3, decoration: const InputDecoration(hintText: 'РўРµРєСЃС‚ Р·Р°РјРµС‚РєРё')),
        actions: [
          TextButton(onPressed: () => Navigator.pop(context), child: const Text('РћС‚РјРµРЅР°')),
          FilledButton(onPressed: () => Navigator.pop(context, c.text), child: const Text('Р—Р°РєСЂРµРїРёС‚СЊ')),
        ],
      ),
    );
  }

  Future<(String, String, String?, String?, List<Map<String, String>>)?> _askAssignment(
      BuildContext context) async {
    final title = TextEditingController();
    final desc = TextEditingController();
    final link = TextEditingController();
    final due = TextEditingController();
    final List<Map<String, String>> files = [];

    return showDialog<(String, String, String?, String?, List<Map<String, String>>)>(
      context: context,
      builder: (_) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Center(
            child: Text('РќРѕРІРѕРµ Р·Р°РґР°РЅРёРµ', style: TextStyle(color: Colors.black, fontWeight: FontWeight.w700)),
          ),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(controller: title, decoration: const InputDecoration(labelText: 'РќР°Р·РІР°РЅРёРµ')),
                const SizedBox(height: 8),
                TextField(
                  controller: desc, minLines: 3, maxLines: 6,
                  decoration: const InputDecoration(labelText: 'Р§С‚Рѕ СЃРґРµР»Р°С‚СЊ'),
                ),
                const SizedBox(height: 8),
                TextField(controller: link, decoration: const InputDecoration(labelText: 'РЎСЃС‹Р»РєР° (РѕРїС†.)')),
                const SizedBox(height: 8),
                TextField(
                  controller: due,
                  readOnly: true,
                  decoration: InputDecoration(
                    labelText: 'РЎСЂРѕРє',
                    hintText: 'Р’С‹Р±РµСЂРёС‚Рµ РґР°С‚Сѓ',
                    suffixIcon: IconButton(
                      icon: const Icon(Icons.calendar_today_outlined),
                      onPressed: () async {
                        final now = DateTime.now();
                        final picked = await showDatePicker(
                          context: context,
                          firstDate: now,
                          lastDate: DateTime(now.year + 2),
                          initialDate: now,
                        );
                        if (picked != null) {
                          due.text =
                              '${picked.day.toString().padLeft(2, '0')}.${picked.month.toString().padLeft(2, '0')}';
                        }
                      },
                    ),
                  ),
                ),
                const SizedBox(height: 8),
                Align(
                  alignment: Alignment.centerLeft,
                  child: TextButton.icon(
                    onPressed: () async {
                      final res = await ImagePicker().pickImage(source: ImageSource.gallery);
                      if (res != null) {
                        setState(() => files.add({'name': res.name, 'path': res.path}));
                      }
                    },
                    icon: const Icon(Icons.attach_file),
                    label: const Text('Р’Р»РѕР¶РёС‚СЊ С„Р°Р№Р»/РёР·РѕР±СЂР°Р¶РµРЅРёРµ'),
                  ),
                ),
                for (final f in files)
                  ListTile(
                    dense: true,
                    leading: const Icon(Icons.insert_drive_file_outlined),
                    title: Text(f['name'] ?? ''),
                    subtitle: Text(f['path'] ?? ''),
                  ),
              ],
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context), child: const Text('РћС‚РјРµРЅР°')),
            FilledButton(
              onPressed: () {
                if (title.text.trim().isEmpty || desc.text.trim().isEmpty) return;
                Navigator.pop(
                  context,
                  (
                    title.text.trim(),
                    desc.text.trim(),
                    link.text.trim().isEmpty ? null : link.text.trim(),
                    due.text.trim().isEmpty ? null : due.text.trim(),
                    files,
                  ),
                );
              },
              child: const Text('Р”РѕР±Р°РІРёС‚СЊ'),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat\profile_avatar.dart =====
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

// РќРёС‡РµРіРѕ РЅРµ Р·РЅР°РµРј РїСЂРѕ С‚РІРѕСЋ РјРѕРґРµР»СЊ РїСЂРѕС„РёР»СЏ вЂ” С‡РёС‚Р°РµРј state РґРёРЅР°РјРёС‡РµСЃРєРё.
// Р•СЃР»Рё РЅРёС‡РµРіРѕ РЅРµС‚ вЂ” Р±СѓРґСѓС‚ РёРЅРёС†РёР°Р»С‹.
class ProfileAvatar extends StatelessWidget {
  final String name;       // РґР»СЏ РёРЅРёС†РёР°Р»РѕРІ
  final String? imageUrl;  // РµСЃР»Рё СѓР¶Рµ РµСЃС‚СЊ РіРѕС‚РѕРІС‹Р№ url вЂ” РёСЃРїРѕР»СЊР·СѓРµРј
  final double radius;

  const ProfileAvatar({
    super.key,
    required this.name,
    this.imageUrl,
    this.radius = 14,
  });

  @override
  Widget build(BuildContext context) {
    String? url = imageUrl;

    // РћСЃС‚РѕСЂРѕР¶РЅР°СЏ РїРѕРїС‹С‚РєР° РґРѕСЃС‚Р°С‚СЊ РјРѕСЋ Р°РІР°С‚Р°СЂРєСѓ РёР· Cubit.state (РґРёРЅР°РјРёС‡РµСЃРєРё).
    // Р Р°Р±РѕС‚Р°РµС‚, РґР°Р¶Рµ РµСЃР»Рё РїРѕР»РµР№ РЅРµС‚ вЂ” РїСЂРѕСЃС‚Рѕ РѕСЃС‚Р°РЅСѓС‚СЃСЏ РёРЅРёС†РёР°Р»С‹.
    if (url == null) {
      try {
        final cubit = context.read<dynamic>(); // РЅРµ СѓРєР°Р·С‹РІР°РµРј С‚РёРї
        final st = cubit.state;                // dynamic
        // РџСЂРѕР±СѓРµРј СЃР°РјС‹Рµ РѕС‡РµРІРёРґРЅС‹Рµ РјРµСЃС‚Р°:
        url = st?.profile?.avatarUrl ??
              st?.me?.avatarUrl ??
              st?.user?.avatarUrl;
      } catch (_) {}
    }

    Widget child;
    if (url is String && url.trim().isNotEmpty) {
      child = ClipOval(
        child: Image.network(url, width: radius * 2, height: radius * 2, fit: BoxFit.cover),
      );
    } else {
      final initials = _initials(name);
      child = CircleAvatar(
        radius: radius,
        child: Text(initials, style: const TextStyle(fontSize: 11)),
      );
    }
    return SizedBox(width: radius * 2, height: radius * 2, child: child);
  }

  String _initials(String name) {
    final parts = name.trim().split(RegExp(r'\s+'));
    if (parts.isEmpty) return 'U';
    final a = parts[0].isNotEmpty ? parts[0][0] : '';
    final b = parts.length > 1 && parts[1].isNotEmpty ? parts[1][0] : '';
    return (a + b).toUpperCase();
  }
}



===== FILE: src\ui\learning\tabs\chat\scroll_to_bottom_button.dart =====
import 'package:flutter/material.dart';

class ScrollToBottomButton extends StatelessWidget {
  final VoidCallback onTap;
  const ScrollToBottomButton({super.key, required this.onTap});

  @override
  Widget build(BuildContext context) {
    final bg = Theme.of(context).colorScheme.primary;
    return Material(
      color: bg,
      elevation: 2,
      shape: const CircleBorder(),
      child: InkWell(
        customBorder: const CircleBorder(),
        onTap: onTap,
        child: const Padding(
          padding: EdgeInsets.all(10),
          child: Icon(Icons.keyboard_arrow_down_rounded, color: Colors.white, size: 22),
        ),
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat\swipe_to_reply.dart =====
import 'package:flutter/material.dart';

class SwipeToReply extends StatefulWidget {
  final Widget child;
  final VoidCallback onReply;
  const SwipeToReply({super.key, required this.child, required this.onReply});

  @override
  State<SwipeToReply> createState() => _SwipeToReplyState();
}

class _SwipeToReplyState extends State<SwipeToReply> {
  double _dx = 0;
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onHorizontalDragUpdate: (d) {
        setState(() => _dx = (_dx + d.primaryDelta!).clamp(0, 80));
      },
      onHorizontalDragEnd: (_) {
        if (_dx > 48) widget.onReply();
        setState(() => _dx = 0);
      },
      child: Transform.translate(
        offset: Offset(_dx, 0),
        child: widget.child,
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat\typing_line.dart =====
import 'package:flutter/material.dart';

class TypingLine extends StatelessWidget {
  final List<String> names;
  const TypingLine({super.key, required this.names});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    final who = names.join(', ');
    return Padding(
      padding: const EdgeInsets.fromLTRB(12, 4, 12, 4),
      child: Row(
        children: [
          Icon(Icons.more_horiz, size: 16, color: cs.primary),
          const SizedBox(width: 6),
          Expanded(
            child: Text(
              '$who РїРµС‡Р°С‚Р°РµС‚вЂ¦',
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
              style: TextStyle(
                fontSize: 12,
                color: Theme.of(context).colorScheme.onSurface.withOpacity(.7),
              ),
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\chat_tab.dart =====
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart' as services;
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:image_picker/image_picker.dart';

import '../state/team_cubit.dart';
import '../models/message.dart';
import '../models/assignment.dart';
import '../assignment_details_screen.dart';

// РІРёРґР¶РµС‚С‹
import 'chat/composer.dart';
import 'chat/scroll_to_bottom_button.dart';
import 'chat/swipe_to_reply.dart';
import 'chat/message_bubble.dart';
import 'chat/assignment_bubble.dart';
import 'chat/plus_button.dart';
import 'chat/pinned_strip.dart';
import 'chat/typing_line.dart';

class ChatTab extends StatefulWidget {
  const ChatTab({super.key});
  @override
  State<ChatTab> createState() => _ChatTabState();
}

class _ChatTabState extends State<ChatTab> {
  final _ctrl = TextEditingController();
  final _scroll = ScrollController();
  final Map<String, Map<String, int>> _localReactions = {};
  final Map<String, GlobalKey> _messageKeys = {};

  bool _showJump = false;

  Message? _replyTo;
  String? _pickedImage;

  final List<PinEntry> _pins = [];
  bool _pinsHidden = false;
  bool _autoPinHidden = false;

  final Set<String> _typingUsers = {};
  Timer? _myTypingOff;
  bool get _someoneTyping => _typingUsers.isNotEmpty;

  final FocusNode _composerFocus = FocusNode();

  static const double _assignmentScale = 0.70;      // в€’30%
  static const double _assignmentTextBoost = 1.18;  // +18%

  // РљР°РЅР°Р»: РЅР°С‚РёРІ РїСЂРёСЃС‹Р»Р°РµС‚ РїСѓС‚СЊ Рє РІСЂРµРјРµРЅРЅРѕРјСѓ С„Р°Р№Р»Сѓ СЃ РєР»Р°РІРёР°С‚СѓСЂС‹ (GIF/СЃС‚РёРєРµСЂ/РєР°СЂС‚РёРЅРєР°)
  static const services.MethodChannel _keyboardChannel =
      services.MethodChannel('keyboard_image_channel');

  @override
  void initState() {
    super.initState();
    _scroll.addListener(_onScroll);
    _ctrl.addListener(_onMyTyping);

    // РџРѕРґРїРёСЃРєР° РЅР° СЃРѕР±С‹С‚РёСЏ РѕС‚ Android (MainActivity.kt)
    _keyboardChannel.setMethodCallHandler((call) async {
      if (call.method == 'onKeyboardImagePicked') {
        final path = (call.arguments ?? '') as String;
        if (path.isNotEmpty && mounted) {
          setState(() => _pickedImage = path);
        }
      }
      return null;
    });
  }

  @override
  void dispose() {
    _scroll.removeListener(_onScroll);
    _ctrl.removeListener(_onMyTyping);
    _scroll.dispose();
    _ctrl.dispose();
    _composerFocus.dispose();
    _myTypingOff?.cancel();
    super.dispose();
  }

  void _onScroll() {
    final show = _scroll.hasClients && _scroll.offset < _scroll.position.maxScrollExtent - 300;
    if (show != _showJump) setState(() => _showJump = show);
  }

  void _onMyTyping() {
    setState(() => _typingUsers.add('Р’С‹'));
    _myTypingOff?.cancel();
    _myTypingOff = Timer(const Duration(seconds: 2), () {
      if (!mounted) return;
      setState(() => _typingUsers.remove('Р’С‹'));
    });
  }

  String _time(DateTime dt) {
    final h = dt.hour.toString().padLeft(2, '0');
    final m = dt.minute.toString().padLeft(2, '0');
    return '$h:$m';
  }

  Future<void> _jumpToBottom() async {
    if (!_scroll.hasClients) return;
    await _scroll.animateTo(
      _scroll.position.maxScrollExtent,
      duration: const Duration(milliseconds: 220),
      curve: Curves.easeOut,
    );
  }

  Future<void> _scrollToMessage(String id) async {
    final ctx = _messageKeys[id]?.currentContext;
    if (ctx != null) {
      await Scrollable.ensureVisible(
        ctx,
        duration: const Duration(milliseconds: 280),
        alignment: .2,
        curve: Curves.easeOut,
      );
    }
  }

  List<PinEntry> _buildPins(TeamState st) {
    final manual = [..._pins];
    if (!_autoPinHidden) {
      final pending = st.pending;
      final published = st.published.isNotEmpty ? st.published.last : null;
      final a = pending ?? published;
      final alreadyHasManual = a != null && manual.any((p) => p.type == PinType.assignment && p.refId == a.id);
      if (a != null && !alreadyHasManual) {
        manual.insert(
          0,
          PinEntry.assignment(
            id: 'auto-${a.id}',
            title: a.title,
            subtitle: a.due != null ? 'РґРѕ ${a.due}' : null,
            assignmentId: a.id,
            isAuto: true,
          ),
        );
      }
    }
    return manual;
  }

  void _pinFromMessage(Message m) {
    if (m.text.trim().isEmpty) return;
    if (_pins.any((p) => p.type == PinType.message && p.refId == m.id)) return;
    setState(() {
      _pins.add(PinEntry.message(
        id: 'msg-${m.id}',
        title: m.text.trim().split('\n').first,
        subtitle: null,
        messageId: m.id,
      ));
      _pinsHidden = false;
    });
  }

  void _pinText(String text) {
    final t = text.trim();
    if (t.isEmpty) return;
    setState(() {
      _pins.add(PinEntry.text(
        id: 'txt-${DateTime.now().microsecondsSinceEpoch}',
        title: t,
      ));
      _pinsHidden = false;
    });
  }

  void _pinAssignment(Assignment a) {
    if (_pins.any((p) => p.type == PinType.assignment && p.refId == a.id && !p.isAuto)) return;
    setState(() {
      _pins.add(PinEntry.assignment(
        id: 'ass-${a.id}',
        title: a.title,
        subtitle: a.due != null ? 'РґРѕ ${a.due}' : null,
        assignmentId: a.id,
      ));
      _pinsHidden = false;
    });
  }

  void _addReaction(String msgId, String emoji) {
    setState(() {
      final map = _localReactions[msgId] ?? <String, int>{};
      map[emoji] = (map[emoji] ?? 0) + 1;
      _localReactions[msgId] = map;
    });
  }

  void _send(BuildContext context) {
    final text = _ctrl.text.trim();
    if (text.isEmpty && _pickedImage == null) return;

    final replyId = _replyTo?.id;
    _ctrl.clear();
    setState(() => _replyTo = null);

    context.read<TeamCubit>().sendMessage(
      'me',
      text,
      authorName: 'Р’С‹',
      imagePath: _pickedImage,
      replyToId: replyId,
    );
    setState(() => _pickedImage = null);

    WidgetsBinding.instance.addPostFrameCallback((_) => _jumpToBottom());
  }

  @override
  Widget build(BuildContext context) {
    final mq = MediaQuery.of(context);
    final scale = mq.textScaleFactor.clamp(1.0, 1.2);
    final themed = Theme.of(context);

    const listBottomPad = 96.0;

    return MediaQuery(
      data: mq.copyWith(textScaleFactor: scale),
      child: BlocBuilder<TeamCubit, TeamState>(
        builder: (context, state) {
          final list = state.chat;
          final pins = _buildPins(state);

          return Column(
            children: [
              if (!_pinsHidden && pins.isNotEmpty)
                PinnedStrip(
                  entries: pins,
                  onOpen: (p) async {
                    switch (p.type) {
                      case PinType.message:
                        await _scrollToMessage(p.refId!);
                        break;
                      case PinType.assignment:
                        Navigator.of(context).push(
                          MaterialPageRoute(
                            builder: (_) => BlocProvider.value(
                              value: context.read<TeamCubit>(),
                              child: AssignmentDetailsScreen(assignmentId: p.refId!),
                            ),
                          ),
                        );
                        break;
                      case PinType.text:
                        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(p.title)));
                        break;
                    }
                  },
                  onUnpin: (p) {
                    if (p.isAuto) {
                      setState(() => _autoPinHidden = true);
                    } else {
                      setState(() => _pins.removeWhere((e) => e.id == p.id));
                    }
                  },
                  onMore: () async {
                    await showModalBottomSheet(
                      context: context,
                      showDragHandle: true,
                      builder: (_) => SafeArea(
                        child: ListView(
                          shrinkWrap: true,
                          children: [
                            ListTile(
                              leading: const Icon(Icons.visibility_off_outlined),
                              title: const Text('РЎРєСЂС‹С‚СЊ Р»РµРЅС‚Сѓ'),
                              onTap: () {
                                Navigator.pop(context);
                                setState(() => _pinsHidden = true);
                              },
                            ),
                            if (!_autoPinHidden)
                              ListTile(
                                leading: const Icon(Icons.push_pin_outlined),
                                title: const Text('РЈР±СЂР°С‚СЊ Р°РІС‚Рѕ-Р·Р°РєСЂРµРї Р·Р°РґР°РЅРёСЏ'),
                                onTap: () {
                                  Navigator.pop(context);
                                  setState(() => _autoPinHidden = true);
                                },
                              ),
                            if (_pins.isNotEmpty) const Divider(height: 12),
                            ..._pins.map((p) => ListTile(
                                  leading: Icon(p.icon),
                                  title: Text(p.title, maxLines: 1, overflow: TextOverflow.ellipsis),
                                  subtitle: p.subtitle != null ? Text(p.subtitle!) : null,
                                  trailing: IconButton(
                                    icon: const Icon(Icons.close),
                                    onPressed: () => setState(() => _pins.removeWhere((e) => e.id == p.id)),
                                  ),
                                  onTap: () {
                                    Navigator.pop(context);
                                    if (p.type == PinType.message) _scrollToMessage(p.refId!);
                                    if (p.type == PinType.assignment) {
                                      Navigator.of(context).push(
                                        MaterialPageRoute(
                                          builder: (_) => BlocProvider.value(
                                            value: context.read<TeamCubit>(),
                                            child: AssignmentDetailsScreen(assignmentId: p.refId!),
                                          ),
                                        ),
                                      );
                                    }
                                  },
                                )),
                          ],
                        ),
                      ),
                    );
                  },
                ),

              Expanded(
                child: Stack(
                  children: [
                    ListView.builder(
                      controller: _scroll,
                      padding: const EdgeInsets.fromLTRB(12, 12, 12, listBottomPad),
                      itemCount: list.length,
                      itemBuilder: (context, i) {
                        final m = list[i];
                        final key = _messageKeys[m.id] ??= GlobalKey();

                        if (m.type == MessageType.assignmentDraft || m.type == MessageType.assignmentPublished) {
                          final boostedTs = (mq.textScaleFactor * _assignmentTextBoost).clamp(1.0, 1.6);
                          return KeyedSubtree(
                            key: key,
                            child: Padding(
                              padding: const EdgeInsets.only(bottom: 8),
                              child: Transform.scale(
                                scale: _assignmentScale,
                                alignment: Alignment.centerLeft,
                                child: MediaQuery(
                                  data: mq.copyWith(textScaleFactor: boostedTs),
                                  child: AssignmentBubble(
                                    message: m,
                                    isDraft: m.type == MessageType.assignmentDraft,
                                    time: _time(m.at),
                                    onOpen: () {
                                      final st = context.read<TeamCubit>().state;
                                      Assignment? a;
                                      final byId = st.assignments.where((e) => e.id == m.assignmentId);
                                      if (byId.isNotEmpty) a = byId.first; else if (st.published.isNotEmpty) a = st.published.last;
                                      if (a == null) return;
                                      Navigator.of(context).push(
                                        MaterialPageRoute(
                                          builder: (_) => BlocProvider.value(
                                            value: context.read<TeamCubit>(),
                                            child: AssignmentDetailsScreen(assignmentId: a!.id),
                                          ),
                                        ),
                                      );
                                    },
                                    onPublish: () => context.read<TeamCubit>().publishPendingManually(),
                                    onVote: () => context.read<TeamCubit>().voteForPending(),
                                    onLongPress: () => _showAssignmentActions(context, m),
                                    onPin: () {
                                      final st = context.read<TeamCubit>().state;
                                      final a = st.assignments.firstWhere(
                                        (e) => e.id == m.assignmentId,
                                        orElse: () => st.published.isNotEmpty ? st.published.last : st.assignments.first,
                                      );
                                      _pinAssignment(a);
                                    },
                                  ),
                                ),
                              ),
                            ),
                          );
                        }

                        final reply = m.replyToId != null
                            ? state.chat.firstWhere(
                                (x) => x.id == m.replyToId,
                                orElse: () => Message(
                                  id: '0',
                                  author: 'other',
                                  authorName: '',
                                  text: '',
                                  at: DateTime.now(),
                                ),
                              )
                            : null;

                        return KeyedSubtree(
                          key: key,
                          child: Padding(
                            padding: const EdgeInsets.only(bottom: 8),
                            child: SwipeToReply(
                              onReply: () => setState(() => _replyTo = m),
                              child: MessageBubble(
                                message: m,
                                time: _time(m.at),
                                replyPreview: reply?.text,
                                imagePath: m.imagePath,
                                reactions: _localReactions[m.id],
                                onReact: (emoji) => _addReaction(m.id, emoji),
                                onLongPress: () => _showMessageActions(context, m),
                              ),
                            ),
                          ),
                        );
                      },
                    ),

                    if (_showJump)
                      Positioned(
                        right: 12,
                        bottom: 82,
                        child: ScrollToBottomButton(onTap: _jumpToBottom),
                      ),
                  ],
                ),
              ),

              if (_replyTo != null)
                Container(
                  margin: const EdgeInsets.fromLTRB(12, 6, 12, 0),
                  padding: const EdgeInsets.all(10),
                  decoration: BoxDecoration(
                    color: themed.colorScheme.surface.withOpacity(.6),
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(color: themed.colorScheme.outline.withOpacity(.25)),
                  ),
                  child: Row(
                    children: [
                      const Icon(Icons.reply, size: 18),
                      const SizedBox(width: 8),
                      Expanded(child: Text(_replyTo!.text, maxLines: 2, overflow: TextOverflow.ellipsis)),
                      IconButton(icon: const Icon(Icons.close), onPressed: () => setState(() => _replyTo = null)),
                    ],
                  ),
                ),

              if (_someoneTyping) TypingLine(names: _typingUsers.toList()),

              // РїРѕР»Рµ РІРІРѕРґР°
              Composer(
                controller: _ctrl,
                focusNode: _composerFocus,
                pickedImagePath: _pickedImage,
                leftButton: PlusButton(
                  onPinText: _pinText,
                  onPropose: (title, description, link, due, attachments) async {
                    await context.read<TeamCubit>().proposeAssignment(
                      title: title, description: description, link: link, due: due, attachments: attachments,
                    );
                  },
                ),
                onPickImage: () async {
                  final res = await ImagePicker().pickImage(source: ImageSource.gallery);
                  if (res != null) setState(() => _pickedImage = res.path);
                },
                onClearPicked: () => setState(() => _pickedImage = null),

                // СЃРёСЃС‚РµРјРЅР°СЏ РєР»Р°РІРёР°С‚СѓСЂР° (СЌРјРѕРґР·Рё/СЃС‚РёРєРµСЂС‹/GIF)
                onOpenEmoji: () {
                  _composerFocus.requestFocus();
                  services.SystemChannels.textInput.invokeMethod('TextInput.show');
                },

                onSend: () => _send(context),
              ),
            ],
          );
        },
      ),
    );
  }

  void _showMessageActions(BuildContext context, Message m) {
    const quick = ['вќ¤пёЏ', 'рџ‚', 'рџ‘Ќ', 'рџ”Ґ', 'рџ‘Џ', 'рџ™Џ'];
    showModalBottomSheet(
      context: context,
      showDragHandle: true,
      builder: (_) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              child: Wrap(
                spacing: 10,
                children: quick
                    .map((e) => GestureDetector(
                          onTap: () {
                            Navigator.pop(context);
                            _addReaction(m.id, e);
                          },
                          child: Text(e, style: const TextStyle(fontSize: 28)),
                        ))
                    .toList(),
              ),
            ),
            const Divider(height: 0),
            ListTile(
              leading: const Icon(Icons.reply),
              title: const Text('РћС‚РІРµС‚РёС‚СЊ'),
              onTap: () {
                Navigator.pop(context);
                setState(() => _replyTo = m);
              },
            ),
            if (m.text.isNotEmpty)
              ListTile(
                leading: const Icon(Icons.copy_all_outlined),
                title: const Text('РљРѕРїРёСЂРѕРІР°С‚СЊ С‚РµРєСЃС‚'),
                onTap: () {
                  Navigator.pop(context);
                  services.Clipboard.setData(services.ClipboardData(text: m.text));
                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('РЎРєРѕРїРёСЂРѕРІР°РЅРѕ')));
                },
              ),
            if (m.text.isNotEmpty)
              ListTile(
                leading: const Icon(Icons.push_pin_outlined),
                title: const Text('Р—Р°РєСЂРµРїРёС‚СЊ'),
                onTap: () {
                  Navigator.pop(context);
                  _pinFromMessage(m);
                },
              ),
            if (m.author == 'me' && DateTime.now().difference(m.at) <= const Duration(hours: 2))
              ListTile(
                leading: const Icon(Icons.delete_outline),
                title: const Text('РЈРґР°Р»РёС‚СЊ СЃРѕРѕР±С‰РµРЅРёРµ'),
                onTap: () async {
                  Navigator.pop(context);
                  final ok = await showDialog<bool>(
                    context: context,
                    builder: (_) => AlertDialog(
                      title: const Text('РЈРґР°Р»РёС‚СЊ СЃРѕРѕР±С‰РµРЅРёРµ?'),
                      content: const Text('РњРѕР¶РЅРѕ СѓРґР°Р»РёС‚СЊ РІ С‚РµС‡РµРЅРёРµ 2 С‡Р°СЃРѕРІ РїРѕСЃР»Рµ РѕС‚РїСЂР°РІРєРё.'),
                      actions: [
                        TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('РћС‚РјРµРЅР°')),
                        FilledButton(onPressed: () => Navigator.pop(context, true), child: const Text('РЈРґР°Р»РёС‚СЊ')),
                      ],
                    ),
                  );
                  if (ok == true) {
                    context.read<TeamCubit>().removeMessage(m.id);
                  }
                },
              ),
          ],
        ),
      ),
    );
  }

  void _showAssignmentActions(BuildContext context, Message m) async {
    final st = context.read<TeamCubit>().state;
    final a = st.assignments.firstWhere(
      (e) => e.id == m.assignmentId,
      orElse: () => st.published.isNotEmpty ? st.published.last : st.assignments.first,
    );

    final canEdit = st.isStarosta || a.createdBy == 'me';

    showModalBottomSheet(
      context: context,
      showDragHandle: true,
      builder: (_) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.push_pin_outlined),
              title: const Text('Р—Р°РєСЂРµРїРёС‚СЊ'),
              onTap: () {
                Navigator.pop(context);
                _pinAssignment(a);
              },
            ),
            if (canEdit)
              ListTile(
                leading: const Icon(Icons.edit_outlined),
                title: const Text('Р РµРґР°РєС‚РёСЂРѕРІР°С‚СЊ Р·Р°РґР°РЅРёРµ'),
                onTap: () async {
                  Navigator.pop(context);
                  final res = await _editAssignmentDialog(context, a);
                  if (res == null) return;
                  await context.read<TeamCubit>().updateAssignment(
                        a.id,
                        title: res.$1,
                        description: res.$2,
                        link: res.$3,
                        due: res.$4,
                        attachments: res.$5,
                      );
                },
              ),
            if (canEdit)
              ListTile(
                leading: const Icon(Icons.delete_outline),
                title: const Text('РЈРґР°Р»РёС‚СЊ Р·Р°РґР°РЅРёРµ'),
                onTap: () async {
                  Navigator.pop(context);
                  await context.read<TeamCubit>().removeAssignment(a.id);
                },
              ),
          ],
        ),
      ),
    );
  }

  Future<(String, String, String?, String?, List<Map<String, String>>)?> _editAssignmentDialog(
      BuildContext context, Assignment a) async {
    final title = TextEditingController(text: a.title);
    final desc  = TextEditingController(text: a.description);
    final link  = TextEditingController(text: a.link ?? '');
    final due   = TextEditingController(text: a.due ?? '');
    final files = [...a.attachments];

    return showDialog<(String, String, String?, String?, List<Map<String, String>>)>(
      context: context,
      builder: (_) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Center(child: Text('Р РµРґР°РєС‚РёСЂРѕРІР°С‚СЊ Р·Р°РґР°РЅРёРµ', style: TextStyle(fontWeight: FontWeight.w700))),
          content: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(controller: title, decoration: const InputDecoration(labelText: 'РќР°Р·РІР°РЅРёРµ')),
                const SizedBox(height: 8),
                TextField(
                  controller: desc, minLines: 3, maxLines: 6,
                  decoration: const InputDecoration(labelText: 'Р§С‚Рѕ СЃРґРµР»Р°С‚СЊ'),
                ),
                const SizedBox(height: 8),
                TextField(controller: link, decoration: const InputDecoration(labelText: 'РЎСЃС‹Р»РєР° (РѕРїС†.)')),
                const SizedBox(height: 8),
                InkWell(
                  borderRadius: BorderRadius.circular(12),
                  onTap: () async {
                    final now = DateTime.now();
                    final picked = await showDatePicker(
                      context: context,
                      firstDate: now,
                      lastDate: now.add(const Duration(days: 365)),
                      initialDate: now,
                    );
                    if (picked != null) {
                      due.text = '${picked.day.toString().padLeft(2, '0')}.${picked.month.toString().padLeft(2, '0')}';
                      setState(() {});
                    }
                  },
                  child: InputDecorator(
                    decoration: const InputDecoration(labelText: 'РЎСЂРѕРє'),
                    child: Align(alignment: Alignment.centerLeft, child: Text(due.text.isEmpty ? 'РќРµ РІС‹Р±СЂР°РЅРѕ' : due.text)),
                  ),
                ),
                const SizedBox(height: 8),
                for (final f in files)
                  ListTile(
                    dense: true,
                    leading: const Icon(Icons.insert_drive_file_outlined),
                    title: Text(f['name'] ?? ''),
                    subtitle: Text(f['path'] ?? ''),
                  ),
              ],
            ),
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context), child: const Text('РћС‚РјРµРЅР°')),
            FilledButton(
              onPressed: () {
                if (title.text.trim().isEmpty || desc.text.trim().isEmpty) return;
                Navigator.pop(context, (
                  title.text.trim(),
                  desc.text.trim(),
                  link.text.trim().isEmpty ? null : link.text.trim(),
                  due.text.trim().isEmpty ? null : due.text.trim(),
                  files
                ));
              },
              child: const Text('РЎРѕС…СЂР°РЅРёС‚СЊ'),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\ui\learning\tabs\files_tab.dart =====
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:file_picker/file_picker.dart';
import 'package:open_filex/open_filex.dart';
import 'package:path_provider/path_provider.dart';
import '../models/file_item.dart';
import '../state/team_cubit.dart';
import 'assignments/assignments_tab.dart';


class FilesTab extends StatelessWidget {
  const FilesTab({super.key});

  Future<void> _pickAndSave(BuildContext context) async {
    final res = await FilePicker.platform.pickFiles(allowMultiple: false);
    if (res == null || res.files.single.path == null) return;
    final source = File(res.files.single.path!);

    final dir = await getApplicationDocumentsDirectory();
    final destPath = '${dir.path}/${res.files.single.name}';
    await source.copy(destPath);

    final state = context.read<TeamCubit>().state;
    final list = [...state.files, FileItem(id: DateTime.now().millisecondsSinceEpoch.toString(), name: res.files.single.name, path: destPath)];
    await context.read<TeamCubit>().setFiles(list);
  }

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<TeamCubit, TeamState>(
      builder: (context, state) {
        return Column(
          children: [
            SafeArea(
              bottom: false,
              child: Padding(
                padding: const EdgeInsets.all(12),
                child: Row(
                  children: [
                    ElevatedButton.icon(
                      onPressed: () => _pickAndSave(context),
                      icon: const Icon(Icons.upload_file),
                      label: const Text('Р—Р°РіСЂСѓР·РёС‚СЊ С„Р°Р№Р»'),
                    ),
                    const SizedBox(width: 12),
                    Text('Р¤Р°Р№Р»С‹ С…СЂР°РЅСЏС‚СЃСЏ Р»РѕРєР°Р»СЊРЅРѕ', style: TextStyle(color: Colors.grey.shade400)),
                  ],
                ),
              ),
            ),
            Expanded(
              child: ListView.separated(
                padding: const EdgeInsets.all(16),
                itemCount: state.files.length,
                separatorBuilder: (_, __) => const SizedBox(height: 8),
                itemBuilder: (_, i) {
                  final f = state.files[i];
                  return ListTile(
                    onTap: () => OpenFilex.open(f.path),
                    leading: const Icon(Icons.insert_drive_file_outlined),
                    title: Text(f.name, maxLines: 1, overflow: TextOverflow.ellipsis),
                    subtitle: Text(f.path, maxLines: 1, overflow: TextOverflow.ellipsis),
                    trailing: IconButton(
                      icon: const Icon(Icons.delete_outline),
                      onPressed: () {
                        final list = [...state.files]..removeAt(i);
                        context.read<TeamCubit>().setFiles(list);
                      },
                    ),
                  );
                },
              ),
            ),
          ],
        );
      },
    );
  }
}



===== FILE: src\ui\learning\team_details_screen.dart =====
import 'tabs/assignments_tab.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'models/team.dart';
import 'state/team_cubit.dart';
import 'tabs/chat_tab.dart';
import 'tabs/files_tab.dart';

// РѕР±С‰РёР№ notifier РґР»СЏ РїРµСЂРµРєР»СЋС‡РµРЅРёСЏ
import 'tabs/assignments/view_mode.dart';

class TeamDetailsScreen extends StatelessWidget {
  final Team team;
  const TeamDetailsScreen({super.key, required this.team});

  @override
  Widget build(BuildContext context) {
    return BlocProvider<TeamCubit>(
      create: (_) => TeamCubit(team)..init(),
      child: const _Body(),
    );
  }
}

class _Body extends StatelessWidget {
  const _Body({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<TeamCubit, TeamState>(
      builder: (context, state) {
        final tabs = <Tab>[
          const Tab(text: 'Р—Р°РґР°РЅРёСЏ'),
          const Tab(text: 'Р§Р°С‚'),
          const Tab(text: 'Р¤Р°Р№Р»С‹'),
        ];
        final views = <Widget>[
          AssignmentsTab(team: state.team),
          const ChatTab(),
          const FilesTab(),
        ];

        return DefaultTabController(
          length: tabs.length,
          child: Builder(
            builder: (context) {
              final ctrl = DefaultTabController.of(context)!;
              // AnimatedBuilder РѕР±РµСЃРїРµС‡РёС‚ РїРµСЂРµСЃС‚СЂРѕР№РєСѓ AppBar РїСЂРё СЃРјРµРЅРµ РІРєР»Р°РґРєРё
              return AnimatedBuilder(
                animation: ctrl.animation!,
                builder: (context, _) {
                  final onAssignments = ctrl.index == 0;
                  return Scaffold(
                    appBar: AppBar(
                      title: Text(
                        state.team.name,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                      bottom: TabBar(tabs: tabs),
                      actions: [
                        if (onAssignments) const AssignmentsViewToggleAction(),
                      ],
                    ),
                    body: TabBarView(children: views),
                  );
                },
              );
            },
          ),
        );
      },
    );
  }
}

/// РљРЅРѕРїРєР° РІ AppBar: В«СЃРїРёСЃРѕРє в†” СЃРµС‚РєР°В»
class AssignmentsViewToggleAction extends StatelessWidget {
  const AssignmentsViewToggleAction({super.key});

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<bool>(
      valueListenable: AssignmentsViewMode.grid,
      builder: (_, asGrid, __) => IconButton(
        tooltip: asGrid ? 'РџРѕРєР°Р·Р°С‚СЊ СЃРїРёСЃРєРѕРј' : 'РџРѕРєР°Р·Р°С‚СЊ СЃРµС‚РєРѕР№',
        iconSize: 22,
        icon: Icon(asGrid ? Icons.view_agenda_outlined : Icons.grid_view_rounded),
        onPressed: () => AssignmentsViewMode.grid.value = !asGrid,
      ),
    );
  }
}



===== FILE: src\ui\navigation\navigation_screen.dart =====
import 'package:flutter/material.dart';

// РРјРїРѕСЂС‚С‹ РїРѕ С‚РµРєСѓС‰РµР№ СЃС‚СЂСѓРєС‚СѓСЂРµ
import '../home/home_screen.dart';
import '../info/info_screen.dart';
import '../learning/learning_screen.dart';
import '../schedule/schedule_screen.dart';
import '../profile/profile_screen.dart';

class NavigationScreen extends StatefulWidget {
  const NavigationScreen({super.key});

  @override
  State<NavigationScreen> createState() => _NavigationScreenState();
}

class _NavigationScreenState extends State<NavigationScreen> {
  int _currentIndex = 0;
  final PageStorageBucket _bucket = PageStorageBucket();

  late final List<Widget> _tabs = <Widget>[
    const _KeepAlive(storageKey: 'tab_home', child: HomeScreen()),
    const _KeepAlive(storageKey: 'tab_info', child: InfoScreen()),
    const _KeepAlive(storageKey: 'tab_learning', child: LearningScreen()),
    const _KeepAlive(storageKey: 'tab_schedule', child: ScheduleScreen()),
    const _KeepAlive(storageKey: 'tab_profile', child: ProfileScreen()),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: PageStorage(
        bucket: _bucket,
        child: IndexedStack(
          index: _currentIndex,
          children: _tabs,
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        type: BottomNavigationBarType.fixed,
        currentIndex: _currentIndex,
        onTap: (index) => setState(() => _currentIndex = index),
        selectedItemColor: Colors.blue,
        unselectedItemColor: Colors.grey,
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Р“Р»Р°РІРЅР°СЏ'),
          BottomNavigationBarItem(icon: Icon(Icons.info_outline), label: 'РџРѕР»РµР·РЅР°СЏ'),
          BottomNavigationBarItem(icon: Icon(Icons.menu_book), label: 'РћР±СѓС‡РµРЅРёРµ'),
          BottomNavigationBarItem(icon: Icon(Icons.calendar_today), label: 'Р Р°СЃРїРёСЃР°РЅРёРµ'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'РџСЂРѕС„РёР»СЊ'),
        ],
      ),
    );
  }
}

/// РћР±С‘СЂС‚РєР°, РєРѕС‚РѕСЂР°СЏ:
/// 1) РІРєР»СЋС‡Р°РµС‚ keep-alive (РЅРµ dispose'РёС‚ РІРёРґР¶РµС‚ РїСЂРё СЃРјРµРЅРµ РІРєР»Р°РґРєРё),
/// 2) РґР°С‘С‚ СЃС‚Р°Р±РёР»СЊРЅС‹Р№ PageStorageKey РґР»СЏ СЃРѕС…СЂР°РЅРµРЅРёСЏ СЃРєСЂРѕР»Р»РѕРІ Рё С‚.Рї.
class _KeepAlive extends StatefulWidget {
  final Widget child;
  final String storageKey;
  const _KeepAlive({super.key, required this.child, required this.storageKey});

  @override
  State<_KeepAlive> createState() => _KeepAliveState();
}

class _KeepAliveState extends State<_KeepAlive>
    with AutomaticKeepAliveClientMixin<_KeepAlive> {
  @override
  bool get wantKeepAlive => true;

  @override
  Widget build(BuildContext context) {
    super.build(context);
    return KeyedSubtree(
      key: PageStorageKey(widget.storageKey),
      child: widget.child,
    );
  }
}



===== FILE: src\ui\profile\edit_profile_screen.dart =====
import 'dart:convert';
import 'dart:io';

import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:image_picker/image_picker.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class EditProfileScreen extends StatefulWidget {
  const EditProfileScreen({super.key});

  @override
  State<EditProfileScreen> createState() => _EditProfileScreenState();
}

class _EditProfileScreenState extends State<EditProfileScreen> {
  final _formKey = GlobalKey<FormState>();

  final _firstName = TextEditingController();
  final _lastName = TextEditingController();
  final _university = TextEditingController();
  final _group = TextEditingController();

  final List<String> _statuses = const [
    'РћРЅР»Р°Р№РЅ',
    'Р—Р°РЅСЏС‚ рџљ«',
    'РќР° РїР°СЂРµ',
    'Р’ Р±РёР±Р»РёРѕС‚РµРєРµ',
    'Р“РѕС‚РѕРІР»СЋСЃСЊ Рє СЃРµСЃСЃРёРё рџ’Є',
    'РћС‚РѕС€С‘Р»',
  ];
  String _status = 'РћРЅР»Р°Р№РЅ';

  String? _avatarPath; // Р»РѕРєР°Р»СЊРЅС‹Р№ РїСЂРµРІСЊСЋ
  String? _avatarUrl;  // url РёР· Р‘Р”

  bool _saving = false;
  Map<String, dynamic>? _user;

  final _sb = Supabase.instance.client;

  @override
  void initState() {
    super.initState();
    _bootstrap();
  }

  Future<void> _bootstrap() async {
    final prefs = await SharedPreferences.getInstance();
    final userJson = prefs.getString('user');
    if (userJson != null) {
      _user = jsonDecode(userJson) as Map<String, dynamic>;
      _firstName.text  = (_user?['name'] ?? '') as String;
      _lastName.text   = (_user?['surname'] ?? '') as String;
      _university.text = (_user?['university'] ?? '') as String;
      _group.text      = (_user?['group_name'] ?? '') as String;
      final st = (_user?['status'] ?? '') as String;
      if (st.isNotEmpty) _status = st;
      _avatarUrl = (_user?['avatar_url'] as String?)?.trim();
      setState(() {});
    }
  }

  @override
  void dispose() {
    _firstName.dispose();
    _lastName.dispose();
    _university.dispose();
    _group.dispose();
    super.dispose();
  }

  /// Р—Р°РіСЂСѓР·РєР° РІ `<uid>/<fileName>.jpg`. Р­С‚Рѕ РєСЂРёС‚РёС‡РЅРѕ РґР»СЏ RLS.
  Future<void> _pickAvatar() async {
    final picker = ImagePicker();
    final picked = await picker.pickImage(source: ImageSource.gallery, imageQuality: 85);
    if (picked == null || _user == null) return;

    setState(() => _avatarPath = picked.path);

    try {
      final id = _user!['id'] as String; // auth.uid()
      final bytes = await File(picked.path).readAsBytes();
      final fileName = 'avatar_${DateTime.now().millisecondsSinceEpoch}.jpg';
      final path = '$id/$fileName'; // <вЂ” Р’РђР–РќРћ: РїР°РїРєР° РїРѕР»СЊР·РѕРІР°С‚РµР»СЏ

      await _sb.storage.from('avatars').uploadBinary(
        path,
        bytes,
        fileOptions: const FileOptions(
          upsert: true,
          contentType: 'image/jpeg',
        ),
      );

      final publicUrl = _sb.storage.from('avatars').getPublicUrl(path);

      await _sb.from('users').update({'avatar_url': publicUrl}).eq('id', id);

      final prefs = await SharedPreferences.getInstance();
      final u = Map<String, dynamic>.from(_user!);
      u['avatar_url'] = publicUrl;
      _user = u;
      _avatarUrl = publicUrl;
      await prefs.setString('user', jsonEncode(u));

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('РђРІР°С‚Р°СЂ РѕР±РЅРѕРІР»С‘РЅ')),
      );
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('РћС€РёР±РєР° Р·Р°РіСЂСѓР·РєРё Р°РІР°С‚Р°СЂР°: $e')),
      );
    }
  }

  Future<void> _save() async {
    // СЃРµР№С‡Р°СЃ РїРѕР»СЏ С‚РѕР»СЊРєРѕ РґР»СЏ С‡С‚РµРЅРёСЏ вЂ” РїРѕ РєРЅРѕРїРєРµ РїСЂРѕСЃС‚Рѕ РІС‹С…РѕРґРёРј
    if (!mounted) return;
    context.pop();
  }

  Future<void> _setStatus(String newStatus) async {
    if (_user == null) return;
    setState(() => _status = newStatus);
    try {
      final id = _user!['id'] as String;
      await _sb.from('users').update({'status': newStatus}).eq('id', id);

      final prefs = await SharedPreferences.getInstance();
      final u = Map<String, dynamic>.from(_user!);
      u['status'] = newStatus;
      _user = u;
      await prefs.setString('user', jsonEncode(u));
    } catch (_) {}
  }

  /// РљСЂР°СЃРёРІР°СЏ СЃРјРµРЅР° РїР°СЂРѕР»СЏ: РґРІР° РїРѕР»СЏ, Р±РµР· BCrypt.
  Future<void> _changePasswordDialog() async {
    final newCtrl = TextEditingController();
    final confirmCtrl = TextEditingController();

    await showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('РЎРјРµРЅР° РїР°СЂРѕР»СЏ'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: newCtrl,
              obscureText: true,
              decoration: const InputDecoration(labelText: 'РќРѕРІС‹Р№ РїР°СЂРѕР»СЊ'),
            ),
            TextField(
              controller: confirmCtrl,
              obscureText: true,
              decoration: const InputDecoration(labelText: 'РџРѕРІС‚РѕСЂРёС‚Рµ РїР°СЂРѕР»СЊ'),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('РћС‚РјРµРЅР°'),
          ),
          FilledButton(
            onPressed: () async {
              final a = newCtrl.text.trim();
              final b = confirmCtrl.text.trim();

              if (a.length < 6) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('РњРёРЅРёРјСѓРј 6 СЃРёРјРІРѕР»РѕРІ')),
                  );
                }
                return;
              }
              if (a != b) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('РџР°СЂРѕР»Рё РЅРµ СЃРѕРІРїР°РґР°СЋС‚')),
                  );
                }
                return;
              }

              try {
                await _sb.auth.updateUser(UserAttributes(password: a));
                if (mounted) {
                  Navigator.of(ctx).pop();
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('РџР°СЂРѕР»СЊ РёР·РјРµРЅС‘РЅ')),
                  );
                }
              } on AuthException catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text(e.message)),
                  );
                }
              } catch (e) {
                if (mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('РћС€РёР±РєР°: $e')),
                  );
                }
              }
            },
            child: const Text('РЎРѕС…СЂР°РЅРёС‚СЊ'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final text = Theme.of(context).textTheme;

    ImageProvider? avatarProvider;
    if (_avatarPath != null) {
      avatarProvider = FileImage(File(_avatarPath!));
    } else if (_avatarUrl != null && _avatarUrl!.isNotEmpty) {
      avatarProvider = CachedNetworkImageProvider(_avatarUrl!);
    }

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_ios_new_rounded),
          onPressed: () => context.pop(),
        ),
        title: const Text('Р РµРґР°РєС‚РёСЂРѕРІР°С‚СЊ РїСЂРѕС„РёР»СЊ'),
        centerTitle: true,
        actions: [
          TextButton(
            onPressed: _saving ? null : _save,
            child: _saving
                ? const SizedBox(
                    width: 16, height: 16, child: CircularProgressIndicator(strokeWidth: 2))
                : const Text('Р“РѕС‚РѕРІРѕ'),
          ),
        ],
      ),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.fromLTRB(16, 12, 16, 24),
          children: [
            // ==== AVATAR ====
            Center(
              child: Stack(
                children: [
                  Container(
                    width: 120,
                    height: 120,
                    decoration: const BoxDecoration(
                      shape: BoxShape.circle,
                      gradient: LinearGradient(
                        colors: [Color(0xFF8EC5FC), Color(0xFFE0C3FC)],
                        begin: Alignment.topLeft,
                        end: Alignment.bottomRight,
                      ),
                    ),
                    child: Center(
                      child: CircleAvatar(
                        radius: 54,
                        backgroundColor: Colors.white,
                        backgroundImage: avatarProvider,
                        child: avatarProvider == null
                            ? const Icon(Icons.person, size: 44, color: Colors.black54)
                            : null,
                      ),
                    ),
                  ),
                  Positioned(
                    right: 0,
                    bottom: 0,
                    child: GestureDetector(
                      onTap: _pickAvatar,
                      child: Container(
                        width: 40,
                        height: 40,
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.primary,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: Theme.of(context).colorScheme.primary.withOpacity(.35),
                              blurRadius: 10,
                              offset: const Offset(0, 6),
                            ),
                          ],
                        ),
                        child: const Icon(Icons.edit, color: Colors.white, size: 20),
                      ),
                    ),
                  ),
                ],
              ),
            ),

            const SizedBox(height: 20),

            // ==== READ-ONLY FIELDS ====
            _LabeledField(label: 'РРјСЏ',         hint: 'Р’РІРµРґРёС‚Рµ РёРјСЏ',         controller: _firstName,   readOnly: true),
            _Divider(),
            _LabeledField(label: 'Р¤Р°РјРёР»РёСЏ',     hint: 'Р’РІРµРґРёС‚Рµ С„Р°РјРёР»РёСЋ',     controller: _lastName,    readOnly: true),
            _Divider(),
            _LabeledField(label: 'РЈРЅРёРІРµСЂСЃРёС‚РµС‚', hint: 'РќР°РїСЂРёРјРµСЂ: РЎРџР±Р“РђРЎРЈ',   controller: _university,  readOnly: true),
            _Divider(),
            _LabeledField(label: 'Р“СЂСѓРїРїР°/РєСѓСЂСЃ', hint: 'РќР°РїСЂРёРјРµСЂ: 1-РЎРј(Р’Р’)-2',controller: _group,       readOnly: true),

            const SizedBox(height: 12),

            // ==== STATUS CHIPS ====
            Text('РЎС‚Р°С‚СѓСЃ',
                style: text.labelMedium?.copyWith(color: Colors.black54, fontWeight: FontWeight.w600)),
            const SizedBox(height: 8),
            Wrap(
              spacing: 8,
              runSpacing: -4,
              children: _statuses.map((s) {
                final selected = _status == s;
                return ChoiceChip(
                  label: Text(s),
                  selected: selected,
                  onSelected: (_) => _setStatus(s),
                  labelStyle: TextStyle(
                    color: selected ? Colors.white : Colors.black87,
                    fontWeight: FontWeight.w600,
                  ),
                  selectedColor: Theme.of(context).colorScheme.primary,
                  backgroundColor: Colors.grey.shade200,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                );
              }).toList(),
            ),

            const SizedBox(height: 28),

            // ==== PASSWORD ====
            ListTile(
              contentPadding: EdgeInsets.zero,
              leading: const Icon(Icons.lock_outline),
              title: const Text('РЎРјРµРЅРёС‚СЊ РїР°СЂРѕР»СЊ'),
              subtitle: const Text('Р”РІР° РїРѕР»СЏ: РЅРѕРІС‹Р№ Рё РїРѕРІС‚РѕСЂ'),
              trailing: const Icon(Icons.chevron_right),
              onTap: _changePasswordDialog,
            ),
          ],
        ),
      ),
    );
  }
}

class _LabeledField extends StatelessWidget {
  final String label;
  final String hint;
  final TextEditingController controller;
  final bool readOnly;
  final int maxLines;
  final TextInputType? keyboardType;

  const _LabeledField({
    required this.label,
    required this.hint,
    required this.controller,
    this.readOnly = false,
    this.maxLines = 1,
    this.keyboardType,
  });

  @override
  Widget build(BuildContext context) {
    final labelStyle = Theme.of(context)
        .textTheme
        .labelMedium
        ?.copyWith(color: Colors.black54, fontWeight: FontWeight.w600);

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: TextFormField(
        controller: controller,
        readOnly: readOnly,
        enableInteractiveSelection: true,
        keyboardType: keyboardType,
        maxLines: maxLines,
        decoration: InputDecoration(
          labelText: label,
          labelStyle: labelStyle,
          hintText: hint,
          border: InputBorder.none,
          contentPadding: const EdgeInsets.symmetric(horizontal: 4, vertical: 8),
        ),
      ),
    );
  }
}

class _Divider extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return const Divider(height: 1, thickness: 1, color: Colors.black12);
  }
}



===== FILE: src\ui\profile\profile_repository.dart =====
import 'dart:io';
import 'package:supabase_flutter/supabase_flutter.dart';

class ProfileRepository {
  final _sb = Supabase.instance.client;

  Future<Map<String, dynamic>?> fetchMyProfile() async {
    final uid = _sb.auth.currentUser?.id;
    if (uid == null) return null;
    return await _sb
        .from('users')
        .select<Map<String, dynamic>>()
        .eq('id', uid)
        .maybeSingle();
  }

  Future<void> updateProfile({
    required String name,
    required String surname,
    required String university,
    required String groupName,
    String? status,
  }) async {
    final uid = _sb.auth.currentUser!.id;
    await _sb.from('users').update({
      'name': name,
      'surname': surname,
      'university': university,
      'group_name': groupName,
      if (status != null) 'status': status,
    }).eq('id', uid);
  }

  /// РљР»Р°РґС‘Рј РІ `<uid>/<filename>.jpg`
  Future<String?> uploadAvatar(File file) async {
    final uid = _sb.auth.currentUser!.id;
    final fileName = 'avatar_${DateTime.now().millisecondsSinceEpoch}.jpg';
    final path = '$uid/$fileName';

    await _sb.storage.from('avatars').upload(
      path,
      file,
      fileOptions: const FileOptions(upsert: true, contentType: 'image/jpeg'),
    );

    final publicUrl = _sb.storage.from('avatars').getPublicUrl(path);
    await _sb.from('users').update({'avatar_url': publicUrl}).eq('id', uid);
    return publicUrl;
  }
}



===== FILE: src\ui\profile\profile_screen.dart =====
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:url_launcher/url_launcher.dart';

class ProfileScreen extends StatefulWidget {
  const ProfileScreen({super.key});

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  Map<String, dynamic>? _user;
  bool _loading = true;

  final _sb = Supabase.instance.client;
  RealtimeChannel? _channel; // РґР»СЏ live-РѕР±РЅРѕРІР»РµРЅРёР№

  @override
  void initState() {
    super.initState();
    _loadLocal();
  }

  @override
  void dispose() {
    _channel?.unsubscribe();
    super.dispose();
  }

  Future<void> _loadLocal() async {
    final prefs = await SharedPreferences.getInstance();
    final userJson = prefs.getString('user');
    if (userJson != null) {
      _user = jsonDecode(userJson) as Map<String, dynamic>;
      _subscribeStatus(); // СЃР»СѓС€Р°РµРј РёР·РјРµРЅРµРЅРёСЏ РІ Р‘Р”
    }
    setState(() => _loading = false);
  }

  void _subscribeStatus() {
    if (_user == null) return;
    final id = _user!['id'] as String?;
    if (id == null) return;

    // РќР° РІСЃСЏРєРёР№ СЃР»СѓС‡Р°Р№ РѕС‚РїРёСЃРєР°, РµСЃР»Рё СѓР¶Рµ РїРѕРґРїРёСЃР°РЅС‹
    _channel?.unsubscribe();

    _channel = _sb
        .channel('public:users')
        .onPostgresChanges(
          event: PostgresChangeEvent.update,
          schema: 'public',
          table: 'users',
          filter: PostgresChangeFilter(
            type: PostgresChangeFilterType.eq,
            column: 'id',
            value: id,
          ),
          callback: (payload) async {
            final newRec = payload.newRecord;
            if (newRec == null) return;

            final newStatus = (newRec['status'] ?? '') as String;
            final newAvatar = (newRec['avatar_url'] ?? '') as String;

            setState(() {
              if (_user != null) {
                _user!['status'] = newStatus;
                _user!['avatar_url'] = newAvatar;
              }
            });

            final prefs = await SharedPreferences.getInstance();
            final u = Map<String, dynamic>.from(_user!);
            u['status'] = newStatus;
            u['avatar_url'] = newAvatar;
            _user = u;
            await prefs.setString('user', jsonEncode(u));
          },
        )
        .subscribe();
  }

  Future<void> _refreshFromServer() async {
    if (_user == null) return;
    final id = _user!['id'] as String?;
    if (id == null) return;

    final fresh = await _sb
        .from('users')
        .select(
          'id, login, name, surname, university, group_name, avatar_url, status',
        )
        .eq('id', id)
        .maybeSingle();

    if (fresh != null) {
      final mapFresh = Map<String, dynamic>.from(fresh as Map);
      _user = mapFresh;
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('user', jsonEncode(mapFresh));
      setState(() {});
    }
  }

  Future<void> _logout() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('loggedIn');
    await prefs.remove('user');
    if (!mounted) return;
    context.go('/login');
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) {
      return Scaffold(
        appBar: AppBar(title: const Text('РџСЂРѕС„РёР»СЊ'), centerTitle: true),
        body: const Center(child: CircularProgressIndicator()),
      );
    }

    final u = _user;
    final first = (u?['name'] ?? '') as String;
    final last = (u?['surname'] ?? '') as String;
    final uni = (u?['university'] ?? '') as String;
    final group = (u?['group_name'] ?? '') as String;
    final status = (u?['status'] ?? '') as String;
    final avatar = (u?['avatar_url'] as String?)?.trim();

    final fullName = [first, last].where((s) => s.isNotEmpty).join(' ').trim();

    return Scaffold(
      appBar: AppBar(
        title: const Text('РџСЂРѕС„РёР»СЊ'),
        centerTitle: true,
        leading: IconButton(
          tooltip: 'Р РµРґР°РєС‚РёСЂРѕРІР°С‚СЊ',
          icon: const Icon(Icons.tune),
          onPressed: () async {
            await context.push('/edit-profile');
            // РїРѕСЃР»Рµ РІРѕР·РІСЂР°С‚Р°: РїРѕРґС‚СЏРЅРµРј Р»РѕРєР°Р»СЊРЅС‹Р№ РєСЌС€ (РѕРЅ СѓР¶Рµ РѕР±РЅРѕРІР»С‘РЅ РІ Edit)
            await _loadLocal();
          },
        ),
        actions: [
          IconButton(
            tooltip: 'РћР±РЅРѕРІРёС‚СЊ',
            icon: const Icon(Icons.refresh),
            onPressed: _refreshFromServer,
          ),
          IconButton(
            tooltip: 'Р’С‹Р№С‚Рё',
            icon: const Icon(Icons.logout),
            onPressed: _logout,
          ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: _refreshFromServer,
        child: ListView(
          padding: const EdgeInsets.fromLTRB(16, 12, 16, 24),
          children: [
            _Header(
              fullName: fullName.isEmpty ? 'Р‘РµР· РёРјРµРЅРё' : fullName,
              university: uni,
              groupName: group,
              status: status,
              avatarUrl: avatar,
            ),
            const SizedBox(height: 16),
            _MetricsRow(messages: '0', rating: '957', friends: '0'),
            const SizedBox(height: 20),

            const _SectionTitle('Р›РµРЅС‚Р°'),
            const SizedBox(height: 10),
            _FeedCarousel(
              items: _demoFeed,
              onTapItem: (item) => _openFeedItem(context, item),
            ),

            const SizedBox(height: 20),
            const _SectionTitle('РЈС‡С‘Р±Р°'),
            const SizedBox(height: 10),
            _ExamsBanner(onTap: () => context.push('/exams')),
          ],
        ),
      ),
    );
  }

  Future<void> _openFeedItem(BuildContext context, FeedItem item) async {
    if (item.url != null) {
      final uri = Uri.parse(item.url!);
      final ok = await launchUrl(uri, mode: LaunchMode.externalApplication);
      if (!ok && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('РќРµ СѓРґР°Р»РѕСЃСЊ РѕС‚РєСЂС‹С‚СЊ: ${item.url}')),
        );
      }
      return;
    }
    if (item.route != null) {
      if (context.mounted) context.push(item.route!);
      return;
    }
    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Р­Р»РµРјРµРЅС‚: ${item.title}')),
      );
    }
  }
}

// =================== HEADER ===================

class _Header extends StatelessWidget {
  final String fullName;
  final String university;
  final String groupName;
  final String status;
  final String? avatarUrl;

  const _Header({
    required this.fullName,
    required this.university,
    required this.groupName,
    required this.status,
    required this.avatarUrl,
  });

  @override
  Widget build(BuildContext context) {
    final text = Theme.of(context).textTheme;

    ImageProvider? avatarProvider;
    if (avatarUrl != null && avatarUrl!.isNotEmpty) {
      avatarProvider = NetworkImage(avatarUrl!);
    }

    return Column(
      children: [
        CircleAvatar(
          radius: 44,
          backgroundColor: Colors.deepPurple.shade100,
          backgroundImage: avatarProvider,
          child: avatarProvider == null
              ? const Icon(Icons.person, size: 44)
              : null,
        ),
        const SizedBox(height: 12),
        Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              fullName,
              style: text.titleLarge?.copyWith(
                fontWeight: FontWeight.w800,
                color: Colors.black,
              ),
            ),
            const SizedBox(width: 6),
            const Icon(Icons.verified, size: 18, color: Colors.deepPurple),
          ],
        ),
        const SizedBox(height: 4),
        Text(
          university.isEmpty && groupName.isEmpty
              ? 'Р”Р°РЅРЅС‹Рµ РїСЂРѕС„РёР»СЏ РЅРµ Р·Р°РїРѕР»РЅРµРЅС‹'
              : [
                  if (university.isNotEmpty) university,
                  if (groupName.isNotEmpty) 'РіСЂСѓРїРїР° $groupName',
                ].join(', '),
          style: text.bodyMedium?.copyWith(color: Colors.black54),
          textAlign: TextAlign.center,
        ),
        const SizedBox(height: 6),
        Text(
          status.isEmpty ? 'РЎС‚Р°С‚СѓСЃ РЅРµ СѓРєР°Р·Р°РЅ' : status,
          style: text.bodyLarge,
          textAlign: TextAlign.center,
        ),
      ],
    );
  }
}

// =================== METRICS ===================

class _MetricsRow extends StatelessWidget {
  final String messages;
  final String rating;
  final String friends;

  const _MetricsRow({
    required this.messages,
    required this.rating,
    required this.friends,
  });

  @override
  Widget build(BuildContext context) {
    final bg = Theme.of(context).colorScheme.primary.withOpacity(.08);

    Widget cell(IconData icon, String label, String value) {
      return Expanded(
        child: Column(
          children: [
            Icon(icon, size: 22),
            const SizedBox(height: 8),
            Text(
              value,
              style: Theme.of(context)
                  .textTheme
                  .titleMedium
                  ?.copyWith(fontWeight: FontWeight.w700),
            ),
            const SizedBox(height: 2),
            Text(label, style: const TextStyle(color: Colors.black54)),
          ],
        ),
      );
    }

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 16),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Row(
        children: [
          cell(Icons.chat_bubble_outline, 'РЎРѕРѕР±С‰РµРЅРёСЏ', messages),
          const SizedBox(width: 12),
          cell(Icons.grade_outlined, 'Р РµР№С‚РёРЅРі', rating),
          const SizedBox(width: 12),
          cell(Icons.group_outlined, 'Р”СЂСѓР·СЊСЏ', friends),
        ],
      ),
    );
  }
}

// =================== FEED / CAROUSEL ===================

class FeedItem {
  final String title;
  final String subtitle;
  final List<Color> gradient;
  final String? route;
  final String? url;

  FeedItem({
    required this.title,
    required this.subtitle,
    required this.gradient,
    this.route,
    this.url,
  });
}

final List<FeedItem> _demoFeed = [
  FeedItem(
    title: 'Рћ РЅР°СЃ',
    subtitle: 'РљРѕРјР°РЅРґР° РЎС‚СѓРґРµРЅС‚ РџР»Р°С‚С„РѕСЂРј',
    gradient: [const Color(0xFF6D5DF6), const Color(0xFF9A7BFF)],
    url: 'https://example.com/about',
  ),
  FeedItem(
    title: 'Р Р°СЃРїРёСЃР°РЅРёРµ Р·Р°РЅСЏС‚РёР№',
    subtitle: 'РўРІРѕРµ СЂР°СЃРїРёСЃР°РЅРёРµ РІСЃРµРіРґР° РїРѕРґ СЂСѓРєРѕР№',
    gradient: [const Color(0xFF5DB2F6), const Color(0xFF7BD2FF)],
    route: '/schedule',
  ),
  FeedItem(
    title: 'РЎРєРёРґРєРё РґР»СЏ СЃС‚СѓРґРµРЅС‚РѕРІ',
    subtitle: 'РћР±РЅРѕРІР»СЏРµРј Р»СѓС‡С€РёРµ РїСЂРµРґР»РѕР¶РµРЅРёСЏ',
    gradient: [const Color(0xFF6AC38F), const Color(0xFF8DE4B0)],
    url: 'https://example.com/discounts',
  ),
];

class _FeedCarousel extends StatefulWidget {
  final List<FeedItem> items;
  final void Function(FeedItem) onTapItem;
  const _FeedCarousel({required this.items, required this.onTapItem});

  @override
  State<_FeedCarousel> createState() => _FeedCarouselState();
}

class _FeedCarouselState extends State<_FeedCarousel> {
  final PageController _controller = PageController(viewportFraction: .92);
  int _index = 0;

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final items = widget.items;

    return Column(
      children: [
        SizedBox(
          height: 160,
          child: PageView.builder(
            controller: _controller,
            onPageChanged: (i) => setState(() => _index = i),
            itemCount: items.length,
            itemBuilder: (_, i) {
              final it = items[i];
              return GestureDetector(
                onTap: () => widget.onTapItem(it),
                child: Container(
                  margin: const EdgeInsets.symmetric(horizontal: 6),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(20),
                    gradient: LinearGradient(
                      colors: it.gradient,
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    ),
                    boxShadow: [
                      BoxShadow(
                        color: it.gradient.last.withOpacity(.35),
                        blurRadius: 18,
                        offset: const Offset(0, 8),
                      ),
                    ],
                  ),
                  child: Stack(
                    children: [
                      Positioned(
                        left: 16,
                        right: 16,
                        bottom: 16,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              it.title,
                              style: const TextStyle(
                                color: Colors.white,
                                fontSize: 18,
                                fontWeight: FontWeight.w800,
                              ),
                            ),
                            const SizedBox(height: 6),
                            Text(
                              it.subtitle,
                              style: const TextStyle(
                                color: Colors.white70,
                                fontSize: 13.5,
                                height: 1.2,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
        const SizedBox(height: 10),
        _DotsIndicator(length: items.length, index: _index),
      ],
    );
  }
}

class _DotsIndicator extends StatelessWidget {
  final int length;
  final int index;
  const _DotsIndicator({required this.length, required this.index});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: List.generate(length, (i) {
        final active = i == index;
        return AnimatedContainer(
          duration: const Duration(milliseconds: 250),
          margin: const EdgeInsets.symmetric(horizontal: 4),
          height: 6,
          width: active ? 18 : 6,
          decoration: BoxDecoration(
            color: active
                ? Theme.of(context).colorScheme.primary
                : Colors.grey.shade400,
            borderRadius: BorderRadius.circular(12),
          ),
        );
      }),
    );
  }
}

// =================== EXAMS BANNER ===================

class _ExamsBanner extends StatelessWidget {
  final VoidCallback onTap;
  const _ExamsBanner({required this.onTap});

  @override
  Widget build(BuildContext context) {
    final colors = [
      Theme.of(context).colorScheme.primary.withOpacity(.12),
      Theme.of(context).colorScheme.primary.withOpacity(.2),
    ];
    return GestureDetector(
      onTap: onTap,
      child: Container(
        height: 64,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(16),
          gradient: LinearGradient(
            colors: colors,
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          boxShadow: [
            BoxShadow(
              color: colors.last.withOpacity(.25),
              blurRadius: 16,
              offset: const Offset(0, 10),
            ),
          ],
        ),
        padding: const EdgeInsets.symmetric(horizontal: 16),
        child: Row(
          children: [
            const Icon(Icons.school_outlined, size: 24),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                'Р—Р°С‡С‘С‚С‹ Рё СЌРєР·Р°РјРµРЅС‹',
                style: Theme.of(context)
                    .textTheme
                    .titleMedium
                    ?.copyWith(fontWeight: FontWeight.w700),
              ),
            ),
            const Icon(Icons.chevron_right),
          ],
        ),
      ),
    );
  }
}

// =================== UTILS ===================

class _SectionTitle extends StatelessWidget {
  final String title;
  const _SectionTitle(this.title);

  @override
  Widget build(BuildContext context) {
    return Text(
      title,
      style: Theme.of(context)
          .textTheme
          .titleMedium
          ?.copyWith(fontWeight: FontWeight.w700),
    );
  }
}



===== FILE: src\ui\schedule\schedule_screen.dart =====
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class ScheduleScreen extends StatelessWidget {
  const ScheduleScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Р Р°СЃРїРёСЃР°РЅРёРµ Р·Р°РЅСЏС‚РёР№')),
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Lottie.asset(
              'assets/lottie/cat_sleeping.json',
              width: 180,
              height: 180,
              repeat: true,
            ),
            const SizedBox(height: 12),
            const Text(
              'Р—РґРµСЃСЊ РїРѕРєР° РїСѓСЃС‚Рѕ',
              style: TextStyle(fontSize: 14, color: Colors.grey),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\ui\screens\chat_screen.dart =====
import 'package:flutter/material.dart';

class ChatScreen extends StatelessWidget {
  const ChatScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Р§Р°С‚ РїРѕ РїСЂРµРґРјРµС‚Сѓ')),
      body: const Center(
        child: Text(
          'Р§Р°С‚С‹ РїРѕРєР° РІ РґРµРјРѕ-СЂРµР¶РёРјРµ',
          style: TextStyle(fontSize: 18),
        ),
      ),
    );
  }
}



===== FILE: src\ui\splash\splash_screen.dart =====
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:go_router/go_router.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  @override
  void initState() {
    super.initState();
    _bootstrap();
  }

  Future<void> _bootstrap() async {
    // РќРµР±РѕР»СЊС€Р°СЏ РїР°СѓР·Р° РґР»СЏ Р°РЅРёРјР°С†РёРё
    await Future.delayed(const Duration(milliseconds: 600));
    final prefs = await SharedPreferences.getInstance();

    final loggedIn = prefs.getBool('loggedIn') ?? false;
    final userJson = prefs.getString('user');
    final hasUser = userJson != null && jsonDecode(userJson) is Map;

    if (!mounted) return;
    if (loggedIn && hasUser) {
      context.go('/home');
    } else {
      context.go('/login');
    }
  }

  @override
  Widget build(BuildContext context) {
    final t = Theme.of(context);
    return Scaffold(
      backgroundColor: t.colorScheme.surface,
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset('assets/lottie/cat_sleeping.json', height: 200),
            const SizedBox(height: 16),
            Text('Р—Р°РіСЂСѓР¶Р°РµРјвЂ¦', style: t.textTheme.titleMedium),
            const SizedBox(height: 8),
            const SizedBox(
              width: 28,
              height: 28,
              child: CircularProgressIndicator(strokeWidth: 3),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: src\ui\widgets\loading_widget.dart =====
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class LoadingWidget extends StatelessWidget {
  final String? message;
  const LoadingWidget({super.key, this.message});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // РђРЅРёРјР°С†РёСЏ РєРѕС€РєРё
          SizedBox(
            height: 150,
            child: Lottie.asset(
              'assets/lottie/cat_loading.json',
              fit: BoxFit.contain,
            ),
          ),
          const SizedBox(height: 16),
          // РЎРѕРѕР±С‰РµРЅРёРµ
          Text(
            message ?? 'Р—Р°РіСЂСѓР·РєР°...',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              fontSize: 16,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: src\widgets\empty_state_widget.dart =====
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class EmptyStateWidget extends StatelessWidget {
  final String title;
  final String subtitle;

  const EmptyStateWidget({
    super.key,
    required this.title,
    required this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset(
              'assets/lottie/cat_sleeping.json',
              width: 200,
              height: 200,
              repeat: true,
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: const TextStyle(fontSize: 18, fontWeight: FontWeight.w500),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: const TextStyle(fontSize: 14, color: Colors.grey),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: vendor\chatview\chatview_lib.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

library chatview;

export 'package:audio_waveforms/audio_waveforms.dart'
    show
        WaveStyle,
        PlayerWaveStyle,
        AndroidEncoder,
        IosEncoder,
        AndroidOutputFormat;
export 'package:chatview_utils/chatview_utils.dart';
export 'package:emoji_picker_flutter/emoji_picker_flutter.dart';

export 'src/extensions/extensions.dart' show MessageTypes;
export 'src/models/config_models/receipts_widget_config.dart';
export 'src/models/models.dart';
export 'src/utils/chat_view_locale.dart';
export 'src/utils/package_strings.dart';
export 'src/values/enumeration.dart';
export 'src/values/typedefs.dart';
export 'src/widgets/chat_view.dart';
export 'src/widgets/chat_view_appbar.dart';



===== FILE: vendor\chatview\src\extensions\extensions.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../inherited_widgets/configurations_inherited_widgets.dart';
import '../models/config_models/chat_bubble_configuration.dart';
import '../models/config_models/message_list_configuration.dart';
import '../models/config_models/reply_suggestions_config.dart';
import '../utils/constants/constants.dart';
import '../utils/emoji_parser.dart';
import '../utils/package_strings.dart';
import '../widgets/chat_view_inherited_widget.dart';
import '../widgets/profile_image_widget.dart';
import '../widgets/suggestions/suggestions_config_inherited_widget.dart';

/// Extension for DateTime to get specific formats of dates and time.
extension TimeDifference on DateTime {
  String getDay(String chatSeparatorDatePattern) {
    final now = DateTime.now();

    /// Compares only the year, month, and day of the dates, ignoring the time.
    /// For example, `2024-12-09 22:00` and `2024-12-10 00:05` are on different
    /// calendar days but less than 24 hours apart. This ensures the difference
    /// is based on the date, not the total hours between the timestamps.
    final targetDate = DateTime(year, month, day);
    final currentDate = DateTime(now.year, now.month, now.day);

    final differenceInDays = currentDate.difference(targetDate).inDays;

    if (differenceInDays == 0) {
      return PackageStrings.currentLocale.today;
    } else if (differenceInDays <= 1 && differenceInDays >= -1) {
      return PackageStrings.currentLocale.yesterday;
    } else {
      final DateFormat formatter = DateFormat(chatSeparatorDatePattern);
      return formatter.format(this);
    }
  }

  String get getDateFromDateTime {
    final DateFormat formatter = DateFormat(dateFormat);
    return formatter.format(this);
  }

  String get getTimeFromDateTime => DateFormat.Hm().format(this);
}

/// Extension on String which implements different types string validations.
extension ValidateString on String {
  bool get isImageUrl {
    final imageUrlRegExp = RegExp(imageUrlRegExpression);
    return imageUrlRegExp.hasMatch(this) || startsWith('data:image');
  }

  bool get fromMemory => startsWith('data:image');

  bool get isAllEmoji {
    for (String s in EmojiParser().unemojify(this).split(" ")) {
      if (!s.startsWith(":") || !s.endsWith(":")) {
        return false;
      }
    }
    return true;
  }

  bool get isUrl => Uri.tryParse(this)?.isAbsolute ?? false;

  Widget getUserProfilePicture({
    required ChatUser? Function(String) getChatUser,
    double? profileCircleRadius,
    EdgeInsets? profileCirclePadding,
  }) {
    final user = getChatUser(this);
    return Padding(
      padding: profileCirclePadding ?? const EdgeInsets.only(left: 4),
      child: ProfileImageWidget(
        imageUrl: user?.profilePhoto,
        imageType: user?.imageType,
        defaultAvatarImage: user?.defaultAvatarImage ?? Constants.profileImage,
        circleRadius: profileCircleRadius ?? 8,
        assetImageErrorBuilder: user?.assetImageErrorBuilder,
        networkImageErrorBuilder: user?.networkImageErrorBuilder,
        networkImageProgressIndicatorBuilder:
            user?.networkImageProgressIndicatorBuilder,
      ),
    );
  }
}

/// Extension on MessageType for checking specific message type
extension MessageTypes on MessageType {
  bool get isImage => this == MessageType.image;

  bool get isText => this == MessageType.text;

  bool get isVoice => this == MessageType.voice;

  bool get isCustom => this == MessageType.custom;
}

/// Extension on ConnectionState for checking specific connection.
extension ConnectionStates on ConnectionState {
  bool get isWaiting => this == ConnectionState.waiting;

  bool get isActive => this == ConnectionState.active;
}

/// Extension on nullable sting to return specific state string.
extension ChatViewStateTitleExtension on String? {
  String getChatViewStateTitle(ChatViewState state) {
    switch (state) {
      case ChatViewState.hasMessages:
        return this ?? '';
      case ChatViewState.noData:
        return this ?? PackageStrings.currentLocale.noMessage;
      case ChatViewState.loading:
        return this ?? '';
      case ChatViewState.error:
        return this ?? PackageStrings.currentLocale.somethingWentWrong;
    }
  }
}

/// Extension on State for accessing inherited widget.
extension StatefulWidgetExtension on State {
  ChatViewInheritedWidget? get chatViewIW =>
      context.mounted ? ChatViewInheritedWidget.of(context) : null;

  ReplySuggestionsConfig? get suggestionsConfig => context.mounted
      ? SuggestionsConfigIW.of(context)?.suggestionsConfig
      : null;

  ConfigurationsInheritedWidget get chatListConfig =>
      context.mounted && ConfigurationsInheritedWidget.of(context) != null
          ? ConfigurationsInheritedWidget.of(context)!
          : const ConfigurationsInheritedWidget(
              chatBackgroundConfig: ChatBackgroundConfiguration(),
              child: SizedBox.shrink(),
            );
}

/// Extension on State for accessing inherited widget.
extension BuildContextExtension on BuildContext {
  ChatViewInheritedWidget? get chatViewIW =>
      mounted ? ChatViewInheritedWidget.of(this) : null;

  ReplySuggestionsConfig? get suggestionsConfig =>
      mounted ? SuggestionsConfigIW.of(this)?.suggestionsConfig : null;

  ConfigurationsInheritedWidget get chatListConfig =>
      mounted && ConfigurationsInheritedWidget.of(this) != null
          ? ConfigurationsInheritedWidget.of(this)!
          : const ConfigurationsInheritedWidget(
              chatBackgroundConfig: ChatBackgroundConfiguration(),
              child: SizedBox.shrink(),
            );

  ChatBubbleConfiguration? get chatBubbleConfig =>
      chatListConfig.chatBubbleConfig;
}



===== FILE: vendor\chatview\src\inherited_widgets\configurations_inherited_widgets.dart =====
import 'package:emoji_picker_flutter/emoji_picker_flutter.dart';
import 'package:flutter/material.dart';

import '../models/models.dart';

class ConfigurationsInheritedWidget extends InheritedWidget {
  const ConfigurationsInheritedWidget({
    Key? key,
    required Widget child,
    required this.chatBackgroundConfig,
    this.reactionPopupConfig,
    this.messageConfig,
    this.chatBubbleConfig,
    this.profileCircleConfig,
    this.swipeToReplyConfig,
    this.repliedMessageConfig,
    this.typeIndicatorConfig,
    this.replyPopupConfig,
    this.emojiPickerSheetConfig,
    this.scrollToBottomButtonConfig,
  }) : super(key: key, child: child);

  /// Provides configuration for background of chat.
  final ChatBackgroundConfiguration chatBackgroundConfig;

  /// Provides configuration for reaction pop up appearance.
  final ReactionPopupConfiguration? reactionPopupConfig;

  /// Provides configuration for customisation of different types
  /// messages.
  final MessageConfiguration? messageConfig;

  /// Provides configuration of chat bubble's appearance.
  final ChatBubbleConfiguration? chatBubbleConfig;

  /// Provides configuration for profile circle avatar of user.
  final ProfileCircleConfiguration? profileCircleConfig;

  /// Provides configuration for when user swipe to chat bubble.
  final SwipeToReplyConfiguration? swipeToReplyConfig;

  /// Provides configuration for replied message view which is located upon chat
  /// bubble.
  final RepliedMessageConfiguration? repliedMessageConfig;

  /// Provides configuration of typing indicator's appearance.
  final TypeIndicatorConfiguration? typeIndicatorConfig;

  /// Provides configuration for reply snack bar's appearance and options.
  final ReplyPopupConfiguration? replyPopupConfig;

  /// Configuration for emoji picker sheet
  final Config? emojiPickerSheetConfig;

  /// Provides a configuration for scroll to bottom button config
  final ScrollToBottomButtonConfig? scrollToBottomButtonConfig;

  static ConfigurationsInheritedWidget? of(BuildContext context) => context
      .dependOnInheritedWidgetOfExactType<ConfigurationsInheritedWidget>();

  @override
  bool updateShouldNotify(covariant ConfigurationsInheritedWidget oldWidget) =>
      oldWidget != this;
}



===== FILE: vendor\chatview\src\models\chat_bubble.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import 'config_models/link_preview_configuration.dart';
import 'config_models/receipts_widget_config.dart';

class ChatBubble {
  const ChatBubble({
    this.color,
    this.borderRadius,
    this.textStyle,
    this.padding,
    this.margin,
    this.linkPreviewConfig,
    this.senderNameTextStyle,
    this.receiptsWidgetConfig,
    this.onMessageRead,
  });

  /// Used for giving color of chat bubble.
  final Color? color;

  /// Used for giving border radius of chat bubble.
  final BorderRadiusGeometry? borderRadius;

  /// Used for giving text style of chat bubble.
  final TextStyle? textStyle;

  /// Used for giving padding of chat bubble.
  final EdgeInsetsGeometry? padding;

  /// Used for giving margin of chat bubble.
  final EdgeInsetsGeometry? margin;

  /// Used to provide configuration of messages with link.
  final LinkPreviewConfiguration? linkPreviewConfig;

  /// Used to give text style of message sender name.
  final TextStyle? senderNameTextStyle;

  /// Used to provide builders for last seen message reciept,
  /// at latest outgoing messsage.
  final ReceiptsWidgetConfig? receiptsWidgetConfig;

  /// Callback when a message has been displayed for the first
  /// time only
  final ValueSetter<Message>? onMessageRead;
}



===== FILE: vendor\chatview\src\models\config_models\chat_bubble_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../models.dart';

class ChatBubbleConfiguration {
  const ChatBubbleConfiguration({
    this.padding,
    this.margin,
    this.maxWidth,
    this.longPressAnimationDuration,
    this.inComingChatBubbleConfig,
    this.outgoingChatBubbleConfig,
    this.onDoubleTap,
    this.disableLinkPreview = false,
  });

  /// Used for giving padding of chat bubble.
  final EdgeInsetsGeometry? padding;

  /// Used for giving margin of chat bubble.
  final EdgeInsetsGeometry? margin;

  /// Used for giving maximum width of chat bubble.
  final double? maxWidth;

  /// Provides callback when user long press on chat bubble.
  final Duration? longPressAnimationDuration;

  /// Provides configuration of other users message's chat bubble.
  final ChatBubble? inComingChatBubbleConfig;

  /// Provides configuration of current user message's chat bubble.
  final ChatBubble? outgoingChatBubbleConfig;

  /// Provides callback when user tap twice on chat bubble.
  final ValueSetter<Message>? onDoubleTap;

  /// A flag to disable link preview functionality.
  ///
  /// When `true`, link previews will be disabled, rendering links as plain text
  /// or standard hyperlinks without additional preview metadata.
  /// When `false`, link previews will be enabled by default (current behavior).
  ///
  /// Default value: `false`.
  final bool disableLinkPreview;
}



===== FILE: vendor\chatview\src\models\config_models\chat_view_states_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';

class ChatViewStateConfiguration {
  const ChatViewStateConfiguration({
    this.errorWidgetConfig = const ChatViewStateWidgetConfiguration(),
    this.noMessageWidgetConfig = const ChatViewStateWidgetConfiguration(),
    this.loadingWidgetConfig = const ChatViewStateWidgetConfiguration(),
    this.onReloadButtonTap,
  });

  /// Provides configuration of error state's widget.
  final ChatViewStateWidgetConfiguration? errorWidgetConfig;

  /// Provides configuration of no message state's widget.
  final ChatViewStateWidgetConfiguration? noMessageWidgetConfig;

  /// Provides configuration of loading state's widget.
  final ChatViewStateWidgetConfiguration? loadingWidgetConfig;

  /// Provides callback when user taps on reload button.
  final VoidCallback? onReloadButtonTap;
}

class ChatViewStateWidgetConfiguration {
  const ChatViewStateWidgetConfiguration({
    this.widget,
    this.title,
    this.titleTextStyle,
    this.imageWidget,
    this.subTitle,
    this.subTitleTextStyle,
    this.loadingIndicatorColor,
    this.reloadButton,
    this.showDefaultReloadButton = true,
    this.reloadButtonColor,
  });

  /// Used to give title of state.
  final String? title;

  /// Used to give sub-title of state.
  final String? subTitle;

  /// Used to give text style of title in any state.
  final TextStyle? titleTextStyle;

  /// Used to give text style of sub-title in any state.
  final TextStyle? subTitleTextStyle;

  /// Provides parameter to pass image widget in any state.
  final Widget? imageWidget;

  /// Used to give color of loading indicator.
  final Color? loadingIndicatorColor;

  /// Provides parameter to pass custom reload button in any state.
  final Widget? reloadButton;

  /// Used to show reload button.
  final bool showDefaultReloadButton;

  /// Used to give color of reload button.
  final Color? reloadButtonColor;

  /// Gives ability to pass custom widget in any state.
  final Widget? widget;
}



===== FILE: vendor\chatview\src\models\config_models\emoji_message_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

class EmojiMessageConfiguration {
  const EmojiMessageConfiguration({
    this.padding,
    this.textStyle,
  });

  /// Used for giving padding to emoji messages.
  final EdgeInsetsGeometry? padding;

  /// Used for giving text style to emoji messages.
  final TextStyle? textStyle;
}



===== FILE: vendor\chatview\src\models\config_models\feature_active_config.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class FeatureActiveConfig {
  const FeatureActiveConfig({
    this.enableSwipeToReply = true,
    this.enableReactionPopup = true,
    this.enableTextField = true,
    this.enableSwipeToSeeTime = true,
    this.enableCurrentUserProfileAvatar = false,
    this.enableOtherUserProfileAvatar = true,
    this.enableReplySnackBar = true,
    this.enablePagination = false,
    this.enableChatSeparator = true,
    this.enableDoubleTapToLike = true,
    this.lastSeenAgoBuilderVisibility = true,
    this.receiptsBuilderVisibility = true,
    this.enableOtherUserName = true,
    this.enableScrollToBottomButton = false,
  });

  /// Used for enable/disable swipe to reply.
  final bool enableSwipeToReply;

  /// Used for enable/disable reaction pop-up.
  final bool enableReactionPopup;

  /// Used for enable/disable text field.
  final bool enableTextField;

  /// Used for enable/disable swipe whole chat to see message created time.
  final bool enableSwipeToSeeTime;

  /// Used for enable/disable current user profile circle.
  final bool enableCurrentUserProfileAvatar;

  /// Used for enable/disable other users profile circle.
  final bool enableOtherUserProfileAvatar;

  /// Used for enable/disable reply snack bar when user long press on chat-bubble.
  final bool enableReplySnackBar;

  /// Used for enable/disable pagination.
  final bool enablePagination;

  /// Used for enable/disable chat separator widget.
  final bool enableChatSeparator;

  /// Used for enable/disable double tap to like message.
  final bool enableDoubleTapToLike;

  /// Controls the visibility of message seen ago receipts default is true
  final bool lastSeenAgoBuilderVisibility;

  /// Controls the visibility of the message [receiptsBuilder]
  final bool receiptsBuilderVisibility;

  /// Used for enable/disable other users name.
  final bool enableOtherUserName;

  /// Used for enable/disable Scroll To Bottom Button.
  final bool enableScrollToBottomButton;
}



===== FILE: vendor\chatview\src\models\config_models\image_message_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

class ImageMessageConfiguration {
  const ImageMessageConfiguration({
    this.hideShareIcon = false,
    this.shareIconConfig,
    this.onTap,
    this.height,
    this.width,
    this.padding,
    this.margin,
    this.borderRadius,
  });

  /// Provides configuration of share button while image message is appeared.
  final ShareIconConfiguration? shareIconConfig;

  /// Hide share icon in image view.
  final bool hideShareIcon;

  /// Provides callback when user taps on image message.
  final ValueSetter<Message>? onTap;

  /// Used for giving height of image message.
  final double? height;

  /// Used for giving width of image message.
  final double? width;

  /// Used for giving padding of image message.
  final EdgeInsetsGeometry? padding;

  /// Used for giving margin of image message.
  final EdgeInsetsGeometry? margin;

  /// Used for giving border radius of image message.
  final BorderRadius? borderRadius;
}

class ShareIconConfiguration {
  ShareIconConfiguration({
    this.onPressed,
    this.icon,
    this.defaultIconBackgroundColor,
    this.padding,
    this.margin,
    this.defaultIconColor,
  });

  /// Provides callback when user press on share button.
  final ValueSetter<String>? onPressed; // Returns imageURL

  /// Provides ability to add custom share icon.
  final Widget? icon;

  /// Used to give share icon background color.
  final Color? defaultIconBackgroundColor;

  /// Used to give share icon padding.
  final EdgeInsetsGeometry? padding;

  /// Used to give share icon margin.
  final EdgeInsetsGeometry? margin;

  /// Used to give share icon color.
  final Color? defaultIconColor;
}



===== FILE: vendor\chatview\src\models\config_models\link_preview_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

class LinkPreviewConfiguration {
  const LinkPreviewConfiguration({
    this.onUrlDetect,
    this.loadingColor,
    this.backgroundColor,
    this.borderRadius,
    this.bodyStyle,
    this.titleStyle,
    this.linkStyle,
    this.padding,
    this.proxyUrl,
    this.errorBody,
  });

  /// Used for giving background colour of message with link.
  final Color? backgroundColor;

  /// Used for giving border radius of message with link.
  final double? borderRadius;

  /// Used for giving text style of body text in message with link.
  final TextStyle? bodyStyle;

  /// Used for giving text style of title text in message with link.
  final TextStyle? titleStyle;

  /// Used for giving text style of link text in message with link.
  final TextStyle? linkStyle;

  /// Used for giving colour of loader in message with link.
  final Color? loadingColor;

  /// Used for giving padding to message with link.
  final EdgeInsetsGeometry? padding;

  /// Used for giving proxy url to message with link.
  final String? proxyUrl;

  /// Provides callback when message detect url in message.
  final ValueSetter<String>? onUrlDetect;

  /// Displays an error message when the link cannot be parsed for preview.
  final String? errorBody;
}



===== FILE: vendor\chatview\src\models\config_models\message_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import '../../values/typedefs.dart';
import '../models.dart';

class MessageConfiguration {
  const MessageConfiguration({
    this.imageMessageConfig,
    this.messageReactionConfig,
    this.emojiMessageConfig,
    this.customMessageBuilder,
    this.voiceMessageConfig,
    this.customMessageReplyViewBuilder,
  });

  /// Provides configuration of image message appearance.
  final ImageMessageConfiguration? imageMessageConfig;

  /// Provides configuration of image message appearance.
  final MessageReactionConfiguration? messageReactionConfig;

  /// Provides configuration of emoji messages appearance.
  final EmojiMessageConfiguration? emojiMessageConfig;

  /// Provides builder to create view for custom messages.
  final CustomMessageBuilder? customMessageBuilder;

  /// Configurations for voice message bubble
  final VoiceMessageConfiguration? voiceMessageConfig;

  /// To customize reply view for custom message type
  final CustomMessageReplyViewBuilder? customMessageReplyViewBuilder;
}



===== FILE: vendor\chatview\src\models\config_models\message_list_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../../utils/constants/constants.dart';
import '../../values/enumeration.dart';
import '../../values/typedefs.dart';

class ChatBackgroundConfiguration {
  const ChatBackgroundConfiguration({
    this.defaultGroupSeparatorConfig,
    this.backgroundColor,
    this.backgroundImage,
    this.height,
    this.width,
    this.groupSeparatorBuilder,
    this.groupedListOrder = GroupedListOrder.asc,
    this.sortEnable = false,
    this.padding,
    this.margin,
    this.messageTimeTextStyle,
    this.messageTimeIconColor,
    this.loadingWidget,
    this.messageTimeAnimationCurve = Curves.decelerate,
    this.messageSorter,
  });

  /// Provides background color of chat view.
  final Color? backgroundColor;

  /// Provides background image of chat view.
  final String? backgroundImage;

  /// Provides padding of chat view.
  final EdgeInsetsGeometry? padding;

  /// Provides margin of chat view.
  final EdgeInsetsGeometry? margin;

  /// Provides height of chat view.
  final double? height;

  /// Provides width of chat view.
  final double? width;

  /// Provides configurations of chat separator widget.
  final StringWithReturnWidget? groupSeparatorBuilder;

  /// Used to define the order of a [GroupedListView] or [SliverGroupedListView].
  final GroupedListOrder groupedListOrder;

  /// Used to enable sort in list view.
  final bool sortEnable;

  /// Used to give text style of message's time while user swipe to see time of
  /// message.
  final TextStyle? messageTimeTextStyle;

  /// Used to give colour of message's time while user swipe to see time of
  /// message.
  final Color? messageTimeIconColor;

  /// Used to give configuration of default chat separator widget.
  final DefaultGroupSeparatorConfiguration? defaultGroupSeparatorConfig;

  /// Used for giving widget while data is loading.
  final Widget? loadingWidget;

  /// Used to give curve of animation which runes while user swipe to see time of
  /// message.
  final Curve messageTimeAnimationCurve;

  /// Provides callback to sort message
  final MessageSorter? messageSorter;
}

class DefaultGroupSeparatorConfiguration {
  const DefaultGroupSeparatorConfiguration({
    this.padding,
    this.textStyle,
    this.chatSeparatorDatePattern = defaultChatSeparatorDatePattern,
  });

  /// Used for giving padding of chat separator widget.
  final EdgeInsetsGeometry? padding;

  /// Used for giving text style of chat separator widget.
  final TextStyle? textStyle;

  /// Provides pattern to separate chat
  /// Defaults to ['MMM dd, yyyy']
  /// e.g. May 21, 2024
  final String chatSeparatorDatePattern;
}



===== FILE: vendor\chatview\src\models\config_models\message_reaction_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../../values/typedefs.dart';

class MessageReactionConfiguration {
  const MessageReactionConfiguration({
    this.reactionsBottomSheetConfig,
    this.reactionCountTextStyle,
    this.reactedUserCountTextStyle,
    this.reactionSize,
    this.margin,
    this.padding,
    this.backgroundColor,
    this.borderRadius,
    this.borderColor,
    this.borderWidth,
    this.profileCircleRadius,
    this.profileCirclePadding,
  });

  /// Used for giving size of reaction on message.
  final double? reactionSize;

  /// Used for giving margin of reaction on message.
  final EdgeInsetsGeometry? margin;

  /// Used for giving padding of reaction on message.
  final EdgeInsetsGeometry? padding;

  /// Used for giving background colour to reaction on message.
  final Color? backgroundColor;

  /// Used for giving border radius of reaction on message.
  final BorderRadiusGeometry? borderRadius;

  /// Used for giving colour of border to reaction on message.
  final Color? borderColor;

  /// Used for giving border width of reaction on message.
  final double? borderWidth;

  /// Used for giving text style reacted user's name of reaction on message.
  final TextStyle? reactedUserCountTextStyle;

  /// Used for giving text style to total count of reaction text.
  final TextStyle? reactionCountTextStyle;

  /// Provides configurations for reaction bottom sheet which shows reacted users
  /// and their reaction on any message.
  final ReactionsBottomSheetConfiguration? reactionsBottomSheetConfig;

  /// Used for giving radius to reacted user profile circle.
  final double? profileCircleRadius;

  /// Used for padding to reacted user profile circle.
  final EdgeInsets? profileCirclePadding;
}

class ReactionsBottomSheetConfiguration {
  const ReactionsBottomSheetConfiguration({
    this.bottomSheetPadding,
    this.backgroundColor,
    this.reactionWidgetDecoration,
    this.reactionWidgetPadding,
    this.reactionWidgetMargin,
    this.reactedUserTextStyle,
    this.profileCircleRadius,
    this.reactionSize,
    this.reactedUserCallback,
  });

  /// Used for giving padding of bottom sheet.
  final EdgeInsetsGeometry? bottomSheetPadding;

  /// Used for giving padding of reaction widget in bottom sheet.
  final EdgeInsetsGeometry? reactionWidgetPadding;

  /// Used for giving margin of bottom sheet.
  final EdgeInsetsGeometry? reactionWidgetMargin;

  /// Used for giving background color of bottom sheet.
  final Color? backgroundColor;

  /// Used for giving decoration reaction widget in bottom sheet.
  final BoxDecoration? reactionWidgetDecoration;

  /// Used for giving text style to reacted user name.
  final TextStyle? reactedUserTextStyle;

  /// Used for giving profile circle radius.
  final double? profileCircleRadius;

  /// Used for giving size of reaction in bottom sheet.
  final double? reactionSize;

  /// Called when user tap on reacted user from reaction list
  final ReactedUserCallback? reactedUserCallback;
}



===== FILE: vendor\chatview\src\models\config_models\profile_circle_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

class ProfileCircleConfiguration {
  const ProfileCircleConfiguration({
    this.onAvatarTap,
    this.padding,
    this.profileImageUrl,
    this.bottomPadding,
    this.circleRadius,
    this.onAvatarLongPress,
    this.imageType = ImageType.network,
    this.defaultAvatarImage = Constants.profileImage,
    this.networkImageErrorBuilder,
    this.assetImageErrorBuilder,
    this.networkImageProgressIndicatorBuilder,
  });

  /// Used to give padding to profile circle.
  final EdgeInsetsGeometry? padding;

  /// Provides image url as network or asset of user.
  /// Or
  /// Provides image data of user in base64
  final String? profileImageUrl;

  /// Used for give bottom padding to profile circle
  final double? bottomPadding;

  /// Used for give circle radius to profile circle
  final double? circleRadius;

  /// Provides callback when user tap on profile circle.
  final ValueSetter<ChatUser>? onAvatarTap;

  /// Provides callback when user long press on profile circle.
  final ValueSetter<ChatUser>? onAvatarLongPress;

  /// Field to define image type [network, asset or base64]
  final ImageType imageType;

  /// Field to set default avatar image if profile image link not provided
  final String defaultAvatarImage;

  /// Error builder to build error widget for asset image
  final AssetImageErrorBuilder? assetImageErrorBuilder;

  /// Error builder to build error widget for network image
  final NetworkImageErrorBuilder? networkImageErrorBuilder;

  /// Progress indicator builder for network image
  final NetworkImageProgressIndicatorBuilder?
      networkImageProgressIndicatorBuilder;
}



===== FILE: vendor\chatview\src\models\config_models\reaction_popup_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../../values/typedefs.dart';

class ReactionPopupConfiguration {
  const ReactionPopupConfiguration({
    this.userReactionCallback,
    this.overrideUserReactionCallback = false,
    this.showGlassMorphismEffect = false,
    this.backgroundColor,
    this.shadow,
    this.animationDuration,
    this.maxWidth,
    this.margin,
    this.padding,
    this.emojiConfig,
    this.glassMorphismConfig,
  });

  /// Used for background color in reaction pop-up.
  final Color? backgroundColor;

  /// Used for shadow in reaction pop-up.
  final BoxShadow? shadow;

  /// Used for animation duration while reaction pop-up opens.
  final Duration? animationDuration;

  /// Used for max width in reaction pop-up.
  final double? maxWidth;

  /// Used for give margin in reaction pop-up.
  final EdgeInsetsGeometry? margin;

  /// Used for give padding in reaction pop-up.
  final EdgeInsetsGeometry? padding;

  /// Provides emoji configuration in reaction pop-up.
  final EmojiConfiguration? emojiConfig;

  /// Used for showing glass morphism effect on reaction pop-up.
  final bool showGlassMorphismEffect;

  /// Provides glass morphism effect configuration.
  final GlassMorphismConfiguration? glassMorphismConfig;

  /// Provides callback when user react on message.
  final ReactionCallback? userReactionCallback;

  /// Provides feasibility to completely override userReactionCallback defaults to false.
  final bool? overrideUserReactionCallback;
}

class EmojiConfiguration {
  const EmojiConfiguration({
    this.emojiList,
    this.size,
  });

  /// Provides list of emojis.
  final List<String>? emojiList;

  /// Used to give size of emoji.
  final double? size;
}

class GlassMorphismConfiguration {
  const GlassMorphismConfiguration({
    this.borderColor,
    this.strokeWidth,
    this.backgroundColor,
    this.borderRadius,
  });

  /// Used to give border color of reaction pop-up.
  final Color? borderColor;

  /// Used to give stroke width of reaction pop-up.
  final double? strokeWidth;

  /// Used to give background color of reaction pop-up.
  final Color? backgroundColor;

  /// Used to give border radius of reaction pop-up.
  final double? borderRadius;
}



===== FILE: vendor\chatview\src\models\config_models\receipts_widget_config.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import '../../utils/constants/constants.dart';
import '../../values/enumeration.dart';
import '../../values/typedefs.dart';

class ReceiptsWidgetConfig {
  const ReceiptsWidgetConfig({
    this.receiptsBuilder,
    this.lastSeenAgoBuilder,
    this.showReceiptsIn = ShowReceiptsIn.lastMessage,
  });

  /// The builder that builds widget that right next to the senders message bubble.
  /// Right now it's implemented to show animation only at the last message just
  /// like instagram.
  /// By default [sendMessageAnimationBuilder]
  final ReceiptBuilder? receiptsBuilder;

  /// Just like Instagram messages receipts are displayed at the bottom of last
  /// message. If in case you want to modify it using your custom widget you can
  /// utilize this function.
  final LastSeenAgoBuilder? lastSeenAgoBuilder;

  /// Whether to show receipts in all messages or not defaults to [ShowReceiptsIn.lastMessage]
  final ShowReceiptsIn showReceiptsIn;
}



===== FILE: vendor\chatview\src\models\config_models\replied_message_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../../values/typedefs.dart';
import 'replied_msg_auto_scroll_config.dart';

class RepliedMessageConfiguration {
  const RepliedMessageConfiguration({
    this.verticalBarColor,
    this.backgroundColor,
    this.textStyle,
    this.replyTitleTextStyle,
    this.margin,
    this.padding,
    this.maxWidth,
    this.borderRadius,
    this.verticalBarWidth,
    this.repliedImageMessageHeight,
    this.repliedImageMessageWidth,
    this.repliedMessageWidgetBuilder,
    this.opacity,
    this.repliedMsgAutoScrollConfig = const RepliedMsgAutoScrollConfig(),
    this.micIconColor,
  });

  /// Used to give color to vertical bar.
  final Color? verticalBarColor;

  /// Used to give background color to replied message widget.
  final Color? backgroundColor;

  /// Used to give text style to reply message.
  final TextStyle? textStyle;

  /// Used to give text style to replied message widget's title
  final TextStyle? replyTitleTextStyle;

  /// Used to give margin in replied message widget.
  final EdgeInsetsGeometry? margin;

  /// Used to give padding in replied message widget.
  final EdgeInsetsGeometry? padding;

  /// Used to give max width in replied message widget.
  final double? maxWidth;

  /// Used to give border radius in replied message widget.
  final BorderRadiusGeometry? borderRadius;

  /// Used to give width to vertical bar in replied message widget.
  final double? verticalBarWidth;

  /// Used to give height of image when there is image in replied message.
  final double? repliedImageMessageHeight;

  /// Used to give width of image when there is image in replied message.
  final double? repliedImageMessageWidth;

  /// Used to give opacity of replied message.
  final double? opacity;

  /// Provides builder for custom view of replied message.
  final ReplyMessageWithReturnWidget? repliedMessageWidgetBuilder;

  /// Configuration for auto scrolling and highlighting a message when
  /// tapping on the original message above the replied message.
  final RepliedMsgAutoScrollConfig repliedMsgAutoScrollConfig;

  /// Color for microphone icon.
  final Color? micIconColor;
}



===== FILE: vendor\chatview\src\models\config_models\replied_msg_auto_scroll_config.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';

class RepliedMsgAutoScrollConfig {
  /// Auto scrolls to original message when tapped on replied message.
  /// Defaults to true.
  final bool enableScrollToRepliedMsg;

  /// Highlights the text by changing background color of chat bubble for
  /// given duration. Default to true.
  final bool enableHighlightRepliedMsg;

  /// Chat bubble color when highlighted. Defaults to Colors.grey.
  final Color highlightColor;

  /// Chat will remain highlighted for this duration. Defaults to 500ms.
  final Duration highlightDuration;

  /// When replied message have image or only emojis. They will be scaled
  /// for provided [highlightDuration] to highlight them. Defaults to 1.1
  final double highlightScale;

  /// Animation curve for auto scroll. Defaults to Curves.easeIn.
  final Curve highlightScrollCurve;

  /// Configuration for auto scrolling and highlighting a message when
  /// tapping on the original message above the replied message.
  const RepliedMsgAutoScrollConfig({
    this.enableHighlightRepliedMsg = true,
    this.enableScrollToRepliedMsg = true,
    this.highlightColor = Colors.grey,
    this.highlightDuration = const Duration(milliseconds: 500),
    this.highlightScale = 1.1,
    this.highlightScrollCurve = Curves.easeIn,
  });
}



===== FILE: vendor\chatview\src\models\config_models\reply_popup_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../../values/typedefs.dart';

class ReplyPopupConfiguration {
  const ReplyPopupConfiguration({
    this.buttonTextStyle,
    this.topBorderColor,
    this.onUnsendTap,
    this.onReplyTap,
    this.onReportTap,
    this.onMoreTap,
    this.backgroundColor,
    this.replyPopupBuilder,
  });

  /// Used for giving background color to reply snack-bar.
  final Color? backgroundColor;

  /// Provides builder for creating reply pop-up widget.
  final ReplyPopupBuilder? replyPopupBuilder;

  /// Provides callback on unSend button.
  final ValueSetter<Message>? onUnsendTap;

  /// Provides callback on onReply button.
  final ValueSetter<Message>? onReplyTap;

  /// Provides callback on onReport button.
  final ValueSetter<Message>? onReportTap;

  /// Provides callback on onMore button.
  final MoreTapCallBack? onMoreTap;

  /// Used to give text style of button text.
  final TextStyle? buttonTextStyle;

  /// Used to give color to top side border of reply snack bar.
  final Color? topBorderColor;
}



===== FILE: vendor\chatview\src\models\config_models\reply_suggestions_config.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../../values/enumeration.dart';
import 'suggestion_list_config.dart';

/// Configuration for reply suggestions in a chat view.
class ReplySuggestionsConfig {
  const ReplySuggestionsConfig({
    this.listConfig,
    this.itemConfig,
    this.onTap,
    this.autoDismissOnSelection = true,
    this.suggestionItemType = SuggestionItemsType.scrollable,
    this.spaceBetweenSuggestionItemRow = 10,
  });

  /// Used to give configuration for suggestion item.
  final SuggestionItemConfig? itemConfig;

  /// Used to give configuration for suggestion list.
  final SuggestionListConfig? listConfig;

  /// Provides callback when user taps on suggestion item.
  final ValueSetter<SuggestionItemData>? onTap;

  /// If true, the suggestion popup will be dismissed automatically when a suggestion is selected.
  final bool autoDismissOnSelection;

  /// Defines the type of suggestion items, whether they are scrollable or not.
  final SuggestionItemsType suggestionItemType;

  /// Defines the space between each row of suggestion items.
  final double spaceBetweenSuggestionItemRow;
}



===== FILE: vendor\chatview\src\models\config_models\scroll_to_bottom_button_config.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';

import '../../values/enumeration.dart';

/// Configuration for the "Scroll to Bottom" button.
class ScrollToBottomButtonConfig {
  ScrollToBottomButtonConfig({
    this.backgroundColor,
    this.border,
    this.borderRadius,
    this.icon,
    this.scrollAnimationDuration,
    this.alignment,
    this.padding,
    this.onClick,
    this.buttonDisplayOffset,
  });

  /// The background color of the button.
  final Color? backgroundColor;

  /// The border of the button.
  final Border? border;

  /// The border radius of the button.
  final BorderRadius? borderRadius;

  /// The icon displayed on the button.
  final Icon? icon;

  /// The duration of the scroll animation when the button is clicked.
  final Duration? scrollAnimationDuration;

  /// The alignment of the button on top of text field.
  final ScrollButtonAlignment? alignment;

  /// The padding around the button.
  final EdgeInsets? padding;

  /// The callback function to be executed when the button is clicked.
  final VoidCallback? onClick;

  /// The scroll offset after which the button is displayed.
  /// The button appears when the scroll position is greater than or equal to this value.
  final double? buttonDisplayOffset;
}



===== FILE: vendor\chatview\src\models\config_models\send_message_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:audio_waveforms/audio_waveforms.dart';
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:image_picker/image_picker.dart';

import '../../values/typedefs.dart';

class SendMessageConfiguration {
  const SendMessageConfiguration({
    this.textFieldConfig,
    this.textFieldBackgroundColor,
    this.imagePickerIconsConfig,
    this.imagePickerConfiguration,
    this.defaultSendButtonColor,
    this.sendButtonIcon,
    this.replyDialogColor,
    this.replyTitleColor,
    this.replyMessageColor,
    this.closeIconColor,
    this.allowRecordingVoice = true,
    this.enableCameraImagePicker = true,
    this.enableGalleryImagePicker = true,
    this.voiceRecordingConfiguration,
    this.micIconColor,
    this.cancelRecordConfiguration,
    this.shouldSendImageWithText = false,
    this.removeImageIcon,
    this.removeImageIconColor,
    this.removeImageIconSize,
    this.selectedImageMargin,
    this.selectedImageViewHeight,
    this.imageBorderRadius,
    this.selectedImageViewBuilder,
  });

  /// Used to give background color to text field.
  final Color? textFieldBackgroundColor;

  /// Used to give color to send button.
  final Color? defaultSendButtonColor;

  /// Provides ability to give custom send button.
  final Widget? sendButtonIcon;

  /// Used to give reply dialog color.
  final Color? replyDialogColor;

  /// Used to give color to title of reply pop-up.
  final Color? replyTitleColor;

  /// Used to give color to reply message.
  final Color? replyMessageColor;

  /// Used to give color to close icon in reply pop-up.
  final Color? closeIconColor;

  /// Provides configuration of image picker functionality.
  final ImagePickerIconsConfiguration? imagePickerIconsConfig;

  /// Provides configuration of image picker plugin.
  final ImagePickerConfiguration? imagePickerConfiguration;

  /// Provides configuration of text field.
  final TextFieldConfiguration? textFieldConfig;

  /// Enable/disable voice recording. Enabled by default.
  final bool allowRecordingVoice;

  /// Enable/disable image picker from gallery. Enabled by default.
  final bool enableGalleryImagePicker;

  /// Enable/disable send image from camera. Enabled by default.
  final bool enableCameraImagePicker;

  /// Color of mic icon when replying to some voice message.
  final Color? micIconColor;

  /// Styling configuration for recorder widget.
  final VoiceRecordingConfiguration? voiceRecordingConfiguration;

  /// Configuration for cancel voice recording
  final CancelRecordConfiguration? cancelRecordConfiguration;

  /// If true, then image will be sent with text message.
  final bool shouldSendImageWithText;

  /// Icon to remove image from text field.
  final Widget? removeImageIcon;

  /// Color of remove image icon.
  final Color? removeImageIconColor;

  /// Size of remove image icon.
  final double? removeImageIconSize;

  /// Margin around selected image in text field.
  final EdgeInsets? selectedImageMargin;

  /// Height of selected image view in text field.
  final double? selectedImageViewHeight;

  /// Border radius of selected image in text field.
  final double? imageBorderRadius;

  /// Provides ability to build custom view for selected images in text field.
  final SelectedImageViewBuilder? selectedImageViewBuilder;
}

class ImagePickerIconsConfiguration {
  const ImagePickerIconsConfiguration({
    this.cameraIconColor,
    this.galleryIconColor,
    this.galleryImagePickerIcon,
    this.cameraImagePickerIcon,
  });

  /// Provides ability to pass custom gallery image picker icon.
  final Widget? galleryImagePickerIcon;

  /// Provides ability to pass custom camera image picker icon.
  final Widget? cameraImagePickerIcon;

  /// Used to give color to camera icon.
  final Color? cameraIconColor;

  /// Used to give color to gallery icon.
  final Color? galleryIconColor;
}

class TextFieldConfiguration {
  const TextFieldConfiguration({
    this.contentPadding,
    this.maxLines,
    this.borderRadius,
    this.hintText,
    this.hintStyle,
    this.textStyle,
    this.padding,
    this.margin,
    this.minLines,
    this.textInputType,
    this.onMessageTyping,
    this.compositionThresholdTime = const Duration(seconds: 1),
    this.inputFormatters,
    this.textCapitalization,
    this.enabled = true,
    this.height,
  });

  /// Used to give max lines in text field.
  final int? maxLines;

  /// Used to give min lines in text field.
  final int? minLines;

  /// Used to give padding in text field.
  final EdgeInsetsGeometry? padding;

  /// Used to give margin in text field.
  final EdgeInsetsGeometry? margin;

  /// Used to give hint text in text field.
  final String? hintText;

  /// Used to give text style of hint text in text field.
  final TextStyle? hintStyle;

  /// Used to give text style of actual text in text field.
  final TextStyle? textStyle;

  /// Used to give border radius in text field.
  final BorderRadius? borderRadius;

  /// Used to give content padding in text field.
  final EdgeInsetsGeometry? contentPadding;

  /// Used to give text input type of text field.
  final TextInputType? textInputType;

  /// Used to give list of input formatters for text field.
  final List<TextInputFormatter>? inputFormatters;

  /// Used to give textCapitalization enums to text field.
  final TextCapitalization? textCapitalization;

  /// Callback when a user starts/stops typing a message by [TypeWriterStatus]
  final ValueSetter<TypeWriterStatus>? onMessageTyping;

  /// After typing stopped, the threshold time after which the composing
  /// status to be changed to [TypeWriterStatus.composed].
  /// Default is 1 second.
  final Duration compositionThresholdTime;

  /// Used for enable or disable the chat text field.
  /// [false] also will disable the buttons for send images, record audio or take picture.
  /// Default is [true].
  final bool enabled;

  /// Used to give height of text field.
  final double? height;
}

class ImagePickerConfiguration {
  const ImagePickerConfiguration({
    this.maxWidth,
    this.maxHeight,
    this.imageQuality,
    this.preferredCameraDevice,
    this.onImagePicked,
  });

  /// Used to give max width of image.
  final double? maxWidth;

  /// Used to give max height of image.
  final double? maxHeight;

  /// Used to give image quality.
  final int? imageQuality;

  /// Preferred camera device to pick image from.
  final CameraDevice? preferredCameraDevice;

  /// Callback when image is picked from camera or gallery,
  ///  we can perform our task on image like adding crop options and return new image path
  final ImagePickedCallback? onImagePicked;
}

class VoiceRecordingConfiguration {
  /// Styling configuration for the recorder widget as well as
  /// configuring the audio recording quality.
  const VoiceRecordingConfiguration({
    this.waveStyle,
    this.padding,
    this.margin,
    this.decoration,
    this.backgroundColor,
    this.micIcon,
    this.recorderIconColor,
    this.stopIcon,
    this.sampleRate,
    this.bitRate,
    this.androidEncoder,
    this.iosEncoder,
    this.androidOutputFormat,
  });

  /// Applies styles to waveform.
  final WaveStyle? waveStyle;

  /// Applies padding around waveform widget.
  final EdgeInsets? padding;

  /// Applies margin around waveform widget.
  final EdgeInsets? margin;

  /// Box decoration containing waveforms
  final BoxDecoration? decoration;

  /// If only background color needs to be changed then use this instead of
  /// decoration.
  final Color? backgroundColor;

  /// An icon for recording voice.
  final Widget? micIcon;

  /// An icon for stopping voice recording.
  final Widget? stopIcon;

  /// Applies color to mic and stop icon.
  final Color? recorderIconColor;

  /// The sample rate for audio is measured in samples per second.
  /// A higher sample rate generates more samples per second,
  /// resulting in better audio quality but also larger file sizes.
  final int? sampleRate;

  /// Bitrate is the amount of data per second that the codec uses to
  /// encode the audio. A higher bitrate results in better quality
  /// but also larger file sizes.
  final int? bitRate;

  /// Audio encoder to be used for recording for IOS.
  final IosEncoder? iosEncoder;

  /// Audio encoder to be used for recording for Android.
  final AndroidEncoder? androidEncoder;

  /// The audio output format to be used for recorded audio files on Android.
  final AndroidOutputFormat? androidOutputFormat;
}

class CancelRecordConfiguration {
  /// Configuration for cancel voice recording
  const CancelRecordConfiguration({
    this.icon,
    this.iconColor,
    this.onCancel,
  });

  /// An icon for cancelling voice recording.
  final Widget? icon;

  /// Cancel record icon color
  final Color? iconColor;

  /// Provides callback on voice record cancel
  final VoidCallback? onCancel;
}



===== FILE: vendor\chatview\src\models\config_models\suggestion_list_config.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';

import '../../values/enumeration.dart';

class SuggestionListConfig {
  const SuggestionListConfig({
    this.decoration,
    this.padding,
    this.margin,
    this.axisAlignment = SuggestionListAlignment.right,
    this.itemSeparatorWidth = 8,
  });

  /// Provides decoration for the suggestion list
  final BoxDecoration? decoration;

  /// Padding for the suggestion list
  final EdgeInsets? padding;

  /// Margin for the suggestion list
  final EdgeInsets? margin;

  /// Separator width of the item in the suggestion list
  final double itemSeparatorWidth;

  /// Alignment of the suggestion list items
  final SuggestionListAlignment axisAlignment;
}



===== FILE: vendor\chatview\src\models\config_models\swipe_to_reply_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../../values/typedefs.dart';

class SwipeToReplyConfiguration {
  const SwipeToReplyConfiguration({
    this.replyIconColor,
    this.replyIconProgressRingColor,
    this.replyIconBackgroundColor,
    this.onRightSwipe,
    this.onLeftSwipe,
  });

  /// Used to give color of reply icon while swipe to reply.
  final Color? replyIconColor;

  /// Used to give color of circular progress around reply icon while swipe to reply.
  final Color? replyIconProgressRingColor;

  /// Used to give color of reply icon background when swipe to reply reach swipe limit.
  final Color? replyIconBackgroundColor;

  /// Provides callback when user swipe chat bubble from left side.
  final OnMessageSwipeCallback? onLeftSwipe;

  /// Provides callback when user swipe chat bubble from right side.
  final OnMessageSwipeCallback? onRightSwipe;
}



===== FILE: vendor\chatview\src\models\config_models\type_indicator_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

class TypeIndicatorConfiguration {
  const TypeIndicatorConfiguration({
    this.indicatorSize,
    this.indicatorSpacing,
    this.flashingCircleDarkColor,
    this.flashingCircleBrightColor,
  });

  /// Used for giving typing indicator size.
  final double? indicatorSize;

  /// Used for giving spacing between indicator dots.
  final double? indicatorSpacing;

  /// Used to give color of dark circle dots.
  final Color? flashingCircleDarkColor;

  /// Used to give color of light circle dots.
  final Color? flashingCircleBrightColor;
}



===== FILE: vendor\chatview\src\models\config_models\voice_message_configuration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:audio_waveforms/audio_waveforms.dart';
import 'package:flutter/material.dart';

/// A configuration model class for voice message bubble.
class VoiceMessageConfiguration {
  const VoiceMessageConfiguration({
    this.playerWaveStyle,
    this.padding = const EdgeInsets.symmetric(horizontal: 8),
    this.margin,
    this.decoration,
    this.animationCurve,
    this.animationDuration,
    this.pauseIcon,
    this.playIcon,
    this.waveformMargin,
    this.waveformPadding,
    this.enableSeekGesture = true,
  });

  /// Applies style to waveform.
  final PlayerWaveStyle? playerWaveStyle;

  /// Applies padding to message bubble.
  final EdgeInsets padding;

  /// Applies margin to message bubble.
  final EdgeInsets? margin;

  /// Applies padding to waveform.
  final EdgeInsets? waveformPadding;

  /// Applies padding to waveform.
  final EdgeInsets? waveformMargin;

  /// BoxDecoration for voice message bubble.
  final BoxDecoration? decoration;

  /// Duration for grow animation for waveform. Default to 500 ms.
  final Duration? animationDuration;

  /// Curve for for grow animation for waveform. Default to Curve.easeIn.
  final Curve? animationCurve;

  /// Icon for playing the audio.
  final Icon? playIcon;

  /// Icon for pausing audio
  final Icon? pauseIcon;

  /// Enable/disable seeking with gestures. Enabled by default.
  final bool enableSeekGesture;
}



===== FILE: vendor\chatview\src\models\models.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
export 'chat_bubble.dart';
export 'config_models/image_message_configuration.dart';
export 'config_models/message_reaction_configuration.dart';
export 'config_models/profile_circle_configuration.dart';
export 'config_models/chat_bubble_configuration.dart';
export 'config_models/replied_message_configuration.dart';
export 'config_models/swipe_to_reply_configuration.dart';
export 'config_models/reply_popup_configuration.dart';
export 'config_models/reaction_popup_configuration.dart';
export 'config_models/message_list_configuration.dart';
export 'config_models/emoji_message_configuration.dart';
export 'config_models/message_configuration.dart';
export 'config_models/send_message_configuration.dart';
export 'config_models/link_preview_configuration.dart';
export 'config_models/type_indicator_configuration.dart';
export 'config_models/chat_view_states_configuration.dart';
export 'config_models/replied_msg_auto_scroll_config.dart';
export 'config_models/feature_active_config.dart';
export 'config_models/reply_suggestions_config.dart';
export 'config_models/suggestion_list_config.dart';
export 'config_models/scroll_to_bottom_button_config.dart';
export 'config_models/voice_message_configuration.dart';



===== FILE: vendor\chatview\src\utils\chat_view_locale.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/// Class representing all localizable strings for ChatView package.
final class ChatViewLocale {
  const ChatViewLocale({
    required this.today,
    required this.yesterday,
    required this.repliedToYou,
    required this.repliedBy,
    required this.more,
    required this.unsend,
    required this.reply,
    required this.replyTo,
    required this.message,
    required this.reactionPopupTitle,
    required this.photo,
    required this.send,
    required this.you,
    required this.report,
    required this.noMessage,
    required this.somethingWentWrong,
    required this.reload,
  });

  /// Create from Map
  factory ChatViewLocale.fromMap(Map<String, String> map) {
    return ChatViewLocale(
      today: map['today']?.toString() ?? '',
      yesterday: map['yesterday']?.toString() ?? '',
      repliedToYou: map['repliedToYou']?.toString() ?? '',
      repliedBy: map['repliedBy']?.toString() ?? '',
      more: map['more']?.toString() ?? '',
      unsend: map['unsend']?.toString() ?? '',
      reply: map['reply']?.toString() ?? '',
      replyTo: map['replyTo']?.toString() ?? '',
      message: map['message']?.toString() ?? '',
      reactionPopupTitle: map['reactionPopupTitle']?.toString() ?? '',
      photo: map['photo']?.toString() ?? '',
      send: map['send']?.toString() ?? '',
      you: map['you']?.toString() ?? '',
      report: map['report']?.toString() ?? '',
      noMessage: map['noMessage']?.toString() ?? '',
      somethingWentWrong: map['somethingWentWrong']?.toString() ?? '',
      reload: map['reload']?.toString() ?? '',
    );
  }

  final String today;
  final String yesterday;
  final String repliedToYou;
  final String repliedBy;
  final String more;
  final String unsend;
  final String reply;
  final String replyTo;
  final String message;
  final String reactionPopupTitle;
  final String photo;
  final String send;
  final String you;
  final String report;
  final String noMessage;
  final String somethingWentWrong;
  final String reload;

  /// English defaults
  static const en = ChatViewLocale(
    today: 'Today',
    yesterday: 'Yesterday',
    repliedToYou: 'Replied to you',
    repliedBy: 'Replied by',
    more: 'More',
    unsend: 'Unsend',
    reply: 'Reply',
    replyTo: 'Replying to',
    message: 'Message',
    reactionPopupTitle: 'Tap and hold to multiply your reaction',
    photo: 'Photo',
    send: 'Send',
    you: 'You',
    report: 'Report',
    noMessage: 'No message',
    somethingWentWrong: 'Something went wrong !!',
    reload: 'Reload',
  );
}



===== FILE: vendor\chatview\src\utils\constants\constants.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../../widgets/chat_message_sending_to_sent_animation.dart';
import '../timeago/timeago.dart' as timeago;

const String imageUrlRegExpression =
    r'(http(s?):)([/|.|\w|\s|-])*\.(?:jpg|gif|png|jpeg)';
const String dateFormat = "yyyy-MM-dd";
const String couldNotLaunch = "Could not launch";
const String heart = "\u{2764}";
const String faceWithTears = "\u{1F602}";
const String disappointedFace = "\u{1F625}";
const String angryFace = "\u{1F621}";
const String astonishedFace = "\u{1F632}";
const String thumbsUp = "\u{1F44D}";
const double bottomPadding1 = 10;
const double bottomPadding2 = 22;
const double bottomPadding3 = 12;
const double bottomPadding4 = 6;
const double leftPadding = 9;
const double maxWidth = 350;
const int opacity = 18;
const double verticalPadding = 4.0;
const double leftPadding2 = 5;
const double horizontalPadding = 6;
const double replyBorderRadius1 = 30;
const double replyBorderRadius2 = 18;
const double leftPadding3 = 12;
const double textFieldBorderRadius = 27;
const String defaultChatSeparatorDatePattern = 'MMM dd, yyyy';
const double defaultChatTextFieldHeight = 10.0;

applicationDateFormatter(DateTime inputTime) {
  if (DateTime.now().difference(inputTime).inDays <= 3) {
    return timeago.format(inputTime);
  } else {
    return DateFormat('dd MMM yyyy').format(inputTime);
  }
}

/// Default widget that appears on receipts at [MessageStatus.pending] when a message
/// is not sent or at the pending state. A custom implementation can have different
/// widgets for different states.
/// Right now it is implemented to appear right next to the outgoing bubble.
Widget sendMessageAnimationBuilder(MessageStatus status) {
  return SendingMessageAnimatingWidget(status);
}

/// Default builder when the message has got seen as of now
/// is visible at the bottom of the chat bubble
Widget lastSeenAgoBuilder(Message message, String formattedDate) {
  return Padding(
    padding: const EdgeInsets.all(2),
    child: Text(
      'Seen ${applicationDateFormatter(message.createdAt)}    ',
      style: const TextStyle(color: Colors.grey, fontSize: 12),
    ),
  );
}

const suggestionListAnimationDuration = Duration(milliseconds: 200);



===== FILE: vendor\chatview\src\utils\debounce.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'dart:async';

import 'package:flutter/material.dart';

class Debouncer {
  Timer? _debounce;
  Duration duration;

  Debouncer(this.duration);

  void run(VoidCallback callbackAfterTimeLapsed,
      VoidCallback callbackBeforeTimeLapsed) {
    if (_debounce?.isActive ?? false) {
      callbackBeforeTimeLapsed();
      _debounce?.cancel();
    }
    _debounce = Timer(duration, callbackAfterTimeLapsed);
  }

  void dispose() {
    _debounce?.cancel();
  }
}



===== FILE: vendor\chatview\src\utils\emoji_parser.dart =====
import 'dart:convert';

import 'package:flutter/widgets.dart';

/// This is code is take from the https://github.com/petehouston/flutter-emoji/blob/master/lib/flutter_emoji.dart
/// All Credit of below class goes to @petehouston flutter_emoji
///
/// Constants defined for Emoji.
///
class EmojiConst {
  static final String charNonSpacingMark = String.fromCharCode(0xfe0f);
  static const String charColon = ':';
  static const String charEmpty = '';
}

/// List of pre-defined message used in this library
class EmojiMessage {
  static const String errorMalformedEmojiName = 'Malformed emoji name';
}

///
/// Utilities to handle emoji operations.
///
class EmojiUtil {
  ///
  /// Strip colons for emoji name.
  /// So, ':heart:' will become 'heart'.
  ///
  static String? stripColons(String? name,
      [void Function(String message)? onError]) {
    if (name == null) {
      return null;
    }
    Iterable<Match> matches = EmojiParser.regexName.allMatches(name);
    if (matches.isEmpty) {
      if (onError != null) {
        onError(EmojiMessage.errorMalformedEmojiName);
      }
      return name;
    }
    return name.replaceAll(EmojiConst.charColon, EmojiConst.charEmpty);
  }

  ///
  /// Wrap colons on both sides of emoji name.
  /// So, 'heart' will become ':heart:'.
  ///
  static String ensureColons(String name) {
    var res = name;
    if (name[0] != EmojiConst.charColon) {
      res = EmojiConst.charColon + name;
    }

    if (!name.endsWith(EmojiConst.charColon)) {
      res += EmojiConst.charColon;
    }

    return res;
  }

  ///
  /// When processing emojis, we don't need to store the graphical byte
  /// which is 0xfe0f, or so-called 'Non-Spacing Mark'.
  ///
  static String? stripNSM(String? name) => name?.replaceAll(
      RegExp(EmojiConst.charNonSpacingMark), EmojiConst.charEmpty);
}

///
/// The representation of an emoji.
/// There are three properties availables:
///   - 'name' : the emoji name (no colon)
///   - 'full' : the full emoji name. It is name with colons on both sides.
///   - 'code' : the actual graphic presentation of emoji.
///
/// Emoji.None is being used to represent a NULL emoji.
///
class Emoji {
  ///
  /// If emoji not found, the parser always returns this.
  ///
  static final Emoji none = Emoji(EmojiConst.charEmpty, EmojiConst.charEmpty);

  final String name;
  final String code;

  Emoji(this.name, this.code);

  String get full => EmojiUtil.ensureColons(name);

  @override
  bool operator ==(other) {
    return other is Emoji && name == other.name && code == other.code;
  }

  Emoji clone() {
    return Emoji(name, code);
  }

  @override
  String toString() {
    return 'Emoji{name="$name", full="$full", code="$code"}';
  }

  @override
  int get hashCode => name.hashCode;
}

///
/// Emoji storage and parser.
/// You will need to instantiate one of this instance to start using.
///
class EmojiParser {
  static final RegExp regexName = RegExp(r':([\w-+]+):');

  ///
  /// Data source for Emoji.
  ///
  /// Reference: https://raw.githubusercontent.com/omnidan/node-emoji/master/lib/emoji.json
  ///
  static const emojiSource =
      'https://raw.githubusercontent.com/omnidan/node-emoji/master/lib/emoji.json';
  static const String jsonEmoji =
      '{"100":"рџ’Ї","1234":"рџ”ў","umbrella_with_rain_drops":"в”","coffee":"в•","aries":"в™€","taurus":"в™‰","sagittarius":"в™ђ","capricorn":"в™‘","aquarius":"в™’","pisces":"в™“","anchor":"вљ“","white_check_mark":"вњ…","sparkles":"вњЁ","question":"вќ“","grey_question":"вќ”","grey_exclamation":"вќ•","exclamation":"вќ—","heavy_exclamation_mark":"вќ—","heavy_plus_sign":"вћ•","heavy_minus_sign":"вћ–","heavy_division_sign":"вћ—","hash":"#пёЏвѓЈ","keycap_star":"*пёЏвѓЈ","zero":"0пёЏвѓЈ","one":"1пёЏвѓЈ","two":"2пёЏвѓЈ","three":"3пёЏвѓЈ","four":"4пёЏвѓЈ","five":"5пёЏвѓЈ","six":"6пёЏвѓЈ","seven":"7пёЏвѓЈ","eight":"8пёЏвѓЈ","nine":"9пёЏвѓЈ","copyright":"В©пёЏ","registered":"В®пёЏ","mahjong":"рџЂ„","black_joker":"рџѓЏ","a":"рџ…°пёЏ","b":"рџ…±пёЏ","o2":"рџ…ѕпёЏ","parking":"рџ…їпёЏ","ab":"рџ†Ћ","cl":"рџ†‘","cool":"рџ†’","free":"рџ†“","id":"рџ†”","new":"рџ†•","ng":"рџ†–","ok":"рџ†—","sos":"рџ†","up":"рџ†™","vs":"рџ†љ","flag-ac":"рџ‡¦рџ‡Ё","flag-ad":"рџ‡¦рџ‡©","flag-ae":"рџ‡¦рџ‡Є","flag-af":"рџ‡¦рџ‡«","flag-ag":"рџ‡¦рџ‡¬","flag-ai":"рџ‡¦рџ‡®","flag-al":"рџ‡¦рџ‡±","flag-am":"рџ‡¦рџ‡І","flag-ao":"рџ‡¦рџ‡ґ","flag-aq":"рџ‡¦рџ‡¶","flag-ar":"рџ‡¦рџ‡·","flag-as":"рџ‡¦рџ‡ё","flag-at":"рџ‡¦рџ‡№","flag-au":"рџ‡¦рџ‡є","flag-aw":"рџ‡¦рџ‡ј","flag-ax":"рџ‡¦рџ‡Ѕ","flag-az":"рџ‡¦рџ‡ї","flag-ba":"рџ‡§рџ‡¦","flag-bb":"рџ‡§рџ‡§","flag-bd":"рџ‡§рџ‡©","flag-be":"рџ‡§рџ‡Є","flag-bf":"рџ‡§рџ‡«","flag-bg":"рџ‡§рџ‡¬","flag-bh":"рџ‡§рџ‡­","flag-bi":"рџ‡§рџ‡®","flag-bj":"рџ‡§рџ‡Ї","flag-bl":"рџ‡§рџ‡±","flag-bm":"рџ‡§рџ‡І","flag-bn":"рџ‡§рџ‡і","flag-bo":"рџ‡§рџ‡ґ","flag-bq":"рџ‡§рџ‡¶","flag-br":"рџ‡§рџ‡·","flag-bs":"рџ‡§рџ‡ё","flag-bt":"рџ‡§рџ‡№","flag-bv":"рџ‡§рџ‡»","flag-bw":"рџ‡§рџ‡ј","flag-by":"рџ‡§рџ‡ѕ","flag-bz":"рџ‡§рџ‡ї","flag-ca":"рџ‡Ёрџ‡¦","flag-cc":"рџ‡Ёрџ‡Ё","flag-cd":"рџ‡Ёрџ‡©","flag-cf":"рџ‡Ёрџ‡«","flag-cg":"рџ‡Ёрџ‡¬","flag-ch":"рџ‡Ёрџ‡­","flag-ci":"рџ‡Ёрџ‡®","flag-ck":"рџ‡Ёрџ‡°","flag-cl":"рџ‡Ёрџ‡±","flag-cm":"рџ‡Ёрџ‡І","cn":"рџ‡Ёрџ‡і","flag-cn":"рџ‡Ёрџ‡і","flag-co":"рџ‡Ёрџ‡ґ","flag-cp":"рџ‡Ёрџ‡µ","flag-cr":"рџ‡Ёрџ‡·","flag-cu":"рџ‡Ёрџ‡є","flag-cv":"рџ‡Ёрџ‡»","flag-cw":"рџ‡Ёрџ‡ј","flag-cx":"рџ‡Ёрџ‡Ѕ","flag-cy":"рџ‡Ёрџ‡ѕ","flag-cz":"рџ‡Ёрџ‡ї","de":"рџ‡©рџ‡Є","flag-de":"рџ‡©рџ‡Є","flag-dg":"рџ‡©рџ‡¬","flag-dj":"рџ‡©рџ‡Ї","flag-dk":"рџ‡©рџ‡°","flag-dm":"рџ‡©рџ‡І","flag-do":"рџ‡©рџ‡ґ","flag-dz":"рџ‡©рџ‡ї","flag-ea":"рџ‡Єрџ‡¦","flag-ec":"рџ‡Єрџ‡Ё","flag-ee":"рџ‡Єрџ‡Є","flag-eg":"рџ‡Єрџ‡¬","flag-eh":"рџ‡Єрџ‡­","flag-er":"рџ‡Єрџ‡·","es":"рџ‡Єрџ‡ё","flag-es":"рџ‡Єрџ‡ё","flag-et":"рџ‡Єрџ‡№","flag-eu":"рџ‡Єрџ‡є","flag-fi":"рџ‡«рџ‡®","flag-fj":"рџ‡«рџ‡Ї","flag-fk":"рџ‡«рџ‡°","flag-fm":"рџ‡«рџ‡І","flag-fo":"рџ‡«рџ‡ґ","fr":"рџ‡«рџ‡·","flag-fr":"рџ‡«рџ‡·","flag-ga":"рџ‡¬рџ‡¦","gb":"рџ‡¬рџ‡§","uk":"рџ‡¬рџ‡§","flag-gb":"рџ‡¬рџ‡§","flag-gd":"рџ‡¬рџ‡©","flag-ge":"рџ‡¬рџ‡Є","flag-gf":"рџ‡¬рџ‡«","flag-gg":"рџ‡¬рџ‡¬","flag-gh":"рџ‡¬рџ‡­","flag-gi":"рџ‡¬рџ‡®","flag-gl":"рџ‡¬рџ‡±","flag-gm":"рџ‡¬рџ‡І","flag-gn":"рџ‡¬рџ‡і","flag-gp":"рџ‡¬рџ‡µ","flag-gq":"рџ‡¬рџ‡¶","flag-gr":"рџ‡¬рџ‡·","flag-gs":"рџ‡¬рџ‡ё","flag-gt":"рџ‡¬рџ‡№","flag-gu":"рџ‡¬рџ‡є","flag-gw":"рџ‡¬рџ‡ј","flag-gy":"рџ‡¬рџ‡ѕ","flag-hk":"рџ‡­рџ‡°","flag-hm":"рџ‡­рџ‡І","flag-hn":"рџ‡­рџ‡і","flag-hr":"рџ‡­рџ‡·","flag-ht":"рџ‡­рџ‡№","flag-hu":"рџ‡­рџ‡є","flag-ic":"рџ‡®рџ‡Ё","flag-id":"рџ‡®рџ‡©","flag-ie":"рџ‡®рџ‡Є","flag-il":"рџ‡®рџ‡±","flag-im":"рџ‡®рџ‡І","flag-in":"рџ‡®рџ‡і","flag-io":"рџ‡®рџ‡ґ","flag-iq":"рџ‡®рџ‡¶","flag-ir":"рџ‡®рџ‡·","flag-is":"рџ‡®рџ‡ё","it":"рџ‡®рџ‡№","flag-it":"рџ‡®рџ‡№","flag-je":"рџ‡Їрџ‡Є","flag-jm":"рџ‡Їрџ‡І","flag-jo":"рџ‡Їрџ‡ґ","jp":"рџ‡Їрџ‡µ","flag-jp":"рџ‡Їрџ‡µ","flag-ke":"рџ‡°рџ‡Є","flag-kg":"рџ‡°рџ‡¬","flag-kh":"рџ‡°рџ‡­","flag-ki":"рџ‡°рџ‡®","flag-km":"рџ‡°рџ‡І","flag-kn":"рџ‡°рџ‡і","flag-kp":"рџ‡°рџ‡µ","kr":"рџ‡°рџ‡·","flag-kr":"рџ‡°рџ‡·","flag-kw":"рџ‡°рџ‡ј","flag-ky":"рџ‡°рџ‡ѕ","flag-kz":"рџ‡°рџ‡ї","flag-la":"рџ‡±рџ‡¦","flag-lb":"рџ‡±рџ‡§","flag-lc":"рџ‡±рџ‡Ё","flag-li":"рџ‡±рџ‡®","flag-lk":"рџ‡±рџ‡°","flag-lr":"рџ‡±рџ‡·","flag-ls":"рџ‡±рџ‡ё","flag-lt":"рџ‡±рџ‡№","flag-lu":"рџ‡±рџ‡є","flag-lv":"рџ‡±рџ‡»","flag-ly":"рџ‡±рџ‡ѕ","flag-ma":"рџ‡Ірџ‡¦","flag-mc":"рџ‡Ірџ‡Ё","flag-md":"рџ‡Ірџ‡©","flag-me":"рџ‡Ірџ‡Є","flag-mf":"рџ‡Ірџ‡«","flag-mg":"рџ‡Ірџ‡¬","flag-mh":"рџ‡Ірџ‡­","flag-mk":"рџ‡Ірџ‡°","flag-ml":"рџ‡Ірџ‡±","flag-mm":"рџ‡Ірџ‡І","flag-mn":"рџ‡Ірџ‡і","flag-mo":"рџ‡Ірџ‡ґ","flag-mp":"рџ‡Ірџ‡µ","flag-mq":"рџ‡Ірџ‡¶","flag-mr":"рџ‡Ірџ‡·","flag-ms":"рџ‡Ірџ‡ё","flag-mt":"рџ‡Ірџ‡№","flag-mu":"рџ‡Ірџ‡є","flag-mv":"рџ‡Ірџ‡»","flag-mw":"рџ‡Ірџ‡ј","flag-mx":"рџ‡Ірџ‡Ѕ","flag-my":"рџ‡Ірџ‡ѕ","flag-mz":"рџ‡Ірџ‡ї","flag-na":"рџ‡ірџ‡¦","flag-nc":"рџ‡ірџ‡Ё","flag-ne":"рџ‡ірџ‡Є","flag-nf":"рџ‡ірџ‡«","flag-ng":"рџ‡ірџ‡¬","flag-ni":"рџ‡ірџ‡®","flag-nl":"рџ‡ірџ‡±","flag-no":"рџ‡ірџ‡ґ","flag-np":"рџ‡ірџ‡µ","flag-nr":"рџ‡ірџ‡·","flag-nu":"рџ‡ірџ‡є","flag-nz":"рџ‡ірџ‡ї","flag-om":"рџ‡ґрџ‡І","flag-pa":"рџ‡µрџ‡¦","flag-pe":"рџ‡µрџ‡Є","flag-pf":"рџ‡µрџ‡«","flag-pg":"рџ‡µрџ‡¬","flag-ph":"рџ‡µрџ‡­","flag-pk":"рџ‡µрџ‡°","flag-pl":"рџ‡µрџ‡±","flag-pm":"рџ‡µрџ‡І","flag-pn":"рџ‡µрџ‡і","flag-pr":"рџ‡µрџ‡·","flag-ps":"рџ‡µрџ‡ё","flag-pt":"рџ‡µрџ‡№","flag-pw":"рџ‡µрџ‡ј","flag-py":"рџ‡µрџ‡ѕ","flag-qa":"рџ‡¶рџ‡¦","flag-re":"рџ‡·рџ‡Є","flag-ro":"рџ‡·рџ‡ґ","flag-rs":"рџ‡·рџ‡ё","ru":"рџ‡·рџ‡є","flag-ru":"рџ‡·рџ‡є","flag-rw":"рџ‡·рџ‡ј","flag-sa":"рџ‡ёрџ‡¦","flag-sb":"рџ‡ёрџ‡§","flag-sc":"рџ‡ёрџ‡Ё","flag-sd":"рџ‡ёрџ‡©","flag-se":"рџ‡ёрџ‡Є","flag-sg":"рџ‡ёрџ‡¬","flag-sh":"рџ‡ёрџ‡­","flag-si":"рџ‡ёрџ‡®","flag-sj":"рџ‡ёрџ‡Ї","flag-sk":"рџ‡ёрџ‡°","flag-sl":"рџ‡ёрџ‡±","flag-sm":"рџ‡ёрџ‡І","flag-sn":"рџ‡ёрџ‡і","flag-so":"рџ‡ёрџ‡ґ","flag-sr":"рџ‡ёрџ‡·","flag-ss":"рџ‡ёрџ‡ё","flag-st":"рџ‡ёрџ‡№","flag-sv":"рџ‡ёрџ‡»","flag-sx":"рџ‡ёрџ‡Ѕ","flag-sy":"рџ‡ёрџ‡ѕ","flag-sz":"рџ‡ёрџ‡ї","flag-ta":"рџ‡№рџ‡¦","flag-tc":"рџ‡№рџ‡Ё","flag-td":"рџ‡№рџ‡©","flag-tf":"рџ‡№рџ‡«","flag-tg":"рџ‡№рџ‡¬","flag-th":"рџ‡№рџ‡­","flag-tj":"рџ‡№рџ‡Ї","flag-tk":"рџ‡№рџ‡°","flag-tl":"рџ‡№рџ‡±","flag-tm":"рџ‡№рџ‡І","flag-tn":"рџ‡№рџ‡і","flag-to":"рџ‡№рџ‡ґ","flag-tr":"рџ‡№рџ‡·","flag-tt":"рџ‡№рџ‡№","flag-tv":"рџ‡№рџ‡»","flag-tw":"рџ‡№рџ‡ј","flag-tz":"рџ‡№рџ‡ї","flag-ua":"рџ‡єрџ‡¦","flag-ug":"рџ‡єрџ‡¬","flag-um":"рџ‡єрџ‡І","flag-un":"рџ‡єрџ‡і","us":"рџ‡єрџ‡ё","flag-us":"рџ‡єрџ‡ё","flag-uy":"рџ‡єрџ‡ѕ","flag-uz":"рџ‡єрџ‡ї","flag-va":"рџ‡»рџ‡¦","flag-vc":"рџ‡»рџ‡Ё","flag-ve":"рџ‡»рџ‡Є","flag-vg":"рџ‡»рџ‡¬","flag-vi":"рџ‡»рџ‡®","flag-vn":"рџ‡»рџ‡і","flag-vu":"рџ‡»рџ‡є","flag-wf":"рџ‡јрџ‡«","flag-ws":"рџ‡јрџ‡ё","flag-xk":"рџ‡Ѕрџ‡°","flag-ye":"рџ‡ѕрџ‡Є","flag-yt":"рџ‡ѕрџ‡№","flag-za":"рџ‡їрџ‡¦","flag-zm":"рџ‡їрџ‡І","flag-zw":"рџ‡їрџ‡ј","koko":"рџ€Ѓ","sa":"рџ€‚пёЏ","u7121":"рџ€љ","u6307":"рџ€Ї","u7981":"рџ€І","u7a7a":"рџ€і","u5408":"рџ€ґ","u6e80":"рџ€µ","u6709":"рџ€¶","u6708":"рџ€·пёЏ","u7533":"рџ€ё","u5272":"рџ€№","u55b6":"рџ€є","ideograph_advantage":"рџ‰ђ","accept":"рџ‰‘","cyclone":"рџЊЂ","foggy":"рџЊЃ","closed_umbrella":"рџЊ‚","night_with_stars":"рџЊѓ","sunrise_over_mountains":"рџЊ„","sunrise":"рџЊ…","city_sunset":"рџЊ†","city_sunrise":"рџЊ‡","rainbow":"рџЊ€","bridge_at_night":"рџЊ‰","ocean":"рџЊЉ","volcano":"рџЊ‹","milky_way":"рџЊЊ","earth_africa":"рџЊЌ","earth_americas":"рџЊЋ","earth_asia":"рџЊЏ","globe_with_meridians":"рџЊђ","new_moon":"рџЊ‘","waxing_crescent_moon":"рџЊ’","first_quarter_moon":"рџЊ“","moon":"рџЊ”","waxing_gibbous_moon":"рџЊ”","full_moon":"рџЊ•","waning_gibbous_moon":"рџЊ–","last_quarter_moon":"рџЊ—","waning_crescent_moon":"рџЊ","crescent_moon":"рџЊ™","new_moon_with_face":"рџЊљ","first_quarter_moon_with_face":"рџЊ›","last_quarter_moon_with_face":"рџЊњ","full_moon_with_face":"рџЊќ","sun_with_face":"рџЊћ","star2":"рџЊџ","stars":"рџЊ ","thermometer":"рџЊЎпёЏ","mostly_sunny":"рџЊ¤пёЏ","sun_small_cloud":"рџЊ¤пёЏ","barely_sunny":"рџЊҐпёЏ","sun_behind_cloud":"рџЊҐпёЏ","partly_sunny_rain":"рџЊ¦пёЏ","sun_behind_rain_cloud":"рџЊ¦пёЏ","rain_cloud":"рџЊ§пёЏ","snow_cloud":"рџЊЁпёЏ","lightning":"рџЊ©пёЏ","lightning_cloud":"рџЊ©пёЏ","tornado":"рџЊЄпёЏ","tornado_cloud":"рџЊЄпёЏ","fog":"рџЊ«пёЏ","wind_blowing_face":"рџЊ¬пёЏ","hotdog":"рџЊ­","taco":"рџЊ®","burrito":"рџЊЇ","chestnut":"рџЊ°","seedling":"рџЊ±","evergreen_tree":"рџЊІ","deciduous_tree":"рџЊі","palm_tree":"рџЊґ","cactus":"рџЊµ","hot_pepper":"рџЊ¶пёЏ","tulip":"рџЊ·","cherry_blossom":"рџЊё","rose":"рџЊ№","hibiscus":"рџЊє","sunflower":"рџЊ»","blossom":"рџЊј","corn":"рџЊЅ","ear_of_rice":"рџЊѕ","herb":"рџЊї","four_leaf_clover":"рџЌЂ","maple_leaf":"рџЌЃ","fallen_leaf":"рџЌ‚","leaves":"рџЌѓ","mushroom":"рџЌ„","tomato":"рџЌ…","eggplant":"рџЌ†","grapes":"рџЌ‡","melon":"рџЌ€","watermelon":"рџЌ‰","tangerine":"рџЌЉ","lemon":"рџЌ‹","banana":"рџЌЊ","pineapple":"рџЌЌ","apple":"рџЌЋ","green_apple":"рџЌЏ","pear":"рџЌђ","peach":"рџЌ‘","cherries":"рџЌ’","strawberry":"рџЌ“","hamburger":"рџЌ”","pizza":"рџЌ•","meat_on_bone":"рџЌ–","poultry_leg":"рџЌ—","rice_cracker":"рџЌ","rice_ball":"рџЌ™","rice":"рџЌљ","curry":"рџЌ›","ramen":"рџЌњ","spaghetti":"рџЌќ","bread":"рџЌћ","fries":"рџЌџ","sweet_potato":"рџЌ ","dango":"рџЌЎ","oden":"рџЌў","sushi":"рџЌЈ","fried_shrimp":"рџЌ¤","fish_cake":"рџЌҐ","icecream":"рџЌ¦","shaved_ice":"рџЌ§","ice_cream":"рџЌЁ","doughnut":"рџЌ©","cookie":"рџЌЄ","chocolate_bar":"рџЌ«","candy":"рџЌ¬","lollipop":"рџЌ­","custard":"рџЌ®","honey_pot":"рџЌЇ","cake":"рџЌ°","bento":"рџЌ±","stew":"рџЌІ","fried_egg":"рџЌі","cooking":"рџЌі","fork_and_knife":"рџЌґ","tea":"рџЌµ","sake":"рџЌ¶","wine_glass":"рџЌ·","cocktail":"рџЌё","tropical_drink":"рџЌ№","beer":"рџЌє","beers":"рџЌ»","baby_bottle":"рџЌј","knife_fork_plate":"рџЌЅпёЏ","champagne":"рџЌѕ","popcorn":"рџЌї","ribbon":"рџЋЂ","gift":"рџЋЃ","birthday":"рџЋ‚","jack_o_lantern":"рџЋѓ","christmas_tree":"рџЋ„","santa":"рџЋ…","fireworks":"рџЋ†","sparkler":"рџЋ‡","balloon":"рџЋ€","tada":"рџЋ‰","confetti_ball":"рџЋЉ","tanabata_tree":"рџЋ‹","crossed_flags":"рџЋЊ","bamboo":"рџЋЌ","dolls":"рџЋЋ","flags":"рџЋЏ","wind_chime":"рџЋђ","rice_scene":"рџЋ‘","school_satchel":"рџЋ’","mortar_board":"рџЋ“","medal":"рџЋ–пёЏ","reminder_ribbon":"рџЋ—пёЏ","studio_microphone":"рџЋ™пёЏ","level_slider":"рџЋљпёЏ","control_knobs":"рџЋ›пёЏ","film_frames":"рџЋћпёЏ","admission_tickets":"рџЋџпёЏ","carousel_horse":"рџЋ ","ferris_wheel":"рџЋЎ","roller_coaster":"рџЋў","fishing_pole_and_fish":"рџЋЈ","microphone":"рџЋ¤","movie_camera":"рџЋҐ","cinema":"рџЋ¦","headphones":"рџЋ§","art":"рџЋЁ","tophat":"рџЋ©","circus_tent":"рџЋЄ","ticket":"рџЋ«","clapper":"рџЋ¬","performing_arts":"рџЋ­","video_game":"рџЋ®","dart":"рџЋЇ","slot_machine":"рџЋ°","8ball":"рџЋ±","game_die":"рџЋІ","bowling":"рџЋі","flower_playing_cards":"рџЋґ","musical_note":"рџЋµ","notes":"рџЋ¶","saxophone":"рџЋ·","guitar":"рџЋё","musical_keyboard":"рџЋ№","trumpet":"рџЋє","violin":"рџЋ»","musical_score":"рџЋј","running_shirt_with_sash":"рџЋЅ","tennis":"рџЋѕ","ski":"рџЋї","basketball":"рџЏЂ","checkered_flag":"рџЏЃ","snowboarder":"рџЏ‚","woman-running":"рџЏѓвЂЌв™ЂпёЏ","man-running":"рџЏѓвЂЌв™‚пёЏ","runner":"рџЏѓвЂЌв™‚пёЏ","running":"рџЏѓвЂЌв™‚пёЏ","woman-surfing":"рџЏ„вЂЌв™ЂпёЏ","man-surfing":"рџЏ„вЂЌв™‚пёЏ","surfer":"рџЏ„вЂЌв™‚пёЏ","sports_medal":"рџЏ…","trophy":"рџЏ†","horse_racing":"рџЏ‡","football":"рџЏ€","rugby_football":"рџЏ‰","woman-swimming":"рџЏЉвЂЌв™ЂпёЏ","man-swimming":"рџЏЉвЂЌв™‚пёЏ","swimmer":"рџЏЉвЂЌв™‚пёЏ","woman-lifting-weights":"рџЏ‹пёЏвЂЌв™ЂпёЏ","man-lifting-weights":"рџЏ‹пёЏвЂЌв™‚пёЏ","weight_lifter":"рџЏ‹пёЏвЂЌв™‚пёЏ","woman-golfing":"рџЏЊпёЏвЂЌв™ЂпёЏ","man-golfing":"рџЏЊпёЏвЂЌв™‚пёЏ","golfer":"рџЏЊпёЏвЂЌв™‚пёЏ","racing_motorcycle":"рџЏЌпёЏ","racing_car":"рџЏЋпёЏ","cricket_bat_and_ball":"рџЏЏ","volleyball":"рџЏђ","field_hockey_stick_and_ball":"рџЏ‘","ice_hockey_stick_and_puck":"рџЏ’","table_tennis_paddle_and_ball":"рџЏ“","snow_capped_mountain":"рџЏ”пёЏ","camping":"рџЏ•пёЏ","beach_with_umbrella":"рџЏ–пёЏ","building_construction":"рџЏ—пёЏ","house_buildings":"рџЏпёЏ","cityscape":"рџЏ™пёЏ","derelict_house_building":"рџЏљпёЏ","classical_building":"рџЏ›пёЏ","desert":"рџЏњпёЏ","desert_island":"рџЏќпёЏ","national_park":"рџЏћпёЏ","stadium":"рџЏџпёЏ","house":"рџЏ ","house_with_garden":"рџЏЎ","office":"рџЏў","post_office":"рџЏЈ","european_post_office":"рџЏ¤","hospital":"рџЏҐ","bank":"рџЏ¦","atm":"рџЏ§","hotel":"рџЏЁ","love_hotel":"рџЏ©","convenience_store":"рџЏЄ","school":"рџЏ«","department_store":"рџЏ¬","factory":"рџЏ­","izakaya_lantern":"рџЏ®","lantern":"рџЏ®","japanese_castle":"рџЏЇ","european_castle":"рџЏ°","rainbow-flag":"рџЏіпёЏвЂЌрџЊ€","transgender_flag":"рџЏіпёЏвЂЌвљ§пёЏ","waving_white_flag":"рџЏіпёЏ","pirate_flag":"рџЏґвЂЌв пёЏ","flag-england":"рџЏґу Ѓ§у Ѓўу ЃҐу Ѓ®у Ѓ§у Ѓї","flag-scotland":"рџЏґу Ѓ§у Ѓўу Ѓіу ЃЈу Ѓґу Ѓї","flag-wales":"рџЏґу Ѓ§у Ѓўу Ѓ·у Ѓ¬у Ѓіу Ѓї","waving_black_flag":"рџЏґ","rosette":"рџЏµпёЏ","label":"рџЏ·пёЏ","badminton_racquet_and_shuttlecock":"рџЏё","bow_and_arrow":"рџЏ№","amphora":"рџЏє","skin-tone-2":"рџЏ»","skin-tone-3":"рџЏј","skin-tone-4":"рџЏЅ","skin-tone-5":"рџЏѕ","skin-tone-6":"рџЏї","rat":"рџђЂ","mouse2":"рџђЃ","ox":"рџђ‚","water_buffalo":"рџђѓ","cow2":"рџђ„","tiger2":"рџђ…","leopard":"рџђ†","rabbit2":"рџђ‡","black_cat":"рџђ€вЂЌв¬›","cat2":"рџђ€","dragon":"рџђ‰","crocodile":"рџђЉ","whale2":"рџђ‹","snail":"рџђЊ","snake":"рџђЌ","racehorse":"рџђЋ","ram":"рџђЏ","goat":"рџђђ","sheep":"рџђ‘","monkey":"рџђ’","rooster":"рџђ“","chicken":"рџђ”","service_dog":"рџђ•вЂЌрџ¦є","dog2":"рџђ•","pig2":"рџђ–","boar":"рџђ—","elephant":"рџђ","octopus":"рџђ™","shell":"рџђљ","bug":"рџђ›","ant":"рџђњ","bee":"рџђќ","honeybee":"рџђќ","ladybug":"рџђћ","lady_beetle":"рџђћ","fish":"рџђџ","tropical_fish":"рџђ ","blowfish":"рџђЎ","turtle":"рџђў","hatching_chick":"рџђЈ","baby_chick":"рџђ¤","hatched_chick":"рџђҐ","bird":"рџђ¦","penguin":"рџђ§","koala":"рџђЁ","poodle":"рџђ©","dromedary_camel":"рџђЄ","camel":"рџђ«","dolphin":"рџђ¬","flipper":"рџђ¬","mouse":"рџђ­","cow":"рџђ®","tiger":"рџђЇ","rabbit":"рџђ°","cat":"рџђ±","dragon_face":"рџђІ","whale":"рџђі","horse":"рџђґ","monkey_face":"рџђµ","dog":"рџђ¶","pig":"рџђ·","frog":"рџђё","hamster":"рџђ№","wolf":"рџђє","polar_bear":"рџђ»вЂЌвќ„пёЏ","bear":"рџђ»","panda_face":"рџђј","pig_nose":"рџђЅ","feet":"рџђѕ","paw_prints":"рџђѕ","chipmunk":"рџђїпёЏ","eyes":"рџ‘Ђ","eye-in-speech-bubble":"рџ‘ЃпёЏвЂЌрџ—ЁпёЏ","eye":"рџ‘ЃпёЏ","ear":"рџ‘‚","nose":"рџ‘ѓ","lips":"рџ‘„","tongue":"рџ‘…","point_up_2":"рџ‘†","point_down":"рџ‘‡","point_left":"рџ‘€","point_right":"рџ‘‰","facepunch":"рџ‘Љ","punch":"рџ‘Љ","wave":"рџ‘‹","ok_hand":"рџ‘Њ","+1":"рџ‘Ќ","thumbsup":"рџ‘Ќ","-1":"рџ‘Ћ","thumbsdown":"рџ‘Ћ","clap":"рџ‘Џ","open_hands":"рџ‘ђ","crown":"рџ‘‘","womans_hat":"рџ‘’","eyeglasses":"рџ‘“","necktie":"рџ‘”","shirt":"рџ‘•","tshirt":"рџ‘•","jeans":"рџ‘–","dress":"рџ‘—","kimono":"рџ‘","bikini":"рџ‘™","womans_clothes":"рџ‘љ","purse":"рџ‘›","handbag":"рџ‘њ","pouch":"рџ‘ќ","mans_shoe":"рџ‘ћ","shoe":"рџ‘ћ","athletic_shoe":"рџ‘џ","high_heel":"рџ‘ ","sandal":"рџ‘Ў","boot":"рџ‘ў","footprints":"рџ‘Ј","bust_in_silhouette":"рџ‘¤","busts_in_silhouette":"рџ‘Ґ","boy":"рџ‘¦","girl":"рџ‘§","male-farmer":"рџ‘ЁвЂЌрџЊѕ","male-cook":"рџ‘ЁвЂЌрџЌі","man_feeding_baby":"рџ‘ЁвЂЌрџЌј","male-student":"рџ‘ЁвЂЌрџЋ“","male-singer":"рџ‘ЁвЂЌрџЋ¤","male-artist":"рџ‘ЁвЂЌрџЋЁ","male-teacher":"рџ‘ЁвЂЌрџЏ«","male-factory-worker":"рџ‘ЁвЂЌрџЏ­","man-boy-boy":"рџ‘ЁвЂЌрџ‘¦вЂЌрџ‘¦","man-boy":"рџ‘ЁвЂЌрџ‘¦","man-girl-boy":"рџ‘ЁвЂЌрџ‘§вЂЌрџ‘¦","man-girl-girl":"рџ‘ЁвЂЌрџ‘§вЂЌрџ‘§","man-girl":"рџ‘ЁвЂЌрџ‘§","man-man-boy":"рџ‘ЁвЂЌрџ‘ЁвЂЌрџ‘¦","man-man-boy-boy":"рџ‘ЁвЂЌрџ‘ЁвЂЌрџ‘¦вЂЌрџ‘¦","man-man-girl":"рџ‘ЁвЂЌрџ‘ЁвЂЌрџ‘§","man-man-girl-boy":"рџ‘ЁвЂЌрџ‘ЁвЂЌрџ‘§вЂЌрџ‘¦","man-man-girl-girl":"рџ‘ЁвЂЌрџ‘ЁвЂЌрџ‘§вЂЌрџ‘§","man-woman-boy":"рџ‘ЁвЂЌрџ‘©вЂЌрџ‘¦","family":"рџ‘ЁвЂЌрџ‘©вЂЌрџ‘¦","man-woman-boy-boy":"рџ‘ЁвЂЌрџ‘©вЂЌрџ‘¦вЂЌрџ‘¦","man-woman-girl":"рџ‘ЁвЂЌрџ‘©вЂЌрџ‘§","man-woman-girl-boy":"рџ‘ЁвЂЌрџ‘©вЂЌрџ‘§вЂЌрџ‘¦","man-woman-girl-girl":"рџ‘ЁвЂЌрџ‘©вЂЌрџ‘§вЂЌрџ‘§","male-technologist":"рџ‘ЁвЂЌрџ’»","male-office-worker":"рџ‘ЁвЂЌрџ’ј","male-mechanic":"рџ‘ЁвЂЌрџ”§","male-scientist":"рџ‘ЁвЂЌрџ”¬","male-astronaut":"рџ‘ЁвЂЌрџљЂ","male-firefighter":"рџ‘ЁвЂЌрџљ’","man_with_probing_cane":"рџ‘ЁвЂЌрџ¦Ї","red_haired_man":"рџ‘ЁвЂЌрџ¦°","curly_haired_man":"рџ‘ЁвЂЌрџ¦±","bald_man":"рџ‘ЁвЂЌрџ¦І","white_haired_man":"рџ‘ЁвЂЌрџ¦і","man_in_motorized_wheelchair":"рџ‘ЁвЂЌрџ¦ј","man_in_manual_wheelchair":"рџ‘ЁвЂЌрџ¦Ѕ","male-doctor":"рџ‘ЁвЂЌвљ•пёЏ","male-judge":"рџ‘ЁвЂЌвљ–пёЏ","male-pilot":"рџ‘ЁвЂЌвњ€пёЏ","man-heart-man":"рџ‘ЁвЂЌвќ¤пёЏвЂЌрџ‘Ё","man-kiss-man":"рџ‘ЁвЂЌвќ¤пёЏвЂЌрџ’‹вЂЌрџ‘Ё","man":"рџ‘Ё","female-farmer":"рџ‘©вЂЌрџЊѕ","female-cook":"рџ‘©вЂЌрџЌі","woman_feeding_baby":"рџ‘©вЂЌрџЌј","female-student":"рџ‘©вЂЌрџЋ“","female-singer":"рџ‘©вЂЌрџЋ¤","female-artist":"рџ‘©вЂЌрџЋЁ","female-teacher":"рџ‘©вЂЌрџЏ«","female-factory-worker":"рџ‘©вЂЌрџЏ­","woman-boy-boy":"рџ‘©вЂЌрџ‘¦вЂЌрџ‘¦","woman-boy":"рџ‘©вЂЌрџ‘¦","woman-girl-boy":"рџ‘©вЂЌрџ‘§вЂЌрџ‘¦","woman-girl-girl":"рџ‘©вЂЌрџ‘§вЂЌрџ‘§","woman-girl":"рџ‘©вЂЌрџ‘§","woman-woman-boy":"рџ‘©вЂЌрџ‘©вЂЌрџ‘¦","woman-woman-boy-boy":"рџ‘©вЂЌрџ‘©вЂЌрџ‘¦вЂЌрџ‘¦","woman-woman-girl":"рџ‘©вЂЌрџ‘©вЂЌрџ‘§","woman-woman-girl-boy":"рџ‘©вЂЌрџ‘©вЂЌрџ‘§вЂЌрџ‘¦","woman-woman-girl-girl":"рџ‘©вЂЌрџ‘©вЂЌрџ‘§вЂЌрџ‘§","female-technologist":"рџ‘©вЂЌрџ’»","female-office-worker":"рџ‘©вЂЌрџ’ј","female-mechanic":"рџ‘©вЂЌрџ”§","female-scientist":"рџ‘©вЂЌрџ”¬","female-astronaut":"рџ‘©вЂЌрџљЂ","female-firefighter":"рџ‘©вЂЌрџљ’","woman_with_probing_cane":"рџ‘©вЂЌрџ¦Ї","red_haired_woman":"рџ‘©вЂЌрџ¦°","curly_haired_woman":"рџ‘©вЂЌрџ¦±","bald_woman":"рџ‘©вЂЌрџ¦І","white_haired_woman":"рџ‘©вЂЌрџ¦і","woman_in_motorized_wheelchair":"рџ‘©вЂЌрџ¦ј","woman_in_manual_wheelchair":"рџ‘©вЂЌрџ¦Ѕ","female-doctor":"рџ‘©вЂЌвљ•пёЏ","female-judge":"рџ‘©вЂЌвљ–пёЏ","female-pilot":"рџ‘©вЂЌвњ€пёЏ","woman-heart-man":"рџ‘©вЂЌвќ¤пёЏвЂЌрџ‘Ё","woman-heart-woman":"рџ‘©вЂЌвќ¤пёЏвЂЌрџ‘©","woman-kiss-man":"рџ‘©вЂЌвќ¤пёЏвЂЌрџ’‹вЂЌрџ‘Ё","woman-kiss-woman":"рџ‘©вЂЌвќ¤пёЏвЂЌрџ’‹вЂЌрџ‘©","woman":"рџ‘©","man_and_woman_holding_hands":"рџ‘«","woman_and_man_holding_hands":"рџ‘«","couple":"рџ‘«","two_men_holding_hands":"рџ‘¬","men_holding_hands":"рџ‘¬","two_women_holding_hands":"рџ‘­","women_holding_hands":"рџ‘­","female-police-officer":"рџ‘®вЂЌв™ЂпёЏ","male-police-officer":"рџ‘®вЂЌв™‚пёЏ","cop":"рџ‘®вЂЌв™‚пёЏ","women-with-bunny-ears-partying":"рџ‘ЇвЂЌв™ЂпёЏ","woman-with-bunny-ears-partying":"рџ‘ЇвЂЌв™ЂпёЏ","dancers":"рџ‘ЇвЂЌв™ЂпёЏ","men-with-bunny-ears-partying":"рџ‘ЇвЂЌв™‚пёЏ","man-with-bunny-ears-partying":"рџ‘ЇвЂЌв™‚пёЏ","woman_with_veil":"рџ‘°вЂЌв™ЂпёЏ","man_with_veil":"рџ‘°вЂЌв™‚пёЏ","bride_with_veil":"рџ‘°","blond-haired-woman":"рџ‘±вЂЌв™ЂпёЏ","blond-haired-man":"рџ‘±вЂЌв™‚пёЏ","person_with_blond_hair":"рџ‘±вЂЌв™‚пёЏ","man_with_gua_pi_mao":"рџ‘І","woman-wearing-turban":"рџ‘івЂЌв™ЂпёЏ","man-wearing-turban":"рџ‘івЂЌв™‚пёЏ","man_with_turban":"рџ‘івЂЌв™‚пёЏ","older_man":"рџ‘ґ","older_woman":"рџ‘µ","baby":"рџ‘¶","female-construction-worker":"рџ‘·вЂЌв™ЂпёЏ","male-construction-worker":"рџ‘·вЂЌв™‚пёЏ","construction_worker":"рџ‘·вЂЌв™‚пёЏ","princess":"рџ‘ё","japanese_ogre":"рџ‘№","japanese_goblin":"рџ‘є","ghost":"рџ‘»","angel":"рџ‘ј","alien":"рџ‘Ѕ","space_invader":"рџ‘ѕ","imp":"рџ‘ї","skull":"рџ’Ђ","woman-tipping-hand":"рџ’ЃвЂЌв™ЂпёЏ","information_desk_person":"рџ’ЃвЂЌв™ЂпёЏ","man-tipping-hand":"рџ’ЃвЂЌв™‚пёЏ","female-guard":"рџ’‚вЂЌв™ЂпёЏ","male-guard":"рџ’‚вЂЌв™‚пёЏ","guardsman":"рџ’‚вЂЌв™‚пёЏ","dancer":"рџ’ѓ","lipstick":"рџ’„","nail_care":"рџ’…","woman-getting-massage":"рџ’†вЂЌв™ЂпёЏ","massage":"рџ’†вЂЌв™ЂпёЏ","man-getting-massage":"рџ’†вЂЌв™‚пёЏ","woman-getting-haircut":"рџ’‡вЂЌв™ЂпёЏ","haircut":"рџ’‡вЂЌв™ЂпёЏ","man-getting-haircut":"рџ’‡вЂЌв™‚пёЏ","barber":"рџ’€","syringe":"рџ’‰","pill":"рџ’Љ","kiss":"рџ’‹","love_letter":"рџ’Њ","ring":"рџ’Ќ","gem":"рџ’Ћ","couplekiss":"рџ’Џ","bouquet":"рџ’ђ","couple_with_heart":"рџ’‘","wedding":"рџ’’","heartbeat":"рџ’“","broken_heart":"рџ’”","two_hearts":"рџ’•","sparkling_heart":"рџ’–","heartpulse":"рџ’—","cupid":"рџ’","blue_heart":"рџ’™","green_heart":"рџ’љ","yellow_heart":"рџ’›","purple_heart":"рџ’њ","gift_heart":"рџ’ќ","revolving_hearts":"рџ’ћ","heart_decoration":"рџ’џ","diamond_shape_with_a_dot_inside":"рџ’ ","bulb":"рџ’Ў","anger":"рџ’ў","bomb":"рџ’Ј","zzz":"рџ’¤","boom":"рџ’Ґ","collision":"рџ’Ґ","sweat_drops":"рџ’¦","droplet":"рџ’§","dash":"рџ’Ё","hankey":"рџ’©","poop":"рџ’©","shit":"рџ’©","muscle":"рџ’Є","dizzy":"рџ’«","speech_balloon":"рџ’¬","thought_balloon":"рџ’­","white_flower":"рџ’®","moneybag":"рџ’°","currency_exchange":"рџ’±","heavy_dollar_sign":"рџ’І","credit_card":"рџ’і","yen":"рџ’ґ","dollar":"рџ’µ","euro":"рџ’¶","pound":"рџ’·","money_with_wings":"рџ’ё","chart":"рџ’№","seat":"рџ’є","computer":"рџ’»","briefcase":"рџ’ј","minidisc":"рџ’Ѕ","floppy_disk":"рџ’ѕ","cd":"рџ’ї","dvd":"рџ“Ђ","file_folder":"рџ“Ѓ","open_file_folder":"рџ“‚","page_with_curl":"рџ“ѓ","page_facing_up":"рџ“„","date":"рџ“…","calendar":"рџ“†","card_index":"рџ“‡","chart_with_upwards_trend":"рџ“€","chart_with_downwards_trend":"рџ“‰","bar_chart":"рџ“Љ","clipboard":"рџ“‹","pushpin":"рџ“Њ","round_pushpin":"рџ“Ќ","paperclip":"рџ“Ћ","straight_ruler":"рџ“Џ","triangular_ruler":"рџ“ђ","bookmark_tabs":"рџ“‘","ledger":"рџ“’","notebook":"рџ““","notebook_with_decorative_cover":"рџ“”","closed_book":"рџ“•","book":"рџ“–","open_book":"рџ“–","green_book":"рџ“—","blue_book":"рџ“","orange_book":"рџ“™","books":"рџ“љ","name_badge":"рџ“›","scroll":"рџ“њ","memo":"рџ“ќ","pencil":"рџ“ќ","telephone_receiver":"рџ“ћ","pager":"рџ“џ","fax":"рџ“ ","satellite_antenna":"рџ“Ў","loudspeaker":"рџ“ў","mega":"рџ“Ј","outbox_tray":"рџ“¤","inbox_tray":"рџ“Ґ","package":"рџ“¦","e-mail":"рџ“§","incoming_envelope":"рџ“Ё","envelope_with_arrow":"рџ“©","mailbox_closed":"рџ“Є","mailbox":"рџ“«","mailbox_with_mail":"рџ“¬","mailbox_with_no_mail":"рџ“­","postbox":"рџ“®","postal_horn":"рџ“Ї","newspaper":"рџ“°","iphone":"рџ“±","calling":"рџ“І","vibration_mode":"рџ“і","mobile_phone_off":"рџ“ґ","no_mobile_phones":"рџ“µ","signal_strength":"рџ“¶","camera":"рџ“·","camera_with_flash":"рџ“ё","video_camera":"рџ“№","tv":"рџ“є","radio":"рџ“»","vhs":"рџ“ј","film_projector":"рџ“ЅпёЏ","prayer_beads":"рџ“ї","twisted_rightwards_arrows":"рџ”Ђ","repeat":"рџ”Ѓ","repeat_one":"рџ”‚","arrows_clockwise":"рџ”ѓ","arrows_counterclockwise":"рџ”„","low_brightness":"рџ”…","high_brightness":"рџ”†","mute":"рџ”‡","speaker":"рџ”€","sound":"рџ”‰","loud_sound":"рџ”Љ","battery":"рџ”‹","electric_plug":"рџ”Њ","mag":"рџ”Ќ","mag_right":"рџ”Ћ","lock_with_ink_pen":"рџ”Џ","closed_lock_with_key":"рџ”ђ","key":"рџ”‘","lock":"рџ”’","unlock":"рџ”“","bell":"рџ””","no_bell":"рџ”•","bookmark":"рџ”–","link":"рџ”—","radio_button":"рџ”","back":"рџ”™","end":"рџ”љ","on":"рџ”›","soon":"рџ”њ","top":"рџ”ќ","underage":"рџ”ћ","keycap_ten":"рџ”џ","capital_abcd":"рџ” ","abcd":"рџ”Ў","symbols":"рџ”Ј","abc":"рџ”¤","fire":"рџ”Ґ","flashlight":"рџ”¦","wrench":"рџ”§","hammer":"рџ”Ё","nut_and_bolt":"рџ”©","hocho":"рџ”Є","knife":"рџ”Є","gun":"рџ”«","microscope":"рџ”¬","telescope":"рџ”­","crystal_ball":"рџ”®","six_pointed_star":"рџ”Ї","beginner":"рџ”°","trident":"рџ”±","black_square_button":"рџ”І","white_square_button":"рџ”і","red_circle":"рџ”ґ","large_blue_circle":"рџ”µ","large_orange_diamond":"рџ”¶","large_blue_diamond":"рџ”·","small_orange_diamond":"рџ”ё","small_blue_diamond":"рџ”№","small_red_triangle":"рџ”є","small_red_triangle_down":"рџ”»","arrow_up_small":"рџ”ј","arrow_down_small":"рџ”Ѕ","om_symbol":"рџ•‰пёЏ","dove_of_peace":"рџ•ЉпёЏ","kaaba":"рџ•‹","mosque":"рџ•Њ","synagogue":"рџ•Ќ","menorah_with_nine_branches":"рџ•Ћ","clock1":"рџ•ђ","clock2":"рџ•‘","clock3":"рџ•’","clock4":"рџ•“","clock5":"рџ•”","clock6":"рџ••","clock7":"рџ•–","clock8":"рџ•—","clock9":"рџ•","clock10":"рџ•™","clock11":"рџ•љ","clock12":"рџ•›","clock130":"рџ•њ","clock230":"рџ•ќ","clock330":"рџ•ћ","clock430":"рџ•џ","clock530":"рџ• ","clock630":"рџ•Ў","clock730":"рџ•ў","clock830":"рџ•Ј","clock930":"рџ•¤","clock1030":"рџ•Ґ","clock1130":"рџ•¦","clock1230":"рџ•§","candle":"рџ•ЇпёЏ","mantelpiece_clock":"рџ•°пёЏ","hole":"рџ•іпёЏ","man_in_business_suit_levitating":"рџ•ґпёЏ","female-detective":"рџ•µпёЏвЂЌв™ЂпёЏ","male-detective":"рџ•µпёЏвЂЌв™‚пёЏ","sleuth_or_spy":"рџ•µпёЏвЂЌв™‚пёЏ","dark_sunglasses":"рџ•¶пёЏ","spider":"рџ•·пёЏ","spider_web":"рџ•ёпёЏ","joystick":"рџ•№пёЏ","man_dancing":"рџ•є","linked_paperclips":"рџ–‡пёЏ","lower_left_ballpoint_pen":"рџ–ЉпёЏ","lower_left_fountain_pen":"рџ–‹пёЏ","lower_left_paintbrush":"рџ–ЊпёЏ","lower_left_crayon":"рџ–ЌпёЏ","raised_hand_with_fingers_splayed":"рџ–ђпёЏ","middle_finger":"рџ–•","reversed_hand_with_middle_finger_extended":"рџ–•","spock-hand":"рџ––","black_heart":"рџ–¤","desktop_computer":"рџ–ҐпёЏ","printer":"рџ–ЁпёЏ","three_button_mouse":"рџ–±пёЏ","trackball":"рџ–ІпёЏ","frame_with_picture":"рџ–јпёЏ","card_index_dividers":"рџ—‚пёЏ","card_file_box":"рџ—ѓпёЏ","file_cabinet":"рџ—„пёЏ","wastebasket":"рџ—‘пёЏ","spiral_note_pad":"рџ—’пёЏ","spiral_calendar_pad":"рџ—“пёЏ","compression":"рџ—њпёЏ","old_key":"рџ—ќпёЏ","rolled_up_newspaper":"рџ—ћпёЏ","dagger_knife":"рџ—ЎпёЏ","speaking_head_in_silhouette":"рџ—ЈпёЏ","left_speech_bubble":"рџ—ЁпёЏ","right_anger_bubble":"рџ—ЇпёЏ","ballot_box_with_ballot":"рџ—іпёЏ","world_map":"рџ—єпёЏ","mount_fuji":"рџ—»","tokyo_tower":"рџ—ј","statue_of_liberty":"рџ—Ѕ","japan":"рџ—ѕ","moyai":"рџ—ї","grinning":"рџЂ","grin":"рџЃ","joy":"рџ‚","smiley":"рџѓ","smile":"рџ„","sweat_smile":"рџ…","laughing":"рџ†","satisfied":"рџ†","innocent":"рџ‡","smiling_imp":"рџ€","wink":"рџ‰","blush":"рџЉ","yum":"рџ‹","relieved":"рџЊ","heart_eyes":"рџЌ","sunglasses":"рџЋ","smirk":"рџЏ","neutral_face":"рџђ","expressionless":"рџ‘","unamused":"рџ’","sweat":"рџ“","pensive":"рџ”","confused":"рџ•","confounded":"рџ–","kissing":"рџ—","kissing_heart":"рџ","kissing_smiling_eyes":"рџ™","kissing_closed_eyes":"рџљ","stuck_out_tongue":"рџ›","stuck_out_tongue_winking_eye":"рџњ","stuck_out_tongue_closed_eyes":"рџќ","disappointed":"рџћ","worried":"рџџ","angry":"рџ ","rage":"рџЎ","cry":"рџў","persevere":"рџЈ","triumph":"рџ¤","disappointed_relieved":"рџҐ","frowning":"рџ¦","anguished":"рџ§","fearful":"рџЁ","weary":"рџ©","sleepy":"рџЄ","tired_face":"рџ«","grimacing":"рџ¬","sob":"рџ­","face_exhaling":"рџ®вЂЌрџ’Ё","open_mouth":"рџ®","hushed":"рџЇ","cold_sweat":"рџ°","scream":"рџ±","astonished":"рџІ","flushed":"рџі","sleeping":"рџґ","face_with_spiral_eyes":"рџµвЂЌрџ’«","dizzy_face":"рџµ","face_in_clouds":"рџ¶вЂЌрџЊ«пёЏ","no_mouth":"рџ¶","mask":"рџ·","smile_cat":"рџё","joy_cat":"рџ№","smiley_cat":"рџє","heart_eyes_cat":"рџ»","smirk_cat":"рџј","kissing_cat":"рџЅ","pouting_cat":"рџѕ","crying_cat_face":"рџї","scream_cat":"рџ™Ђ","slightly_frowning_face":"рџ™Ѓ","slightly_smiling_face":"рџ™‚","upside_down_face":"рџ™ѓ","face_with_rolling_eyes":"рџ™„","woman-gesturing-no":"рџ™…вЂЌв™ЂпёЏ","no_good":"рџ™…вЂЌв™ЂпёЏ","man-gesturing-no":"рџ™…вЂЌв™‚пёЏ","woman-gesturing-ok":"рџ™†вЂЌв™ЂпёЏ","ok_woman":"рџ™†вЂЌв™ЂпёЏ","man-gesturing-ok":"рџ™†вЂЌв™‚пёЏ","woman-bowing":"рџ™‡вЂЌв™ЂпёЏ","man-bowing":"рџ™‡вЂЌв™‚пёЏ","bow":"рџ™‡вЂЌв™‚пёЏ","see_no_evil":"рџ™€","hear_no_evil":"рџ™‰","speak_no_evil":"рџ™Љ","woman-raising-hand":"рџ™‹вЂЌв™ЂпёЏ","raising_hand":"рџ™‹вЂЌв™ЂпёЏ","man-raising-hand":"рџ™‹вЂЌв™‚пёЏ","raised_hands":"рџ™Њ","woman-frowning":"рџ™ЌвЂЌв™ЂпёЏ","person_frowning":"рџ™ЌвЂЌв™ЂпёЏ","man-frowning":"рџ™ЌвЂЌв™‚пёЏ","woman-pouting":"рџ™ЋвЂЌв™ЂпёЏ","person_with_pouting_face":"рџ™ЋвЂЌв™ЂпёЏ","man-pouting":"рџ™ЋвЂЌв™‚пёЏ","pray":"рџ™Џ","rocket":"рџљЂ","helicopter":"рџљЃ","steam_locomotive":"рџљ‚","railway_car":"рџљѓ","bullettrain_side":"рџљ„","bullettrain_front":"рџљ…","train2":"рџљ†","metro":"рџљ‡","light_rail":"рџљ€","station":"рџљ‰","tram":"рџљЉ","train":"рџљ‹","bus":"рџљЊ","oncoming_bus":"рџљЌ","trolleybus":"рџљЋ","busstop":"рџљЏ","minibus":"рџљђ","ambulance":"рџљ‘","fire_engine":"рџљ’","police_car":"рџљ“","oncoming_police_car":"рџљ”","taxi":"рџљ•","oncoming_taxi":"рџљ–","car":"рџљ—","red_car":"рџљ—","oncoming_automobile":"рџљ","blue_car":"рџљ™","truck":"рџљљ","articulated_lorry":"рџљ›","tractor":"рџљњ","monorail":"рџљќ","mountain_railway":"рџљћ","suspension_railway":"рџљџ","mountain_cableway":"рџљ ","aerial_tramway":"рџљЎ","ship":"рџљў","woman-rowing-boat":"рџљЈвЂЌв™ЂпёЏ","man-rowing-boat":"рџљЈвЂЌв™‚пёЏ","rowboat":"рџљЈвЂЌв™‚пёЏ","speedboat":"рџљ¤","traffic_light":"рџљҐ","vertical_traffic_light":"рџљ¦","construction":"рџљ§","rotating_light":"рџљЁ","triangular_flag_on_post":"рџљ©","door":"рџљЄ","no_entry_sign":"рџљ«","smoking":"рџљ¬","no_smoking":"рџљ­","put_litter_in_its_place":"рџљ®","do_not_litter":"рџљЇ","potable_water":"рџљ°","non-potable_water":"рџљ±","bike":"рџљІ","no_bicycles":"рџљі","woman-biking":"рџљґвЂЌв™ЂпёЏ","man-biking":"рџљґвЂЌв™‚пёЏ","bicyclist":"рџљґвЂЌв™‚пёЏ","woman-mountain-biking":"рџљµвЂЌв™ЂпёЏ","man-mountain-biking":"рџљµвЂЌв™‚пёЏ","mountain_bicyclist":"рџљµвЂЌв™‚пёЏ","woman-walking":"рџљ¶вЂЌв™ЂпёЏ","man-walking":"рџљ¶вЂЌв™‚пёЏ","walking":"рџљ¶вЂЌв™‚пёЏ","no_pedestrians":"рџљ·","children_crossing":"рџљё","mens":"рџљ№","womens":"рџљє","restroom":"рџљ»","baby_symbol":"рџљј","toilet":"рџљЅ","wc":"рџљѕ","shower":"рџљї","bath":"рџ›Ђ","bathtub":"рџ›Ѓ","passport_control":"рџ›‚","customs":"рџ›ѓ","baggage_claim":"рџ›„","left_luggage":"рџ›…","couch_and_lamp":"рџ›‹пёЏ","sleeping_accommodation":"рџ›Њ","shopping_bags":"рџ›ЌпёЏ","bellhop_bell":"рџ›ЋпёЏ","bed":"рџ›ЏпёЏ","place_of_worship":"рџ›ђ","octagonal_sign":"рџ›‘","shopping_trolley":"рџ›’","hindu_temple":"рџ›•","hut":"рџ›–","elevator":"рџ›—","hammer_and_wrench":"рџ› пёЏ","shield":"рџ›ЎпёЏ","oil_drum":"рџ›ўпёЏ","motorway":"рџ›ЈпёЏ","railway_track":"рџ›¤пёЏ","motor_boat":"рџ›ҐпёЏ","small_airplane":"рџ›©пёЏ","airplane_departure":"рџ›«","airplane_arriving":"рџ›¬","satellite":"рџ›°пёЏ","passenger_ship":"рџ›іпёЏ","scooter":"рџ›ґ","motor_scooter":"рџ›µ","canoe":"рџ›¶","sled":"рџ›·","flying_saucer":"рџ›ё","skateboard":"рџ›№","auto_rickshaw":"рџ›є","pickup_truck":"рџ›»","roller_skate":"рџ›ј","large_orange_circle":"рџџ ","large_yellow_circle":"рџџЎ","large_green_circle":"рџџў","large_purple_circle":"рџџЈ","large_brown_circle":"рџџ¤","large_red_square":"рџџҐ","large_blue_square":"рџџ¦","large_orange_square":"рџџ§","large_yellow_square":"рџџЁ","large_green_square":"рџџ©","large_purple_square":"рџџЄ","large_brown_square":"рџџ«","pinched_fingers":"рџ¤Њ","white_heart":"рџ¤Ќ","brown_heart":"рџ¤Ћ","pinching_hand":"рџ¤Џ","zipper_mouth_face":"рџ¤ђ","money_mouth_face":"рџ¤‘","face_with_thermometer":"рџ¤’","nerd_face":"рџ¤“","thinking_face":"рџ¤”","face_with_head_bandage":"рџ¤•","robot_face":"рџ¤–","hugging_face":"рџ¤—","the_horns":"рџ¤","sign_of_the_horns":"рџ¤","call_me_hand":"рџ¤™","raised_back_of_hand":"рџ¤љ","left-facing_fist":"рџ¤›","right-facing_fist":"рџ¤њ","handshake":"рџ¤ќ","crossed_fingers":"рџ¤ћ","hand_with_index_and_middle_fingers_crossed":"рџ¤ћ","i_love_you_hand_sign":"рџ¤џ","face_with_cowboy_hat":"рџ¤ ","clown_face":"рџ¤Ў","nauseated_face":"рџ¤ў","rolling_on_the_floor_laughing":"рџ¤Ј","drooling_face":"рџ¤¤","lying_face":"рџ¤Ґ","woman-facepalming":"рџ¤¦вЂЌв™ЂпёЏ","man-facepalming":"рџ¤¦вЂЌв™‚пёЏ","face_palm":"рџ¤¦","sneezing_face":"рџ¤§","face_with_raised_eyebrow":"рџ¤Ё","face_with_one_eyebrow_raised":"рџ¤Ё","star-struck":"рџ¤©","grinning_face_with_star_eyes":"рџ¤©","zany_face":"рџ¤Є","grinning_face_with_one_large_and_one_small_eye":"рџ¤Є","shushing_face":"рџ¤«","face_with_finger_covering_closed_lips":"рџ¤«","face_with_symbols_on_mouth":"рџ¤¬","serious_face_with_symbols_covering_mouth":"рџ¤¬","face_with_hand_over_mouth":"рџ¤­","smiling_face_with_smiling_eyes_and_hand_covering_mouth":"рџ¤­","face_vomiting":"рџ¤®","face_with_open_mouth_vomiting":"рџ¤®","exploding_head":"рџ¤Ї","shocked_face_with_exploding_head":"рџ¤Ї","pregnant_woman":"рџ¤°","breast-feeding":"рџ¤±","palms_up_together":"рџ¤І","selfie":"рџ¤і","prince":"рџ¤ґ","woman_in_tuxedo":"рџ¤µвЂЌв™ЂпёЏ","man_in_tuxedo":"рџ¤µвЂЌв™‚пёЏ","person_in_tuxedo":"рџ¤µ","mrs_claus":"рџ¤¶","mother_christmas":"рџ¤¶","woman-shrugging":"рџ¤·вЂЌв™ЂпёЏ","man-shrugging":"рџ¤·вЂЌв™‚пёЏ","shrug":"рџ¤·","woman-cartwheeling":"рџ¤ёвЂЌв™ЂпёЏ","man-cartwheeling":"рџ¤ёвЂЌв™‚пёЏ","person_doing_cartwheel":"рџ¤ё","woman-juggling":"рџ¤№вЂЌв™ЂпёЏ","man-juggling":"рџ¤№вЂЌв™‚пёЏ","juggling":"рџ¤№","fencer":"рџ¤є","woman-wrestling":"рџ¤јвЂЌв™ЂпёЏ","man-wrestling":"рџ¤јвЂЌв™‚пёЏ","wrestlers":"рџ¤ј","woman-playing-water-polo":"рџ¤ЅвЂЌв™ЂпёЏ","man-playing-water-polo":"рџ¤ЅвЂЌв™‚пёЏ","water_polo":"рџ¤Ѕ","woman-playing-handball":"рџ¤ѕвЂЌв™ЂпёЏ","man-playing-handball":"рџ¤ѕвЂЌв™‚пёЏ","handball":"рџ¤ѕ","diving_mask":"рџ¤ї","wilted_flower":"рџҐЂ","drum_with_drumsticks":"рџҐЃ","clinking_glasses":"рџҐ‚","tumbler_glass":"рџҐѓ","spoon":"рџҐ„","goal_net":"рџҐ…","first_place_medal":"рџҐ‡","second_place_medal":"рџҐ€","third_place_medal":"рџҐ‰","boxing_glove":"рџҐЉ","martial_arts_uniform":"рџҐ‹","curling_stone":"рџҐЊ","lacrosse":"рџҐЌ","softball":"рџҐЋ","flying_disc":"рџҐЏ","croissant":"рџҐђ","avocado":"рџҐ‘","cucumber":"рџҐ’","bacon":"рџҐ“","potato":"рџҐ”","carrot":"рџҐ•","baguette_bread":"рџҐ–","green_salad":"рџҐ—","shallow_pan_of_food":"рџҐ","stuffed_flatbread":"рџҐ™","egg":"рџҐљ","glass_of_milk":"рџҐ›","peanuts":"рџҐњ","kiwifruit":"рџҐќ","pancakes":"рџҐћ","dumpling":"рџҐџ","fortune_cookie":"рџҐ ","takeout_box":"рџҐЎ","chopsticks":"рџҐў","bowl_with_spoon":"рџҐЈ","cup_with_straw":"рџҐ¤","coconut":"рџҐҐ","broccoli":"рџҐ¦","pie":"рџҐ§","pretzel":"рџҐЁ","cut_of_meat":"рџҐ©","sandwich":"рџҐЄ","canned_food":"рџҐ«","leafy_green":"рџҐ¬","mango":"рџҐ­","moon_cake":"рџҐ®","bagel":"рџҐЇ","smiling_face_with_3_hearts":"рџҐ°","yawning_face":"рџҐ±","smiling_face_with_tear":"рџҐІ","partying_face":"рџҐі","woozy_face":"рџҐґ","hot_face":"рџҐµ","cold_face":"рџҐ¶","ninja":"рџҐ·","disguised_face":"рџҐё","pleading_face":"рџҐє","sari":"рџҐ»","lab_coat":"рџҐј","goggles":"рџҐЅ","hiking_boot":"рџҐѕ","womans_flat_shoe":"рџҐї","crab":"рџ¦Ђ","lion_face":"рџ¦Ѓ","scorpion":"рџ¦‚","turkey":"рџ¦ѓ","unicorn_face":"рџ¦„","eagle":"рџ¦…","duck":"рџ¦†","bat":"рџ¦‡","shark":"рџ¦€","owl":"рџ¦‰","fox_face":"рџ¦Љ","butterfly":"рџ¦‹","deer":"рџ¦Њ","gorilla":"рџ¦Ќ","lizard":"рџ¦Ћ","rhinoceros":"рџ¦Џ","shrimp":"рџ¦ђ","squid":"рџ¦‘","giraffe_face":"рџ¦’","zebra_face":"рџ¦“","hedgehog":"рџ¦”","sauropod":"рџ¦•","t-rex":"рџ¦–","cricket":"рџ¦—","kangaroo":"рџ¦","llama":"рџ¦™","peacock":"рџ¦љ","hippopotamus":"рџ¦›","parrot":"рџ¦њ","raccoon":"рџ¦ќ","lobster":"рџ¦ћ","mosquito":"рџ¦џ","microbe":"рџ¦ ","badger":"рџ¦Ў","swan":"рџ¦ў","mammoth":"рџ¦Ј","dodo":"рџ¦¤","sloth":"рџ¦Ґ","otter":"рџ¦¦","orangutan":"рџ¦§","skunk":"рџ¦Ё","flamingo":"рџ¦©","oyster":"рџ¦Є","beaver":"рџ¦«","bison":"рџ¦¬","seal":"рџ¦­","guide_dog":"рџ¦®","probing_cane":"рџ¦Ї","bone":"рџ¦ґ","leg":"рџ¦µ","foot":"рџ¦¶","tooth":"рџ¦·","female_superhero":"рџ¦ёвЂЌв™ЂпёЏ","male_superhero":"рџ¦ёвЂЌв™‚пёЏ","superhero":"рџ¦ё","female_supervillain":"рџ¦№вЂЌв™ЂпёЏ","male_supervillain":"рџ¦№вЂЌв™‚пёЏ","supervillain":"рџ¦№","safety_vest":"рџ¦є","ear_with_hearing_aid":"рџ¦»","motorized_wheelchair":"рџ¦ј","manual_wheelchair":"рџ¦Ѕ","mechanical_arm":"рџ¦ѕ","mechanical_leg":"рџ¦ї","cheese_wedge":"рџ§Ђ","cupcake":"рџ§Ѓ","salt":"рџ§‚","beverage_box":"рџ§ѓ","garlic":"рџ§„","onion":"рџ§…","falafel":"рџ§†","waffle":"рџ§‡","butter":"рџ§€","mate_drink":"рџ§‰","ice_cube":"рџ§Љ","bubble_tea":"рџ§‹","woman_standing":"рџ§ЌвЂЌв™ЂпёЏ","man_standing":"рџ§ЌвЂЌв™‚пёЏ","standing_person":"рџ§Ќ","woman_kneeling":"рџ§ЋвЂЌв™ЂпёЏ","man_kneeling":"рџ§ЋвЂЌв™‚пёЏ","kneeling_person":"рџ§Ћ","deaf_woman":"рџ§ЏвЂЌв™ЂпёЏ","deaf_man":"рџ§ЏвЂЌв™‚пёЏ","deaf_person":"рџ§Џ","face_with_monocle":"рџ§ђ","farmer":"рџ§‘вЂЌрџЊѕ","cook":"рџ§‘вЂЌрџЌі","person_feeding_baby":"рџ§‘вЂЌрџЌј","mx_claus":"рџ§‘вЂЌрџЋ„","student":"рџ§‘вЂЌрџЋ“","singer":"рџ§‘вЂЌрџЋ¤","artist":"рџ§‘вЂЌрџЋЁ","teacher":"рџ§‘вЂЌрџЏ«","factory_worker":"рџ§‘вЂЌрџЏ­","technologist":"рџ§‘вЂЌрџ’»","office_worker":"рџ§‘вЂЌрџ’ј","mechanic":"рџ§‘вЂЌрџ”§","scientist":"рџ§‘вЂЌрџ”¬","astronaut":"рџ§‘вЂЌрџљЂ","firefighter":"рџ§‘вЂЌрџљ’","people_holding_hands":"рџ§‘вЂЌрџ¤ќвЂЌрџ§‘","person_with_probing_cane":"рџ§‘вЂЌрџ¦Ї","red_haired_person":"рџ§‘вЂЌрџ¦°","curly_haired_person":"рџ§‘вЂЌрџ¦±","bald_person":"рџ§‘вЂЌрџ¦І","white_haired_person":"рџ§‘вЂЌрџ¦і","person_in_motorized_wheelchair":"рџ§‘вЂЌрџ¦ј","person_in_manual_wheelchair":"рџ§‘вЂЌрџ¦Ѕ","health_worker":"рџ§‘вЂЌвљ•пёЏ","judge":"рџ§‘вЂЌвљ–пёЏ","pilot":"рџ§‘вЂЌвњ€пёЏ","adult":"рџ§‘","child":"рџ§’","older_adult":"рџ§“","woman_with_beard":"рџ§”вЂЌв™ЂпёЏ","man_with_beard":"рџ§”вЂЌв™‚пёЏ","bearded_person":"рџ§”","person_with_headscarf":"рџ§•","woman_in_steamy_room":"рџ§–вЂЌв™ЂпёЏ","man_in_steamy_room":"рџ§–вЂЌв™‚пёЏ","person_in_steamy_room":"рџ§–вЂЌв™‚пёЏ","woman_climbing":"рџ§—вЂЌв™ЂпёЏ","person_climbing":"рџ§—вЂЌв™ЂпёЏ","man_climbing":"рџ§—вЂЌв™‚пёЏ","woman_in_lotus_position":"рџ§вЂЌв™ЂпёЏ","person_in_lotus_position":"рџ§вЂЌв™ЂпёЏ","man_in_lotus_position":"рџ§вЂЌв™‚пёЏ","female_mage":"рџ§™вЂЌв™ЂпёЏ","mage":"рџ§™вЂЌв™ЂпёЏ","male_mage":"рџ§™вЂЌв™‚пёЏ","female_fairy":"рџ§љвЂЌв™ЂпёЏ","fairy":"рџ§љвЂЌв™ЂпёЏ","male_fairy":"рџ§љвЂЌв™‚пёЏ","female_vampire":"рџ§›вЂЌв™ЂпёЏ","vampire":"рџ§›вЂЌв™ЂпёЏ","male_vampire":"рџ§›вЂЌв™‚пёЏ","mermaid":"рџ§њвЂЌв™ЂпёЏ","merman":"рџ§њвЂЌв™‚пёЏ","merperson":"рџ§њвЂЌв™‚пёЏ","female_elf":"рџ§ќвЂЌв™ЂпёЏ","male_elf":"рџ§ќвЂЌв™‚пёЏ","elf":"рџ§ќвЂЌв™‚пёЏ","female_genie":"рџ§ћвЂЌв™ЂпёЏ","male_genie":"рџ§ћвЂЌв™‚пёЏ","genie":"рџ§ћвЂЌв™‚пёЏ","female_zombie":"рџ§џвЂЌв™ЂпёЏ","male_zombie":"рџ§џвЂЌв™‚пёЏ","zombie":"рџ§џвЂЌв™‚пёЏ","brain":"рџ§ ","orange_heart":"рџ§Ў","billed_cap":"рџ§ў","scarf":"рџ§Ј","gloves":"рџ§¤","coat":"рџ§Ґ","socks":"рџ§¦","red_envelope":"рџ§§","firecracker":"рџ§Ё","jigsaw":"рџ§©","test_tube":"рџ§Є","petri_dish":"рџ§«","dna":"рџ§¬","compass":"рџ§­","abacus":"рџ§®","fire_extinguisher":"рџ§Ї","toolbox":"рџ§°","bricks":"рџ§±","magnet":"рџ§І","luggage":"рџ§і","lotion_bottle":"рџ§ґ","thread":"рџ§µ","yarn":"рџ§¶","safety_pin":"рџ§·","teddy_bear":"рџ§ё","broom":"рџ§№","basket":"рџ§є","roll_of_paper":"рџ§»","soap":"рџ§ј","sponge":"рџ§Ѕ","receipt":"рџ§ѕ","nazar_amulet":"рџ§ї","ballet_shoes":"рџ©°","one-piece_swimsuit":"рџ©±","briefs":"рџ©І","shorts":"рџ©і","thong_sandal":"рџ©ґ","drop_of_blood":"рџ©ё","adhesive_bandage":"рџ©№","stethoscope":"рџ©є","yo-yo":"рџЄЂ","kite":"рџЄЃ","parachute":"рџЄ‚","boomerang":"рџЄѓ","magic_wand":"рџЄ„","pinata":"рџЄ…","nesting_dolls":"рџЄ†","ringed_planet":"рџЄђ","chair":"рџЄ‘","razor":"рџЄ’","axe":"рџЄ“","diya_lamp":"рџЄ”","banjo":"рџЄ•","military_helmet":"рџЄ–","accordion":"рџЄ—","long_drum":"рџЄ","coin":"рџЄ™","carpentry_saw":"рџЄљ","screwdriver":"рџЄ›","ladder":"рџЄњ","hook":"рџЄќ","mirror":"рџЄћ","window":"рџЄџ","plunger":"рџЄ ","sewing_needle":"рџЄЎ","knot":"рџЄў","bucket":"рџЄЈ","mouse_trap":"рџЄ¤","toothbrush":"рџЄҐ","headstone":"рџЄ¦","placard":"рџЄ§","rock":"рџЄЁ","fly":"рџЄ°","worm":"рџЄ±","beetle":"рџЄІ","cockroach":"рџЄі","potted_plant":"рџЄґ","wood":"рџЄµ","feather":"рџЄ¶","anatomical_heart":"рџ«Ђ","lungs":"рџ«Ѓ","people_hugging":"рџ«‚","blueberries":"рџ«ђ","bell_pepper":"рџ«‘","olive":"рџ«’","flatbread":"рџ«“","tamale":"рџ«”","fondue":"рџ«•","teapot":"рџ«–","bangbang":"вЂјпёЏ","interrobang":"вЃ‰пёЏ","tm":"в„ўпёЏ","information_source":"в„№пёЏ","left_right_arrow":"в†”пёЏ","arrow_up_down":"в†•пёЏ","arrow_upper_left":"в†–пёЏ","arrow_upper_right":"в†—пёЏ","arrow_lower_right":"в†пёЏ","arrow_lower_left":"в†™пёЏ","leftwards_arrow_with_hook":"в†©пёЏ","arrow_right_hook":"в†ЄпёЏ","watch":"вЊљ","hourglass":"вЊ›","keyboard":"вЊЁпёЏ","eject":"вЏЏпёЏ","fast_forward":"вЏ©","rewind":"вЏЄ","arrow_double_up":"вЏ«","arrow_double_down":"вЏ¬","black_right_pointing_double_triangle_with_vertical_bar":"вЏ­пёЏ","black_left_pointing_double_triangle_with_vertical_bar":"вЏ®пёЏ","black_right_pointing_triangle_with_double_vertical_bar":"вЏЇпёЏ","alarm_clock":"вЏ°","stopwatch":"вЏ±пёЏ","timer_clock":"вЏІпёЏ","hourglass_flowing_sand":"вЏі","double_vertical_bar":"вЏёпёЏ","black_square_for_stop":"вЏ№пёЏ","black_circle_for_record":"вЏєпёЏ","m":"в“‚пёЏ","black_small_square":"в–ЄпёЏ","white_small_square":"в–«пёЏ","arrow_forward":"в–¶пёЏ","arrow_backward":"в—ЂпёЏ","white_medium_square":"в—»пёЏ","black_medium_square":"в—јпёЏ","white_medium_small_square":"в—Ѕ","black_medium_small_square":"в—ѕ","sunny":"вЂпёЏ","cloud":"вЃпёЏ","umbrella":"в‚пёЏ","snowman":"вѓпёЏ","comet":"в„пёЏ","phone":"вЋпёЏ","telephone":"вЋпёЏ","ballot_box_with_check":"в‘пёЏ","shamrock":"впёЏ","point_up":"вќпёЏ","skull_and_crossbones":"в пёЏ","radioactive_sign":"вўпёЏ","biohazard_sign":"вЈпёЏ","orthodox_cross":"в¦пёЏ","star_and_crescent":"вЄпёЏ","peace_symbol":"в®пёЏ","yin_yang":"вЇпёЏ","wheel_of_dharma":"вёпёЏ","white_frowning_face":"в№пёЏ","relaxed":"вєпёЏ","female_sign":"в™ЂпёЏ","male_sign":"в™‚пёЏ","gemini":"в™Љ","cancer":"в™‹","leo":"в™Њ","virgo":"в™Ќ","libra":"в™Ћ","scorpius":"в™Џ","chess_pawn":"в™џпёЏ","spades":"в™ пёЏ","clubs":"в™ЈпёЏ","hearts":"в™ҐпёЏ","diamonds":"в™¦пёЏ","hotsprings":"в™ЁпёЏ","recycle":"в™»пёЏ","infinity":"в™ѕпёЏ","wheelchair":"в™ї","hammer_and_pick":"вљ’пёЏ","crossed_swords":"вљ”пёЏ","medical_symbol":"вљ•пёЏ","staff_of_aesculapius":"вљ•пёЏ","scales":"вљ–пёЏ","alembic":"вљ—пёЏ","gear":"вљ™пёЏ","atom_symbol":"вљ›пёЏ","fleur_de_lis":"вљњпёЏ","warning":"вљ пёЏ","zap":"вљЎ","transgender_symbol":"вљ§пёЏ","white_circle":"вљЄ","black_circle":"вљ«","coffin":"вљ°пёЏ","funeral_urn":"вљ±пёЏ","soccer":"вљЅ","baseball":"вљѕ","snowman_without_snow":"в›„","partly_sunny":"в›…","thunder_cloud_and_rain":"в›€пёЏ","ophiuchus":"в›Ћ","pick":"в›ЏпёЏ","helmet_with_white_cross":"в›‘пёЏ","chains":"в›“пёЏ","no_entry":"в›”","shinto_shrine":"в›©пёЏ","church":"в›Є","mountain":"в›°пёЏ","umbrella_on_ground":"в›±пёЏ","fountain":"в›І","golf":"в›і","ferry":"в›ґпёЏ","boat":"в›µ","sailboat":"в›µ","skier":"в›·пёЏ","ice_skate":"в›ёпёЏ","woman-bouncing-ball":"в›№пёЏвЂЌв™ЂпёЏ","man-bouncing-ball":"в›№пёЏвЂЌв™‚пёЏ","person_with_ball":"в›№пёЏвЂЌв™‚пёЏ","tent":"в›є","fuelpump":"в›Ѕ","scissors":"вњ‚пёЏ","airplane":"вњ€пёЏ","email":"вњ‰пёЏ","envelope":"вњ‰пёЏ","fist":"вњЉ","hand":"вњ‹","raised_hand":"вњ‹","v":"вњЊпёЏ","writing_hand":"вњЌпёЏ","pencil2":"вњЏпёЏ","black_nib":"вњ’пёЏ","heavy_check_mark":"вњ”пёЏ","heavy_multiplication_x":"вњ–пёЏ","latin_cross":"вњќпёЏ","star_of_david":"вњЎпёЏ","eight_spoked_asterisk":"вњіпёЏ","eight_pointed_black_star":"вњґпёЏ","snowflake":"вќ„пёЏ","sparkle":"вќ‡пёЏ","x":"вќЊ","negative_squared_cross_mark":"вќЋ","heavy_heart_exclamation_mark_ornament":"вќЈпёЏ","heart_on_fire":"вќ¤пёЏвЂЌрџ”Ґ","mending_heart":"вќ¤пёЏвЂЌрџ©№","heart":"вќ¤пёЏ","arrow_right":"вћЎпёЏ","curly_loop":"вћ°","loop":"вћї","arrow_heading_up":"в¤ґпёЏ","arrow_heading_down":"в¤µпёЏ","arrow_left":"в¬…пёЏ","arrow_up":"в¬†пёЏ","arrow_down":"в¬‡пёЏ","black_large_square":"в¬›","white_large_square":"в¬њ","star":"в­ђ","o":"в­•","wavy_dash":"гЂ°пёЏ","part_alternation_mark":"гЂЅпёЏ","congratulations":"гЉ—пёЏ","secret":"гЉ™пёЏ"}';

  final Map<String, Emoji> _emojisByName = <String, Emoji>{};
  final Map<String?, Emoji> _emojisByCode = <String, Emoji>{};

  EmojiParser({bool init = true}) {
    if (init == true) {
      initLocalData();
    }
  }

  void initLocalData() {
    _init(jsonEmoji);
  }

  void _init(String dataset) {
    Map<String, dynamic> mapEmojis = jsonDecode(dataset);
    mapEmojis.forEach((k, v) {
      _emojisByName[k] = Emoji(k, v);
      _emojisByCode[EmojiUtil.stripNSM(v)] = Emoji(k, v);
    });
  }

  bool hasEmoji(String? emoji) {
    return _emojisByCode.containsKey(EmojiUtil.stripNSM(emoji));
  }

  ///
  /// Get emoji based on emoji code.
  ///
  /// For example:
  ///
  ///   var parser = EmojiParser();
  ///   var emojiHeart = parser.getEmoji('вќ¤');
  ///   print(emojiHeart); '{name: heart, full: :heart:, emoji: вќ¤пёЏ}'
  ///
  /// Returns Emoji.None if not found.
  ///
  Emoji getEmoji(String? emoji) {
    return _emojisByCode[EmojiUtil.stripNSM(emoji)] ?? Emoji.none;
  }

  ///
  /// This method will unemojify the text containing the Unicode emoji symbols
  /// into emoji name.
  ///
  /// For example: 'I вќ¤пёЏ Flutter' => 'I :heart: Flutter'
  ///
  String unemojify(String text) {
    if (text.isEmpty) return text;

    final characters = Characters(text);
    final buffer = StringBuffer();
    for (final character in characters) {
      if (hasEmoji(character)) {
        var result = character;
        result = result.replaceAll(
          character,
          getEmoji(character).full,
        );

        buffer.write(result);
      } else {
        buffer.write(character);
      }
    }
    return buffer.toString();
  }

  ///
  /// Return a list of emojis found in the input text
  ///
  /// For example: parseEmojis('I вќ¤пёЏ Flutter just like в•') => ['вќ¤пёЏ', 'в•']
  ///
  List<String> parseEmojis(String text) {
    if (text.isEmpty) return List.empty();

    List<String> result = <String>[];
    for (final character in text.characters) {
      if (hasEmoji(character)) {
        result.add(character);
      }
    }
    return result;
  }
}



===== FILE: vendor\chatview\src\utils\measure_size.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';

/// This widget has been created for size of widget which is covered in view port
/// It also gives update when size changes.
class MeasureSize extends StatefulWidget {
  const MeasureSize({
    Key? key,
    required this.onSizeChange,
    required this.child,
  }) : super(key: key);
  final Widget? child;
  final ValueSetter<bool> onSizeChange;

  @override
  State<MeasureSize> createState() => _MeasureSizeState();
}

class _MeasureSizeState extends State<MeasureSize> {
  @override
  Widget build(BuildContext context) {
    WidgetsBinding.instance.addPostFrameCallback(postFrameCallback);
    return Container(
      key: widgetKey,
      child: widget.child,
    );
  }

  GlobalKey widgetKey = GlobalKey();
  Size? oldSize;

  void postFrameCallback(Duration timestamp) {
    var currentContext = widgetKey.currentContext;
    if (currentContext == null) return;

    var newSize = currentContext.size;
    if (oldSize == newSize) return;
    oldSize = newSize;
    RenderBox? box = widgetKey.currentContext?.findRenderObject() as RenderBox?;
    Offset position = box!.localToGlobal(Offset.zero);

    /// Below logic checks that end position of widget greater than or less than
    /// to device width
    widget.onSizeChange(
        (position.dx + newSize!.width) >= MediaQuery.of(context).size.width);
  }
}



===== FILE: vendor\chatview\src\utils\package_strings.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'chat_view_locale.dart';

class PackageStrings {
  static final Map<String, ChatViewLocale> _localeObjects = {
    'en': ChatViewLocale.en,
  };

  static String _currentLocale = 'en';

  /// Set the current locale for the package strings (e.g., 'en', 'es').
  static void setLocale(String locale) {
    assert(_localeObjects.containsKey(locale),
        'Locale "$locale" not found. Please add it using PackageStrings.addLocaleObject("$locale", ChatViewLocale(...)) before setting.');
    if (_localeObjects.containsKey(locale)) {
      _currentLocale = locale;
    }
  }

  /// Allow developers to add or override locales at runtime using a class
  static void addLocaleObject(String locale, ChatViewLocale localeObj) {
    _localeObjects[locale] = localeObj;
  }

  static ChatViewLocale get currentLocale =>
      _localeObjects[_currentLocale] ?? ChatViewLocale.en;
}



===== FILE: vendor\chatview\src\utils\timeago\en_messages.dart =====
// This code is sourced from the timeago package available on pub.dev. link : https://pub.dev/packages/timeago

import 'package:chatview/src/utils/timeago/lookupmessages.dart';

/// English Messages
class EnMessages implements LookupMessages {
  @override
  String prefixAgo() => '';
  @override
  String prefixFromNow() => '';
  @override
  String suffixAgo() => 'ago';
  @override
  String suffixFromNow() => 'from now';
  @override
  String lessThanOneMinute(int seconds) => 'a moment';
  @override
  String aboutAMinute(int minutes) => 'a minute';
  @override
  String minutes(int minutes) => '$minutes minutes';
  @override
  String aboutAnHour(int minutes) => 'about an hour';
  @override
  String hours(int hours) => '$hours hours';
  @override
  String aDay(int hours) => 'a day';
  @override
  String days(int days) => '$days days';
  @override
  String aboutAMonth(int days) => 'about a month';
  @override
  String months(int months) => '$months months';
  @override
  String aboutAYear(int year) => 'about a year';
  @override
  String years(int years) => '$years years';
  @override
  String wordSeparator() => ' ';
}

/// English short Messages
class EnShortMessages implements LookupMessages {
  @override
  String prefixAgo() => '';
  @override
  String prefixFromNow() => '';
  @override
  String suffixAgo() => '';
  @override
  String suffixFromNow() => '';
  @override
  String lessThanOneMinute(int seconds) => 'now';
  @override
  String aboutAMinute(int minutes) => '1m';
  @override
  String minutes(int minutes) => '${minutes}m';
  @override
  String aboutAnHour(int minutes) => '~1h';
  @override
  String hours(int hours) => '${hours}h';
  @override
  String aDay(int hours) => '~1d';
  @override
  String days(int days) => '${days}d';
  @override
  String aboutAMonth(int days) => '~1mo';
  @override
  String months(int months) => '${months}mo';
  @override
  String aboutAYear(int year) => '~1y';
  @override
  String years(int years) => '${years}y';
  @override
  String wordSeparator() => ' ';
}



===== FILE: vendor\chatview\src\utils\timeago\lookupmessages.dart =====
// This code is sourced from the timeago package available on pub.dev. link: https://pub.dev/packages/timeago

/// [LookupMessages] template for any language
///
///
abstract class LookupMessages {
  /// Example: `prefixAgo()` 1 min `suffixAgo()`
  String prefixAgo();

  /// Example: `prefixFromNow()` 1 min `suffixFromNow()`
  String prefixFromNow();

  /// Example: `prefixAgo()` 1 min `suffixAgo()`
  String suffixAgo();

  /// Example: `prefixFromNow()` 1 min `suffixFromNow()`
  String suffixFromNow();

  /// Format when time is less than a minute
  String lessThanOneMinute(int seconds);

  /// Format when time is about a minute
  String aboutAMinute(int minutes);

  /// Format when time is in minutes
  String minutes(int minutes);

  /// Format when time is about an hour
  String aboutAnHour(int minutes);

  /// Format when time is in hours
  String hours(int hours);

  /// Format when time is a day
  String aDay(int hours);

  /// Format when time is in days
  String days(int days);

  /// Format when time is about a month
  String aboutAMonth(int days);

  /// Format when time is in months
  String months(int months);

  /// Format when time is about a year
  String aboutAYear(int year);

  /// Format when time is about a year
  String years(int years);

  /// word separator when words are concatenated
  String wordSeparator() => ' ';
}



===== FILE: vendor\chatview\src\utils\timeago\timeago.dart =====
// This code is sourced from the timeago package available on pub.dev. link: https://pub.dev/packages/timeago

import 'package:chatview/src/utils/timeago/en_messages.dart';
import 'package:chatview/src/utils/timeago/lookupmessages.dart';
import 'package:flutter/foundation.dart';

String _default = 'en';

Map<String, LookupMessages> _lookupMessagesMap = {
  'en': EnMessages(),
  'en_short': EnShortMessages(),
};

/// Sets the default [locale]. By default it is `en`.
///
/// Example
/// ```
/// setLocaleMessages('fr', FrMessages());
/// setDefaultLocale('fr');
/// ```
void setDefaultLocale(String locale) {
  assert(_lookupMessagesMap.containsKey(locale),
      '[locale] must be a registered locale');
  _default = locale;
}

/// Sets a [locale] with the provided [lookupMessages] to be available when
/// using the [format] function.
///
/// Example:
/// ```dart
/// setLocaleMessages('fr', FrMessages());
/// ```
///
/// If you want to define locale message implement [LookupMessages] interface
/// with the desired messages
///
void setLocaleMessages(String locale, LookupMessages lookupMessages) {
  _lookupMessagesMap[locale] = lookupMessages;
}

/// Formats provided [date] to a fuzzy time like 'a moment ago'
///
/// - If [locale] is passed will look for message for that locale, if you want
///   to add or override locales use [setLocaleMessages]. Defaults to 'en'
/// - If [clock] is passed this will be the point of reference for calculating
///   the elapsed time. Defaults to DateTime.now()
/// - If [allowFromNow] is passed, format will use the From prefix, ie. a date
///   5 minutes from now in 'en' locale will display as "5 minutes from now"
String format(DateTime date,
    {String? locale, DateTime? clock, bool allowFromNow = false}) {
  final locale0 = locale ?? _default;
  if (_lookupMessagesMap[locale0] == null) {
    debugPrint(
        "Locale [$locale0] has not been added, using [$_default] as fallback. To add a locale use [setLocaleMessages]");
  }
  final allowFromNow0 = allowFromNow;
  final messages = _lookupMessagesMap[locale0] ?? EnMessages();
  final clock0 = clock ?? DateTime.now();
  var elapsed = clock0.millisecondsSinceEpoch - date.millisecondsSinceEpoch;

  String prefix, suffix;

  if (allowFromNow0 && elapsed < 0) {
    elapsed = date.isBefore(clock0) ? elapsed : elapsed.abs();
    prefix = messages.prefixFromNow();
    suffix = messages.suffixFromNow();
  } else {
    prefix = messages.prefixAgo();
    suffix = messages.suffixAgo();
  }

  final num seconds = elapsed / 1000;
  final num minutes = seconds / 60;
  final num hours = minutes / 60;
  final num days = hours / 24;
  final num months = days / 30;
  final num years = days / 365;

  String result;
  if (seconds < 45) {
    result = messages.lessThanOneMinute(seconds.round());
  } else if (seconds < 90) {
    result = messages.aboutAMinute(minutes.round());
  } else if (minutes < 45) {
    result = messages.minutes(minutes.round());
  } else if (minutes < 90) {
    result = messages.aboutAnHour(minutes.round());
  } else if (hours < 24) {
    result = messages.hours(hours.round());
  } else if (hours < 48) {
    result = messages.aDay(hours.round());
  } else if (days < 30) {
    result = messages.days(days.round());
  } else if (days < 60) {
    result = messages.aboutAMonth(days.round());
  } else if (days < 365) {
    result = messages.months(months.round());
  } else if (years < 2) {
    result = messages.aboutAYear(months.round());
  } else {
    result = messages.years(years.round());
  }

  return [prefix, result, suffix]
      .where((str) => str.isNotEmpty)
      .join(messages.wordSeparator());
}



===== FILE: vendor\chatview\src\values\custom_time_messages.dart =====
import '../utils/timeago/lookupmessages.dart';

// Override "en" locale messages with custom messages that are more precise and short
// setLocaleMessages('en', ReceiptsCustomMessages())

// my_custom_messages.dart
class ReceiptsCustomMessages implements LookupMessages {
  @override
  String prefixAgo() => '';
  @override
  String prefixFromNow() => '';
  @override
  String suffixAgo() => '';
  @override
  String suffixFromNow() => '';
  @override
  String lessThanOneMinute(int seconds) => 'now';
  @override
  String aboutAMinute(int minutes) => '$minutes m ago';
  @override
  String minutes(int minutes) => '$minutes m ago';
  @override
  String aboutAnHour(int minutes) => '$minutes m ago';
  @override
  String hours(int hours) => '$hours h ago';
  @override
  String aDay(int hours) => '$hours h ago';
  @override
  String days(int days) => '$days d ago';
  @override
  String aboutAMonth(int days) => '$days d ago';
  @override
  String months(int months) => '$months mo ago';
  @override
  String aboutAYear(int year) => '$year y ago';
  @override
  String years(int years) => '$years y ago';
  @override
  String wordSeparator() => ' ';
}



===== FILE: vendor\chatview\src\values\enumeration.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// Different types Message of ChatView

import 'package:flutter/material.dart';
import 'package:chatview_utils/chatview_utils.dart';

enum ShowReceiptsIn { all, lastMessage }

enum SuggestionListAlignment {
  left(Alignment.bottomLeft),
  center(Alignment.bottomCenter),
  right(Alignment.bottomRight);

  const SuggestionListAlignment(this.alignment);

  final Alignment alignment;
}

extension ChatViewStateExtension on ChatViewState {
  bool get hasMessages => this == ChatViewState.hasMessages;

  bool get isLoading => this == ChatViewState.loading;

  bool get isError => this == ChatViewState.error;

  bool get noMessages => this == ChatViewState.noData;
}

enum GroupedListOrder { asc, desc }

extension GroupedListOrderExtension on GroupedListOrder {
  bool get isAsc => this == GroupedListOrder.asc;

  bool get isDesc => this == GroupedListOrder.desc;
}

enum ScrollButtonAlignment {
  left(Alignment.bottomLeft),
  center(Alignment.bottomCenter),
  right(Alignment.bottomRight);

  const ScrollButtonAlignment(this.alignment);

  final Alignment alignment;
}

enum SuggestionItemsType {
  scrollable,
  multiline;

  bool get isScrollType => this == SuggestionItemsType.scrollable;

  bool get isMultilineType => this == SuggestionItemsType.multiline;
}



===== FILE: vendor\chatview\src\values\typedefs.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

typedef StringMessageCallBack = void Function(
  String message,
  ReplyMessage replyMessage,
  MessageType messageType,
);
typedef ReplyMessageWithReturnWidget = Widget Function(
  ReplyMessage? replyMessage,
);
typedef DoubleCallBack = void Function(
  double yPosition,
  double xPosition,
);
typedef StringsCallBack = void Function(String emoji, String messageId);
typedef StringWithReturnWidget = Widget Function(String separator);
typedef DragUpdateDetailsCallback = void Function(DragUpdateDetails);
typedef MoreTapCallBack = void Function(
  Message message,
  bool sentByCurrentUser,
);
typedef ReactionCallback = void Function(
  Message message,
  String emoji,
);
typedef ReactedUserCallback = void Function(
  ChatUser reactedUser,
  String reaction,
);

/// customMessageType view for a reply of custom message type
typedef CustomMessageReplyViewBuilder = Widget Function(
  ReplyMessage state,
);
typedef MessageSorter = int Function(
  Message message1,
  Message message2,
);

/// customView for replying to any message
typedef CustomViewForReplyMessage = Widget Function(
  BuildContext context,
  ReplyMessage state,
);
typedef GetMessageSeparator = (
  Map<int, DateTime> messageSeparator,
  DateTime dateTime,
);
typedef SelectedImageViewBuilder = Widget Function(
  List<String> images,
  ValueSetter<String> onImageRemove,
);
typedef CustomMessageBuilder = Widget Function(Message message);
typedef ReceiptBuilder = Widget Function(MessageStatus status);
typedef LastSeenAgoBuilder = Widget Function(
  Message message,
  String formattedDate,
);
typedef ReplyPopupBuilder = Widget Function(
  Message message,
  bool sentByCurrentUser,
);
typedef ImagePickedCallback = Future<String?> Function(String? path);
typedef OnMessageSwipeCallback = void Function(
  String message,
  String sentBy,
);
typedef ChatBubbleLongPressCallback = void Function(
  double yCordinate,
  double xCordinate,
  Message message,
);
typedef ChatTextFieldViewBuilderCallback<T> = Widget Function(
  BuildContext context,
  T value,
  Widget? child,
);



===== FILE: vendor\chatview\src\widgets\chat_bubble_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/config_models/feature_active_config.dart';
import '../utils/constants/constants.dart';
import '../values/enumeration.dart';
import '../values/typedefs.dart';
import 'chat_view_inherited_widget.dart';
import 'message_time_widget.dart';
import 'message_view.dart';
import 'profile_circle.dart';
import 'reply_message_widget.dart';
import 'swipe_to_reply.dart';

class ChatBubbleWidget extends StatefulWidget {
  const ChatBubbleWidget({
    required GlobalKey key,
    required this.message,
    required this.onLongPress,
    required this.slideAnimation,
    required this.onSwipe,
    this.onReplyTap,
    this.shouldHighlight = false,
  }) : super(key: key);

  /// Represent current instance of message.
  final Message message;

  /// Give callback once user long press on chat bubble.
  final DoubleCallBack onLongPress;

  /// Provides callback of when user swipe chat bubble for reply.
  final ValueSetter<Message> onSwipe;

  /// Provides slide animation when user swipe whole chat.
  final Animation<Offset>? slideAnimation;

  /// Provides callback when user tap on replied message upon chat bubble.
  final ValueSetter<String>? onReplyTap;

  /// Flag for when user tap on replied message and highlight actual message.
  final bool shouldHighlight;

  @override
  State<ChatBubbleWidget> createState() => _ChatBubbleWidgetState();
}

class _ChatBubbleWidgetState extends State<ChatBubbleWidget> {
  String get replyMessage => widget.message.replyMessage.message;

  bool get isMessageBySender => widget.message.sentBy == currentUser?.id;

  bool get isLastMessage =>
      chatController?.initialMessageList.last.id == widget.message.id;

  FeatureActiveConfig? featureActiveConfig;
  ChatController? chatController;
  ChatUser? currentUser;
  int? maxDuration;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (chatViewIW != null) {
      featureActiveConfig = chatViewIW!.featureActiveConfig;
      chatController = chatViewIW!.chatController;
      currentUser = chatController?.currentUser;
    }
  }

  @override
  Widget build(BuildContext context) {
    // Get user from id.
    final messagedUser = chatController?.getUserFromId(widget.message.sentBy);
    return Stack(
      children: [
        if (featureActiveConfig?.enableSwipeToSeeTime ?? true) ...[
          Visibility(
            visible: widget.slideAnimation?.value.dx == 0.0 ? false : true,
            child: Positioned.fill(
              child: Align(
                alignment: Alignment.centerRight,
                child: MessageTimeWidget(
                  messageTime: widget.message.createdAt,
                  isCurrentUser: isMessageBySender,
                ),
              ),
            ),
          ),
          SlideTransition(
            position: widget.slideAnimation!,
            child: _chatBubbleWidget(messagedUser),
          ),
        ] else
          _chatBubbleWidget(messagedUser),
      ],
    );
  }

  Widget _chatBubbleWidget(ChatUser? messagedUser) {
    final chatBubbleConfig = chatListConfig.chatBubbleConfig;
    return Container(
      padding: chatBubbleConfig?.padding ?? const EdgeInsets.only(left: 5.0),
      margin: chatBubbleConfig?.margin ?? const EdgeInsets.only(bottom: 10),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment:
            isMessageBySender ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (!isMessageBySender &&
              (featureActiveConfig?.enableOtherUserProfileAvatar ?? true))
            profileCircle(messagedUser),
          Expanded(
            child: _messagesWidgetColumn(messagedUser),
          ),
          if (isMessageBySender) ...[getReceipt()],
          if (isMessageBySender &&
              (featureActiveConfig?.enableCurrentUserProfileAvatar ?? true))
            profileCircle(messagedUser),
        ],
      ),
    );
  }

  ProfileCircle profileCircle(ChatUser? messagedUser) {
    final profileCircleConfig = chatListConfig.profileCircleConfig;
    return ProfileCircle(
      bottomPadding: widget.message.reaction.reactions.isNotEmpty
          ? profileCircleConfig?.bottomPadding ?? 15
          : profileCircleConfig?.bottomPadding ?? 2,
      profileCirclePadding: profileCircleConfig?.padding,
      imageUrl: messagedUser?.profilePhoto,
      imageType: messagedUser?.imageType,
      defaultAvatarImage:
          messagedUser?.defaultAvatarImage ?? Constants.profileImage,
      networkImageProgressIndicatorBuilder:
          messagedUser?.networkImageProgressIndicatorBuilder,
      assetImageErrorBuilder: messagedUser?.assetImageErrorBuilder,
      networkImageErrorBuilder: messagedUser?.networkImageErrorBuilder,
      circleRadius: profileCircleConfig?.circleRadius,
      onTap: () => _onAvatarTap(messagedUser),
      onLongPress: () => _onAvatarLongPress(messagedUser),
    );
  }

  void onRightSwipe() {
    if (maxDuration != null) {
      widget.message.voiceMessageDuration =
          Duration(milliseconds: maxDuration!);
    }
    if (chatListConfig.swipeToReplyConfig?.onRightSwipe != null) {
      chatListConfig.swipeToReplyConfig?.onRightSwipe!(
          widget.message.message, widget.message.sentBy);
    }
    widget.onSwipe(widget.message);
  }

  void onLeftSwipe() {
    if (maxDuration != null) {
      widget.message.voiceMessageDuration =
          Duration(milliseconds: maxDuration!);
    }
    if (chatListConfig.swipeToReplyConfig?.onLeftSwipe != null) {
      chatListConfig.swipeToReplyConfig?.onLeftSwipe!(
          widget.message.message, widget.message.sentBy);
    }
    widget.onSwipe(widget.message);
  }

  void _onAvatarTap(ChatUser? user) {
    if (chatListConfig.profileCircleConfig?.onAvatarTap != null &&
        user != null) {
      chatListConfig.profileCircleConfig?.onAvatarTap!(user);
    }
  }

  Widget getReceipt() {
    final showReceipts = chatListConfig.chatBubbleConfig
            ?.outgoingChatBubbleConfig?.receiptsWidgetConfig?.showReceiptsIn ??
        ShowReceiptsIn.lastMessage;
    if (showReceipts == ShowReceiptsIn.all) {
      return ValueListenableBuilder(
        valueListenable: widget.message.statusNotifier,
        builder: (context, value, child) {
          if (ChatViewInheritedWidget.of(context)
                  ?.featureActiveConfig
                  .receiptsBuilderVisibility ??
              true) {
            return chatListConfig.chatBubbleConfig?.outgoingChatBubbleConfig
                    ?.receiptsWidgetConfig?.receiptsBuilder
                    ?.call(value) ??
                sendMessageAnimationBuilder(value);
          }
          return const SizedBox();
        },
      );
    } else if (showReceipts == ShowReceiptsIn.lastMessage && isLastMessage) {
      return ValueListenableBuilder(
          valueListenable:
              chatController!.initialMessageList.last.statusNotifier,
          builder: (context, value, child) {
            if (ChatViewInheritedWidget.of(context)
                    ?.featureActiveConfig
                    .receiptsBuilderVisibility ??
                true) {
              return chatListConfig.chatBubbleConfig?.outgoingChatBubbleConfig
                      ?.receiptsWidgetConfig?.receiptsBuilder
                      ?.call(value) ??
                  sendMessageAnimationBuilder(value);
            }
            return sendMessageAnimationBuilder(value);
          });
    }
    return const SizedBox();
  }

  void _onAvatarLongPress(ChatUser? user) {
    if (chatListConfig.profileCircleConfig?.onAvatarLongPress != null &&
        user != null) {
      chatListConfig.profileCircleConfig?.onAvatarLongPress!(user);
    }
  }

  Widget _messagesWidgetColumn(ChatUser? messagedUser) {
    return Column(
      crossAxisAlignment:
          isMessageBySender ? CrossAxisAlignment.end : CrossAxisAlignment.start,
      children: [
        if ((chatController?.otherUsers.isNotEmpty ?? false) &&
            !isMessageBySender &&
            (featureActiveConfig?.enableOtherUserName ?? true))
          Padding(
            padding: chatListConfig
                    .chatBubbleConfig?.inComingChatBubbleConfig?.padding ??
                const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            child: Text(
              messagedUser?.name ?? '',
              style: chatListConfig.chatBubbleConfig?.inComingChatBubbleConfig
                  ?.senderNameTextStyle,
            ),
          ),
        if (replyMessage.isNotEmpty)
          chatListConfig.repliedMessageConfig?.repliedMessageWidgetBuilder !=
                  null
              ? chatListConfig.repliedMessageConfig!
                  .repliedMessageWidgetBuilder!(widget.message.replyMessage)
              : ReplyMessageWidget(
                  message: widget.message,
                  repliedMessageConfig: chatListConfig.repliedMessageConfig,
                  onTap: () => widget.onReplyTap
                      ?.call(widget.message.replyMessage.messageId),
                ),
        SwipeToReply(
          isMessageByCurrentUser: isMessageBySender,
          onSwipe: isMessageBySender ? onLeftSwipe : onRightSwipe,
          child: MessageView(
            outgoingChatBubbleConfig:
                chatListConfig.chatBubbleConfig?.outgoingChatBubbleConfig,
            isLongPressEnable:
                (featureActiveConfig?.enableReactionPopup ?? true) ||
                    (featureActiveConfig?.enableReplySnackBar ?? true),
            inComingChatBubbleConfig:
                chatListConfig.chatBubbleConfig?.inComingChatBubbleConfig,
            message: widget.message,
            isMessageBySender: isMessageBySender,
            messageConfig: chatListConfig.messageConfig,
            onLongPress: widget.onLongPress,
            chatBubbleMaxWidth: chatListConfig.chatBubbleConfig?.maxWidth,
            longPressAnimationDuration:
                chatListConfig.chatBubbleConfig?.longPressAnimationDuration,
            onDoubleTap: featureActiveConfig?.enableDoubleTapToLike ?? false
                ? chatListConfig.chatBubbleConfig?.onDoubleTap ??
                    (message) => currentUser != null
                        ? chatController?.setReaction(
                            emoji: heart,
                            messageId: message.id,
                            userId: currentUser!.id,
                          )
                        : null
                : null,
            shouldHighlight: widget.shouldHighlight,
            controller: chatController,
            highlightColor: chatListConfig.repliedMessageConfig
                    ?.repliedMsgAutoScrollConfig.highlightColor ??
                Colors.grey,
            highlightScale: chatListConfig.repliedMessageConfig
                    ?.repliedMsgAutoScrollConfig.highlightScale ??
                1.1,
            onMaxDuration: _onMaxDuration,
          ),
        ),
      ],
    );
  }

  void _onMaxDuration(int duration) => maxDuration = duration;
}



===== FILE: vendor\chatview\src\widgets\chat_group_header.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/config_models/message_list_configuration.dart';
import '../utils/constants/constants.dart';

class ChatGroupHeader extends StatelessWidget {
  const ChatGroupHeader({
    Key? key,
    required this.day,
    this.groupSeparatorConfig,
  }) : super(key: key);

  /// Provides day of started chat.
  final DateTime day;

  /// Provides configuration for separator upon date wise chat.
  final DefaultGroupSeparatorConfiguration? groupSeparatorConfig;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: groupSeparatorConfig?.padding ??
          const EdgeInsets.symmetric(vertical: 12),
      child: Text(
        day.getDay(
          groupSeparatorConfig?.chatSeparatorDatePattern ??
              defaultChatSeparatorDatePattern,
        ),
        textAlign: TextAlign.center,
        style: groupSeparatorConfig?.textStyle ?? const TextStyle(fontSize: 17),
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\chat_groupedlist_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/config_models/feature_active_config.dart';
import '../models/config_models/message_list_configuration.dart';
import '../models/config_models/send_message_configuration.dart';
import '../models/config_models/suggestion_list_config.dart';
import '../values/enumeration.dart';
import '../values/typedefs.dart';
import 'chat_bubble_widget.dart';
import 'chat_group_header.dart';
import 'suggestions/suggestion_list.dart';
import 'type_indicator_widget.dart';

class ChatGroupedListWidget extends StatefulWidget {
  const ChatGroupedListWidget({
    Key? key,
    required this.showPopUp,
    required this.scrollController,
    required this.assignReplyMessage,
    required this.onChatListTap,
    required this.onChatBubbleLongPress,
    required this.isEnableSwipeToSeeTime,
    this.textFieldConfig,
  }) : super(key: key);

  /// Allow user to swipe to see time while reaction pop is not open.
  final bool showPopUp;

  /// Pass scroll controller
  final ScrollController scrollController;

  /// Provides callback for assigning reply message when user swipe on chat bubble.
  final ValueSetter<Message> assignReplyMessage;

  /// Provides callback when user tap anywhere on whole chat.
  final VoidCallback onChatListTap;

  /// Provides callback when user press chat bubble for certain time then usual.
  final ChatBubbleLongPressCallback onChatBubbleLongPress;

  /// Provide flag for turn on/off to see message crated time view when user
  /// swipe whole chat.
  final bool isEnableSwipeToSeeTime;

  /// Provides configuration for text field.
  final TextFieldConfiguration? textFieldConfig;

  @override
  State<ChatGroupedListWidget> createState() => _ChatGroupedListWidgetState();
}

class _ChatGroupedListWidgetState extends State<ChatGroupedListWidget>
    with TickerProviderStateMixin {
  bool get showPopUp => widget.showPopUp;

  bool highlightMessage = false;
  final ValueNotifier<String?> _replyId = ValueNotifier(null);

  AnimationController? _animationController;
  Animation<Offset>? _slideAnimation;

  FeatureActiveConfig? featureActiveConfig;

  ChatController? chatController;

  bool get isEnableSwipeToSeeTime => widget.isEnableSwipeToSeeTime;

  ChatBackgroundConfiguration get chatBackgroundConfig =>
      chatListConfig.chatBackgroundConfig;

  @override
  void initState() {
    super.initState();
    _initializeAnimation();
  }

  void _initializeAnimation() {
    // When this flag is on at that time only animation controllers will be
    // initialized.
    if (isEnableSwipeToSeeTime) {
      _animationController = AnimationController(
        vsync: this,
        duration: const Duration(milliseconds: 250),
      );
      _slideAnimation = Tween<Offset>(
        begin: const Offset(0.0, 0.0),
        end: const Offset(0.0, 0.0),
      ).animate(
        CurvedAnimation(
          curve: Curves.decelerate,
          parent: _animationController!,
        ),
      );
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (chatViewIW != null) {
      featureActiveConfig = chatViewIW!.featureActiveConfig;
      chatController = chatViewIW!.chatController;
    }
    _initializeAnimation();
  }

  @override
  Widget build(BuildContext context) {
    final suggestionsListConfig =
        suggestionsConfig?.listConfig ?? const SuggestionListConfig();
    return SingleChildScrollView(
      reverse: true,
      // When reaction popup is being appeared at that user should not scroll.
      physics: showPopUp ? const NeverScrollableScrollPhysics() : null,
      controller: widget.scrollController,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          GestureDetector(
            onHorizontalDragUpdate: (details) =>
                isEnableSwipeToSeeTime && !showPopUp
                    ? _onHorizontalDrag(details)
                    : null,
            onHorizontalDragEnd: (details) =>
                isEnableSwipeToSeeTime && !showPopUp
                    ? _animationController?.reverse()
                    : null,
            onTap: widget.onChatListTap,
            child: _animationController != null
                ? AnimatedBuilder(
                    animation: _animationController!,
                    builder: (context, child) {
                      return _chatStreamBuilder;
                    },
                  )
                : _chatStreamBuilder,
          ),
          if (chatController != null)
            ValueListenableBuilder(
              valueListenable: chatController!.typingIndicatorNotifier,
              builder: (context, value, child) => TypingIndicator(
                typeIndicatorConfig: chatListConfig.typeIndicatorConfig,
                chatBubbleConfig:
                    chatListConfig.chatBubbleConfig?.inComingChatBubbleConfig,
                showIndicator: value,
              ),
            ),
          if (chatController != null)
            Flexible(
              child: Align(
                alignment: suggestionsListConfig.axisAlignment.alignment,
                child: const SuggestionList(),
              ),
            ),

          // Adds bottom space to the message list, ensuring it is displayed
          // above the message text field.
          if (chatViewIW case final chatViewIWNonNull?)
            ValueListenableBuilder<double>(
              valueListenable: chatViewIWNonNull.chatTextFieldHeight,
              builder: (_, value, __) => SizedBox(height: value),
            ),
        ],
      ),
    );
  }

  Future<void> _onReplyTap(String id, List<Message>? messages) async {
    // Finds the replied message if exists
    final repliedMessages = messages?.firstWhere((message) => id == message.id);
    final repliedMsgAutoScrollConfig =
        chatListConfig.repliedMessageConfig?.repliedMsgAutoScrollConfig;
    final highlightDuration = repliedMsgAutoScrollConfig?.highlightDuration ??
        const Duration(milliseconds: 300);
    // Scrolls to replied message and highlights
    if (repliedMessages != null && repliedMessages.key.currentState != null) {
      await Scrollable.ensureVisible(
        repliedMessages.key.currentState!.context,
        // This value will make widget to be in center when auto scrolled.
        alignment: 0.5,
        curve:
            repliedMsgAutoScrollConfig?.highlightScrollCurve ?? Curves.easeIn,
        duration: highlightDuration,
      );
      if (repliedMsgAutoScrollConfig?.enableHighlightRepliedMsg ?? false) {
        _replyId.value = id;

        Future.delayed(highlightDuration, () {
          _replyId.value = null;
        });
      }
    }
  }

  /// When user swipe at that time only animation is assigned with value.
  void _onHorizontalDrag(DragUpdateDetails details) {
    _slideAnimation = Tween<Offset>(
      begin: const Offset(0.0, 0.0),
      end: const Offset(-0.2, 0.0),
    ).animate(
      CurvedAnimation(
        curve: chatBackgroundConfig.messageTimeAnimationCurve,
        parent: _animationController!,
      ),
    );

    details.delta.dx > 1
        ? _animationController?.reverse()
        : _animationController?.forward();
  }

  @override
  void dispose() {
    _animationController?.dispose();
    _replyId.dispose();
    super.dispose();
  }

  Widget get _chatStreamBuilder {
    DateTime lastMatchedDate = DateTime.now();
    return StreamBuilder<List<Message>>(
      stream: chatController?.messageStreamController.stream,
      builder: (context, snapshot) {
        if (!snapshot.connectionState.isActive) {
          return Center(
            child: chatBackgroundConfig.loadingWidget ??
                const CircularProgressIndicator(),
          );
        } else {
          final messages = chatBackgroundConfig.sortEnable
              ? sortMessage(snapshot.data!)
              : snapshot.data!;

          final enableSeparator =
              featureActiveConfig?.enableChatSeparator ?? false;

          Map<int, DateTime> messageSeparator = {};

          if (enableSeparator) {
            /// Get separator when date differ for two messages
            (messageSeparator, lastMatchedDate) = _getMessageSeparator(
              messages,
              lastMatchedDate,
            );
          }

          /// [count] that indicates how many separators
          /// needs to be display in chat
          var count = 0;

          return ListView.builder(
            key: widget.key,
            physics: const NeverScrollableScrollPhysics(),
            padding: EdgeInsets.zero,
            shrinkWrap: true,
            itemCount: (enableSeparator
                ? messages.length + messageSeparator.length
                : messages.length),
            itemBuilder: (context, index) {
              /// By removing [count] from [index] will get actual index
              /// to display message in chat
              var newIndex = index - count;

              /// Check [messageSeparator] contains group separator for [index]
              if (enableSeparator && messageSeparator.containsKey(index)) {
                /// Increase counter each time
                /// after separating messages with separator
                count++;
                return _groupSeparator(
                  messageSeparator[index]!,
                );
              }

              return ValueListenableBuilder<String?>(
                valueListenable: _replyId,
                builder: (context, state, child) {
                  final message = messages[newIndex];
                  final enableScrollToRepliedMsg = chatListConfig
                          .repliedMessageConfig
                          ?.repliedMsgAutoScrollConfig
                          .enableScrollToRepliedMsg ??
                      false;
                  return ChatBubbleWidget(
                    key: message.key,
                    message: message,
                    slideAnimation: _slideAnimation,
                    onLongPress: (yCoordinate, xCoordinate) =>
                        widget.onChatBubbleLongPress(
                      yCoordinate,
                      xCoordinate,
                      message,
                    ),
                    onSwipe: widget.assignReplyMessage,
                    shouldHighlight: state == message.id,
                    onReplyTap: enableScrollToRepliedMsg
                        ? (replyId) => _onReplyTap(replyId, snapshot.data)
                        : null,
                  );
                },
              );
            },
          );
        }
      },
    );
  }

  List<Message> sortMessage(List<Message> messages) {
    final elements = [...messages];
    elements.sort(
      chatBackgroundConfig.messageSorter ??
          (a, b) => a.createdAt.compareTo(b.createdAt),
    );
    if (chatBackgroundConfig.groupedListOrder.isAsc) {
      return elements.toList();
    } else {
      return elements.reversed.toList();
    }
  }

  /// return DateTime by checking lastMatchedDate and message created DateTime
  DateTime _groupBy(
    Message message,
    DateTime lastMatchedDate,
  ) {
    /// If the conversation is ongoing on the same date,
    /// return the same date [lastMatchedDate].

    /// When the conversation starts on a new date,
    /// we are returning new date [message.createdAt].
    return lastMatchedDate.getDateFromDateTime ==
            message.createdAt.getDateFromDateTime
        ? lastMatchedDate
        : message.createdAt;
  }

  Widget _groupSeparator(DateTime createdAt) {
    return featureActiveConfig?.enableChatSeparator ?? false
        ? _GroupSeparatorBuilder(
            separator: createdAt,
            defaultGroupSeparatorConfig:
                chatBackgroundConfig.defaultGroupSeparatorConfig,
            groupSeparatorBuilder: chatBackgroundConfig.groupSeparatorBuilder,
          )
        : const SizedBox.shrink();
  }

  GetMessageSeparator _getMessageSeparator(
    List<Message> messages,
    DateTime lastDate,
  ) {
    final messageSeparator = <int, DateTime>{};
    var lastMatchedDate = lastDate;
    var counter = 0;

    /// Holds index and separator mapping to display in chat
    for (var i = 0; i < messages.length; i++) {
      if (messageSeparator.isEmpty) {
        /// Separator for initial message
        messageSeparator[0] = messages[0].createdAt;
        continue;
      }
      lastMatchedDate = _groupBy(
        messages[i],
        lastMatchedDate,
      );
      var previousDate = _groupBy(
        messages[i - 1],
        lastMatchedDate,
      );

      if (previousDate != lastMatchedDate) {
        /// Group separator when previous message and
        /// current message time differ
        counter++;

        messageSeparator[i + counter] = messages[i].createdAt;
      }
    }

    return (messageSeparator, lastMatchedDate);
  }
}

class _GroupSeparatorBuilder extends StatelessWidget {
  const _GroupSeparatorBuilder({
    Key? key,
    required this.separator,
    this.groupSeparatorBuilder,
    this.defaultGroupSeparatorConfig,
  }) : super(key: key);
  final DateTime separator;
  final StringWithReturnWidget? groupSeparatorBuilder;
  final DefaultGroupSeparatorConfiguration? defaultGroupSeparatorConfig;

  @override
  Widget build(BuildContext context) {
    return groupSeparatorBuilder != null
        ? groupSeparatorBuilder!(separator.toString())
        : ChatGroupHeader(
            day: separator,
            groupSeparatorConfig: defaultGroupSeparatorConfig,
          );
  }
}



===== FILE: vendor\chatview\src\widgets\chat_list_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'dart:async';
import 'dart:io' if (kIsWeb) 'dart:html';

import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';

import '../../chatview.dart';
import '../extensions/extensions.dart';
import 'chat_groupedlist_widget.dart';
import 'reply_popup_widget.dart';

class ChatListWidget extends StatefulWidget {
  const ChatListWidget({
    Key? key,
    required this.chatController,
    required this.assignReplyMessage,
    this.loadingWidget,
    this.loadMoreData,
    this.isLastPage,
    this.onChatListTap,
    this.textFieldConfig,
  }) : super(key: key);

  /// Provides controller for accessing few function for running chat.
  final ChatController chatController;

  /// Provides widget for loading view while pagination is enabled.
  final Widget? loadingWidget;

  /// Provides callback when user actions reaches to top and needs to load more
  /// chat
  final ValueGetter<Future<void>>? loadMoreData;

  /// Provides flag if there is no more next data left in list.
  final bool? isLastPage;

  /// Provides callback for assigning reply message when user swipe to chat
  /// bubble.
  final ValueSetter<Message> assignReplyMessage;

  /// Provides callback when user tap anywhere on whole chat.
  final VoidCallback? onChatListTap;

  /// Provides configuration for text field config.
  final TextFieldConfiguration? textFieldConfig;

  @override
  State<ChatListWidget> createState() => _ChatListWidgetState();
}

class _ChatListWidgetState extends State<ChatListWidget> {
  final ValueNotifier<bool> _isNextPageLoading = ValueNotifier<bool>(false);

  ChatController get chatController => widget.chatController;

  List<Message> get messageList => chatController.initialMessageList;

  ScrollController get scrollController => chatController.scrollController;

  FeatureActiveConfig? featureActiveConfig;
  ChatUser? currentUser;

  @override
  void initState() {
    super.initState();
    _initialize();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (chatViewIW != null) {
      featureActiveConfig = chatViewIW!.featureActiveConfig;
      currentUser = chatViewIW!.chatController.currentUser;
    }
    if (featureActiveConfig?.enablePagination ?? false) {
      // When flag is on then it will include pagination logic to scroll
      // controller.
      scrollController.addListener(_pagination);
    }
  }

  void _initialize() {
    chatController.messageStreamController = StreamController();
    if (!chatController.messageStreamController.isClosed) {
      chatController.messageStreamController.sink.add(messageList);
    }
    if (messageList.isNotEmpty) chatController.scrollToLastMessage();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        ValueListenableBuilder<bool>(
          valueListenable: _isNextPageLoading,
          builder: (_, isNextPageLoading, child) {
            if (isNextPageLoading &&
                (featureActiveConfig?.enablePagination ?? false)) {
              return SizedBox(
                height: Scaffold.of(context).appBarMaxHeight,
                child: Center(
                  child:
                      widget.loadingWidget ?? const CircularProgressIndicator(),
                ),
              );
            } else {
              return const SizedBox.shrink();
            }
          },
        ),
        Expanded(
          child: ValueListenableBuilder<bool>(
            valueListenable: chatViewIW!.showPopUp,
            builder: (_, showPopupValue, child) {
              return Stack(
                children: [
                  ChatGroupedListWidget(
                    showPopUp: showPopupValue,
                    scrollController: scrollController,
                    isEnableSwipeToSeeTime:
                        featureActiveConfig?.enableSwipeToSeeTime ?? true,
                    assignReplyMessage: widget.assignReplyMessage,
                    onChatBubbleLongPress: (yCoordinate, xCoordinate, message) {
                      if (featureActiveConfig?.enableReactionPopup ?? false) {
                        chatViewIW?.reactionPopupKey.currentState
                            ?.refreshWidget(
                          message: message,
                          xCoordinate: xCoordinate,
                          yCoordinate: yCoordinate,
                        );
                        chatViewIW?.showPopUp.value = true;
                      }
                      if (featureActiveConfig?.enableReplySnackBar ?? false) {
                        _showReplyPopup(
                          message: message,
                          sentByCurrentUser: message.sentBy == currentUser?.id,
                        );
                      }
                    },
                    onChatListTap: _onChatListTap,
                    textFieldConfig: widget.textFieldConfig,
                  ),
                ],
              );
            },
          ),
        ),
      ],
    );
  }

  void _pagination() {
    if (widget.loadMoreData == null || widget.isLastPage == true) return;
    if ((scrollController.position.pixels ==
            scrollController.position.maxScrollExtent) &&
        !_isNextPageLoading.value) {
      _isNextPageLoading.value = true;
      widget.loadMoreData!()
          .whenComplete(() => _isNextPageLoading.value = false);
    }
  }

  void _showReplyPopup({
    required Message message,
    required bool sentByCurrentUser,
  }) {
    final replyPopup = chatListConfig.replyPopupConfig;
    ScaffoldMessenger.of(context)
      ..clearSnackBars()
      ..showSnackBar(
        SnackBar(
          duration: const Duration(hours: 1),
          backgroundColor: replyPopup?.backgroundColor ?? Colors.white,
          content: replyPopup?.replyPopupBuilder != null
              ? replyPopup!.replyPopupBuilder!(message, sentByCurrentUser)
              : ReplyPopupWidget(
                  buttonTextStyle: replyPopup?.buttonTextStyle,
                  topBorderColor: replyPopup?.topBorderColor,
                  onMoreTap: () {
                    _onChatListTap();
                    replyPopup?.onMoreTap?.call(
                      message,
                      sentByCurrentUser,
                    );
                  },
                  onReportTap: () {
                    _onChatListTap();
                    replyPopup?.onReportTap?.call(
                      message,
                    );
                  },
                  onUnsendTap: () {
                    _onChatListTap();
                    replyPopup?.onUnsendTap?.call(
                      message,
                    );
                  },
                  onReplyTap: () {
                    widget.assignReplyMessage(message);
                    if (featureActiveConfig?.enableReactionPopup ?? false) {
                      chatViewIW?.showPopUp.value = false;
                    }
                    ScaffoldMessenger.of(context).hideCurrentSnackBar();
                    if (replyPopup?.onReplyTap != null) {
                      replyPopup?.onReplyTap!(message);
                    }
                  },
                  sentByCurrentUser: sentByCurrentUser,
                ),
          padding: EdgeInsets.zero,
        ),
      ).closed;
  }

  void _onChatListTap() {
    widget.onChatListTap?.call();
    if (!kIsWeb && (Platform.isIOS || Platform.isAndroid)) {
      FocusScope.of(context).unfocus();
    }
    chatViewIW?.showPopUp.value = false;
    ScaffoldMessenger.of(context).hideCurrentSnackBar();
  }

  @override
  void dispose() {
    _isNextPageLoading.dispose();
    super.dispose();
  }
}



===== FILE: vendor\chatview\src\widgets\chat_message_sending_to_sent_animation.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'dart:math';

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

class SendingMessageAnimatingWidget extends StatefulWidget {
  const SendingMessageAnimatingWidget(this.status, {Key? key})
      : super(key: key);

  final MessageStatus status;

  @override
  State<SendingMessageAnimatingWidget> createState() =>
      _SendingMessageAnimatingWidgetState();
}

class _SendingMessageAnimatingWidgetState
    extends State<SendingMessageAnimatingWidget> with TickerProviderStateMixin {
  bool get isSent => widget.status != MessageStatus.pending;

  bool isVisible = false;

  _attachOnStatusChangeListeners() {
    if (isSent) {
      Future.delayed(const Duration(milliseconds: 400), () {
        isVisible = true;
        if (mounted) {
          setState(() {});
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    _attachOnStatusChangeListeners();
    return AnimatedPadding(
      curve: Curves.easeInOutExpo,
      duration: const Duration(seconds: 1),
      padding: EdgeInsets.only(right: isSent ? 5 : 8.0, bottom: isSent ? 8 : 2),
      child: isVisible
          ? const SizedBox()
          : Transform.rotate(
              angle: !isSent ? pi / 10 : -pi / 12,
              child: const Padding(
                padding: EdgeInsets.only(
                  left: 2,
                  bottom: 5,
                ),
                child: Icon(
                  Icons.send,
                  color: Colors.grey,
                  size: 12,
                ),
              )),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\chat_textfield_view_builder.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../utils/constants/constants.dart';
import '../values/typedefs.dart';

/// A widget builder that contains the logic to calculate the height of the chat text field
/// When reply message view is shown update the height of the chat text field
/// When selected image view is shown update the height of the chat text field
class ChatTextFieldViewBuilder<T> extends StatelessWidget {
  /// A widget that rebuilds when the value of a [ValueNotifier] changes.
  const ChatTextFieldViewBuilder({
    super.key,
    required this.valueListenable,
    required this.builder,
  });

  /// The [ValueListenable] that provides the value to be listened to.
  final ValueListenable<T> valueListenable;

  /// The builder function that takes the current context, value, and an optional child widget.
  final ChatTextFieldViewBuilderCallback<T> builder;

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<T>(
      valueListenable: valueListenable,
      builder: (context, value, child) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (!context.mounted) return;
          final chatViewIW = context.chatViewIW;
          // Update the chat text field height based on the current context size.
          chatViewIW?.chatTextFieldHeight.value =
              chatViewIW.chatTextFieldViewKey.currentContext?.size?.height ??
                  defaultChatTextFieldHeight;
        });
        return builder.call(context, value, child);
      },
    );
  }
}



===== FILE: vendor\chatview\src\widgets\chat_view.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'dart:io';

import 'package:chatview/chatview.dart';
import 'package:chatview/src/widgets/chat_list_widget.dart';
import 'package:chatview/src/widgets/chatview_state_widget.dart';
import 'package:chatview/src/widgets/reaction_popup.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../inherited_widgets/configurations_inherited_widgets.dart';
import '../utils/timeago/timeago.dart';
import '../values/custom_time_messages.dart';
import 'chat_view_inherited_widget.dart';
import 'send_message_widget.dart';
import 'suggestions/suggestions_config_inherited_widget.dart';

class ChatView extends StatefulWidget {
  const ChatView({
    Key? key,
    required this.chatController,
    this.onSendTap,
    this.profileCircleConfig,
    this.chatBubbleConfig,
    this.repliedMessageConfig,
    this.swipeToReplyConfig,
    this.replyPopupConfig,
    this.reactionPopupConfig,
    this.loadMoreData,
    this.loadingWidget,
    this.messageConfig,
    this.isLastPage,
    this.appBar,
    ChatBackgroundConfiguration? chatBackgroundConfig,
    this.typeIndicatorConfig,
    this.sendMessageBuilder,
    this.sendMessageConfig,
    this.onChatListTap,
    required this.chatViewState,
    ChatViewStateConfiguration? chatViewStateConfig,
    this.featureActiveConfig = const FeatureActiveConfig(),
    this.emojiPickerSheetConfig,
    this.replyMessageBuilder,
    this.replySuggestionsConfig,
    this.scrollToBottomButtonConfig,
  })  : chatBackgroundConfig =
            chatBackgroundConfig ?? const ChatBackgroundConfiguration(),
        chatViewStateConfig =
            chatViewStateConfig ?? const ChatViewStateConfiguration(),
        super(key: key);

  /// Provides configuration related to user profile circle avatar.
  final ProfileCircleConfiguration? profileCircleConfig;

  /// Provides configurations related to chat bubble such as padding, margin, max
  /// width etc.
  final ChatBubbleConfiguration? chatBubbleConfig;

  /// Allow user to giving customisation different types
  /// messages.
  final MessageConfiguration? messageConfig;

  /// Provides configuration for replied message view which is located upon chat
  /// bubble.
  final RepliedMessageConfiguration? repliedMessageConfig;

  /// Provides configurations related to swipe chat bubble which triggers
  /// when user swipe chat bubble.
  final SwipeToReplyConfiguration? swipeToReplyConfig;

  /// Provides configuration for reply snack bar's appearance and options.
  final ReplyPopupConfiguration? replyPopupConfig;

  /// Provides configuration for reaction pop up appearance.
  final ReactionPopupConfiguration? reactionPopupConfig;

  /// Allow user to give customisation to background of chat
  final ChatBackgroundConfiguration chatBackgroundConfig;

  /// Provides callback when user actions reaches to top and needs to load more
  /// chat
  final AsyncCallback? loadMoreData;

  /// Provides widget for loading view while pagination is enabled.
  final Widget? loadingWidget;

  /// Provides flag if there is no more next data left in list.
  final bool? isLastPage;

  /// Provides call back when user tap on send button in text field. It returns
  /// message, reply message and message type.
  final StringMessageCallBack? onSendTap;

  /// Provides builder which helps you to make custom text field and functionality.
  final ReplyMessageWithReturnWidget? sendMessageBuilder;

  /// Allow user to giving customisation typing indicator.
  final TypeIndicatorConfiguration? typeIndicatorConfig;

  /// Provides controller for accessing few function for running chat.
  final ChatController chatController;

  /// Provides configuration of default text field in chat.
  final SendMessageConfiguration? sendMessageConfig;

  /// Provides current state of chat.
  final ChatViewState chatViewState;

  /// Provides configuration for chat view state appearance and functionality.
  final ChatViewStateConfiguration? chatViewStateConfig;

  /// Provides configuration for turn on/off specific features.
  final FeatureActiveConfig featureActiveConfig;

  /// Provides parameter so user can assign ChatViewAppbar.
  final Widget? appBar;

  /// Provides callback when user tap on chat list.
  final VoidCallback? onChatListTap;

  /// Configuration for emoji picker sheet
  final Config? emojiPickerSheetConfig;

  /// Suggestion Item Config
  final ReplySuggestionsConfig? replySuggestionsConfig;

  /// Provides a callback for the view when replying to message
  final CustomViewForReplyMessage? replyMessageBuilder;

  /// Provides a configuration for scroll to bottom button config
  final ScrollToBottomButtonConfig? scrollToBottomButtonConfig;

  static void closeReplyMessageView(BuildContext context) {
    final state = context.findAncestorStateOfType<_ChatViewState>();

    assert(
      state != null,
      'ChatViewState not found. Make sure to use correct context that contains the ChatViewState',
    );

    state?.replyMessageViewClose();
  }

  @override
  State<ChatView> createState() => _ChatViewState();
}

class _ChatViewState extends State<ChatView>
    with SingleTickerProviderStateMixin {
  final GlobalKey<SendMessageWidgetState> _sendMessageKey = GlobalKey();

  ChatController get chatController => widget.chatController;

  ChatBackgroundConfiguration get chatBackgroundConfig =>
      widget.chatBackgroundConfig;

  ChatViewState get chatViewState => widget.chatViewState;

  ChatViewStateConfiguration? get chatViewStateConfig =>
      widget.chatViewStateConfig;

  FeatureActiveConfig get featureActiveConfig => widget.featureActiveConfig;

  late GlobalKey chatTextFieldViewKey;

  @override
  void initState() {
    super.initState();
    setLocaleMessages('en', ReceiptsCustomMessages());
    chatTextFieldViewKey = GlobalKey();
  }

  @override
  Widget build(BuildContext context) {
    // Scroll to last message on in hasMessages state.
    if (widget.chatController.showTypingIndicator &&
        chatViewState.hasMessages) {
      chatController.scrollToLastMessage();
    }
    return ChatViewInheritedWidget(
      chatController: chatController,
      featureActiveConfig: featureActiveConfig,
      profileCircleConfiguration: widget.profileCircleConfig,
      chatTextFieldViewKey: chatTextFieldViewKey,
      child: SuggestionsConfigIW(
        suggestionsConfig: widget.replySuggestionsConfig,
        child: Builder(builder: (context) {
          return ConfigurationsInheritedWidget(
            chatBackgroundConfig: widget.chatBackgroundConfig,
            reactionPopupConfig: widget.reactionPopupConfig,
            typeIndicatorConfig: widget.typeIndicatorConfig,
            chatBubbleConfig: widget.chatBubbleConfig,
            replyPopupConfig: widget.replyPopupConfig,
            messageConfig: widget.messageConfig,
            profileCircleConfig: widget.profileCircleConfig,
            repliedMessageConfig: widget.repliedMessageConfig,
            swipeToReplyConfig: widget.swipeToReplyConfig,
            emojiPickerSheetConfig: widget.emojiPickerSheetConfig,
            scrollToBottomButtonConfig: widget.scrollToBottomButtonConfig,
            child: Stack(
              children: [
                Container(
                  height: chatBackgroundConfig.height ??
                      MediaQuery.of(context).size.height,
                  width: chatBackgroundConfig.width ??
                      MediaQuery.of(context).size.width,
                  decoration: BoxDecoration(
                    color: chatBackgroundConfig.backgroundColor ?? Colors.white,
                    image: chatBackgroundConfig.backgroundImage != null
                        ? DecorationImage(
                            fit: BoxFit.fill,
                            image: NetworkImage(
                                chatBackgroundConfig.backgroundImage!),
                          )
                        : null,
                  ),
                  padding: chatBackgroundConfig.padding,
                  margin: chatBackgroundConfig.margin,
                  child: Column(
                    children: [
                      if (widget.appBar != null) widget.appBar!,
                      Expanded(
                        child: Stack(
                          children: [
                            if (chatViewState.isLoading)
                              ChatViewStateWidget(
                                chatViewStateWidgetConfig:
                                    chatViewStateConfig?.loadingWidgetConfig,
                                chatViewState: chatViewState,
                              )
                            else if (chatViewState.noMessages)
                              ChatViewStateWidget(
                                chatViewStateWidgetConfig:
                                    chatViewStateConfig?.noMessageWidgetConfig,
                                chatViewState: chatViewState,
                                onReloadButtonTap:
                                    chatViewStateConfig?.onReloadButtonTap,
                              )
                            else if (chatViewState.isError)
                              ChatViewStateWidget(
                                chatViewStateWidgetConfig:
                                    chatViewStateConfig?.errorWidgetConfig,
                                chatViewState: chatViewState,
                                onReloadButtonTap:
                                    chatViewStateConfig?.onReloadButtonTap,
                              )
                            else if (chatViewState.hasMessages)
                              GestureDetector(
                                onTap: () => FocusManager.instance.primaryFocus
                                    ?.unfocus(),
                                behavior: HitTestBehavior.opaque,
                                child: ChatListWidget(
                                  chatController: widget.chatController,
                                  loadMoreData: widget.loadMoreData,
                                  isLastPage: widget.isLastPage,
                                  loadingWidget: widget.loadingWidget,
                                  onChatListTap: widget.onChatListTap,
                                  assignReplyMessage: (message) =>
                                      _sendMessageKey.currentState
                                          ?.assignReplyMessage(message),
                                  textFieldConfig:
                                      widget.sendMessageConfig?.textFieldConfig,
                                ),
                              ),
                            if (featureActiveConfig.enableTextField)
                              SendMessageWidget(
                                key: _sendMessageKey,
                                sendMessageBuilder: widget.sendMessageBuilder,
                                sendMessageConfig: widget.sendMessageConfig,
                                onSendTap:
                                    (message, replyMessage, messageType) {
                                  if (context.suggestionsConfig
                                          ?.autoDismissOnSelection ??
                                      true) {
                                    chatController.removeReplySuggestions();
                                  }
                                  _onSendTap(
                                      message, replyMessage, messageType);
                                },
                                messageConfig: widget.messageConfig,
                                replyMessageBuilder: widget.replyMessageBuilder,
                              ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
                if (featureActiveConfig.enableReactionPopup)
                  ValueListenableBuilder<bool>(
                    valueListenable: context.chatViewIW!.showPopUp,
                    builder: (_, showPopupValue, child) {
                      return ReactionPopup(
                        key: context.chatViewIW!.reactionPopupKey,
                        onTap: () => _onChatListTap(context),
                        showPopUp: showPopupValue,
                      );
                    },
                  ),
              ],
            ),
          );
        }),
      ),
    );
  }

  void _onChatListTap(BuildContext context) {
    widget.onChatListTap?.call();
    if (!kIsWeb && (Platform.isIOS || Platform.isAndroid)) {
      FocusScope.of(context).unfocus();
    }
    context.chatViewIW?.showPopUp.value = false;
    ScaffoldMessenger.of(context).hideCurrentSnackBar();
  }

  void _onSendTap(
    String message,
    ReplyMessage replyMessage,
    MessageType messageType,
  ) {
    if (widget.sendMessageBuilder == null) {
      if (widget.onSendTap != null) {
        widget.onSendTap!(message, replyMessage, messageType);
      }
    }
    chatController.scrollToLastMessage();
  }

  void replyMessageViewClose() => _sendMessageKey.currentState?.onCloseTap();

  @override
  void dispose() {
    chatViewIW?.showPopUp.dispose();
    super.dispose();
  }
}



===== FILE: vendor\chatview\src\widgets\chat_view_appbar.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'dart:io' if (kIsWeb) 'dart:html';

import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';

import '../../chatview.dart';
import 'profile_image_widget.dart';

class ChatViewAppBar extends StatelessWidget {
  const ChatViewAppBar({
    Key? key,
    required this.chatTitle,
    this.backGroundColor,
    this.userStatus,
    this.profilePicture,
    this.chatTitleTextStyle,
    this.userStatusTextStyle,
    this.backArrowColor,
    this.actions,
    this.elevation,
    this.onBackPress,
    this.padding,
    this.leading,
    this.showLeading = true,
    this.defaultAvatarImage = Constants.profileImage,
    this.assetImageErrorBuilder,
    this.networkImageErrorBuilder,
    this.imageType = ImageType.network,
    this.networkImageProgressIndicatorBuilder,
  }) : super(key: key);

  /// Allow user to change colour of appbar.
  final Color? backGroundColor;

  /// Allow user to change title of appbar.
  final String chatTitle;

  /// Allow user to change whether user is available or offline.
  final String? userStatus;

  /// Allow user to change profile picture in appbar.
  final String? profilePicture;

  /// Allow user to change text style of chat title.
  final TextStyle? chatTitleTextStyle;

  /// Allow user to change text style of user status.
  final TextStyle? userStatusTextStyle;

  /// Allow user to change back arrow colour.
  final Color? backArrowColor;

  /// Allow user to add actions widget in right side of appbar.
  final List<Widget>? actions;

  /// Allow user to change elevation of appbar.
  final double? elevation;

  /// Provides callback when user tap on back arrow.
  final VoidCallback? onBackPress;

  /// Allow user to change padding in appbar.
  final EdgeInsets? padding;

  /// Allow user to change leading icon of appbar.
  final Widget? leading;

  /// Allow user to turn on/off leading icon.
  final bool showLeading;

  /// Field to set default image if network url for profile image not provided
  final String defaultAvatarImage;

  /// Error builder to build error widget for asset image
  final AssetImageErrorBuilder? assetImageErrorBuilder;

  /// Error builder to build error widget for network image
  final NetworkImageErrorBuilder? networkImageErrorBuilder;

  /// Field to define image type [network, asset or base64]
  final ImageType imageType;

  /// Progress indicator builder for network image
  final NetworkImageProgressIndicatorBuilder?
      networkImageProgressIndicatorBuilder;

  @override
  Widget build(BuildContext context) {
    return Material(
      elevation: elevation ?? 1,
      child: Container(
        padding: padding ??
            EdgeInsets.only(
              top: MediaQuery.of(context).padding.top,
              bottom: 4,
            ),
        color: backGroundColor ?? Colors.white,
        child: Row(
          children: [
            if (showLeading)
              leading ??
                  IconButton(
                    onPressed: onBackPress ?? () => Navigator.pop(context),
                    icon: Icon(
                      (!kIsWeb && Platform.isIOS)
                          ? Icons.arrow_back_ios
                          : Icons.arrow_back,
                      color: backArrowColor,
                    ),
                  ),
            Expanded(
              child: Row(
                children: [
                  if (profilePicture != null)
                    Padding(
                      padding: const EdgeInsets.only(right: 8.0),
                      child: ProfileImageWidget(
                        imageUrl: profilePicture,
                        defaultAvatarImage: defaultAvatarImage,
                        assetImageErrorBuilder: assetImageErrorBuilder,
                        networkImageErrorBuilder: networkImageErrorBuilder,
                        imageType: imageType,
                        networkImageProgressIndicatorBuilder:
                            networkImageProgressIndicatorBuilder,
                      ),
                    ),
                  Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        chatTitle,
                        style: chatTitleTextStyle ??
                            const TextStyle(
                              fontSize: 18,
                              fontWeight: FontWeight.bold,
                              letterSpacing: 0.25,
                            ),
                      ),
                      if (userStatus != null)
                        Text(
                          userStatus!,
                          style: userStatusTextStyle,
                        ),
                    ],
                  ),
                ],
              ),
            ),
            if (actions != null) ...actions!,
          ],
        ),
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\chat_view_inherited_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../models/config_models/feature_active_config.dart';
import '../models/config_models/profile_circle_configuration.dart';
import 'reaction_popup.dart';

/// This widget for alternative of excessive amount of passing arguments
/// over widgets.
class ChatViewInheritedWidget extends InheritedWidget {
  ChatViewInheritedWidget({
    Key? key,
    required Widget child,
    required this.featureActiveConfig,
    required this.chatController,
    required this.chatTextFieldViewKey,
    this.profileCircleConfiguration,
  }) : super(key: key, child: child);
  final FeatureActiveConfig featureActiveConfig;
  final ProfileCircleConfiguration? profileCircleConfiguration;
  final ChatController chatController;
  final GlobalKey chatTextFieldViewKey;
  final ValueNotifier<bool> showPopUp = ValueNotifier(false);
  final ValueNotifier<double> chatTextFieldHeight = ValueNotifier(0.0);
  final GlobalKey<ReactionPopupState> reactionPopupKey = GlobalKey();

  static ChatViewInheritedWidget? of(BuildContext context) =>
      context.dependOnInheritedWidgetOfExactType<ChatViewInheritedWidget>();

  @override
  bool updateShouldNotify(covariant ChatViewInheritedWidget oldWidget) =>
      oldWidget.featureActiveConfig != featureActiveConfig;
}



===== FILE: vendor\chatview\src\widgets\chatui_textfield.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'dart:async';
import 'dart:io' show File, Platform;

import 'package:audio_waveforms/audio_waveforms.dart';
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:image_picker/image_picker.dart';

import '../models/config_models/send_message_configuration.dart';
import '../utils/constants/constants.dart';
import '../utils/debounce.dart';
import '../utils/package_strings.dart';
import '../values/typedefs.dart';

class ChatUITextField extends StatefulWidget {
  const ChatUITextField({
    Key? key,
    this.sendMessageConfig,
    required this.focusNode,
    required this.textEditingController,
    required this.onPressed,
    required this.onRecordingComplete,
    required this.onImageSelected,
  }) : super(key: key);

  /// Provides configuration of default text field in chat.
  final SendMessageConfiguration? sendMessageConfig;

  /// Provides focusNode for focusing text field.
  final FocusNode focusNode;

  /// Provides functions which handles text field.
  final TextEditingController textEditingController;

  /// Provides callback when user tap on text field.
  final VoidCallback onPressed;

  /// Provides callback once voice is recorded.
  final ValueSetter<String?> onRecordingComplete;

  /// Provides callback when user select images from camera/gallery.
  final StringsCallBack onImageSelected;

  @override
  State<ChatUITextField> createState() => _ChatUITextFieldState();
}

class _ChatUITextFieldState extends State<ChatUITextField> {
  final ValueNotifier<String> _inputText = ValueNotifier('');

  final ImagePicker _imagePicker = ImagePicker();

  RecorderController? controller;

  ValueNotifier<bool> isRecording = ValueNotifier(false);

  bool Function(KeyEvent)? _keyboardHandler;

  SendMessageConfiguration? get sendMessageConfig => widget.sendMessageConfig;

  VoiceRecordingConfiguration? get voiceRecordingConfig =>
      widget.sendMessageConfig?.voiceRecordingConfiguration;

  ImagePickerIconsConfiguration? get imagePickerIconsConfig =>
      sendMessageConfig?.imagePickerIconsConfig;

  TextFieldConfiguration? get textFieldConfig =>
      sendMessageConfig?.textFieldConfig;

  CancelRecordConfiguration? get cancelRecordConfiguration =>
      sendMessageConfig?.cancelRecordConfiguration;

  OutlineInputBorder get _outLineBorder => OutlineInputBorder(
        borderSide: const BorderSide(color: Colors.transparent),
        borderRadius: widget.sendMessageConfig?.textFieldConfig?.borderRadius ??
            BorderRadius.circular(textFieldBorderRadius),
      );

  ValueNotifier<TypeWriterStatus> composingStatus =
      ValueNotifier(TypeWriterStatus.typed);

  late Debouncer debouncer;

  @override
  void initState() {
    attachListeners();
    debouncer = Debouncer(
        sendMessageConfig?.textFieldConfig?.compositionThresholdTime ??
            const Duration(seconds: 1));
    super.initState();

    if (!kIsWeb && (Platform.isIOS || Platform.isAndroid)) {
      controller = RecorderController();
    }
    if (kIsWeb) {
      if (_attachHardwareKeyboardHandler() case final handler) {
        _keyboardHandler = handler;
        HardwareKeyboard.instance.addHandler(handler);
      }
    }
  }

  @override
  void dispose() {
    debouncer.dispose();
    composingStatus.dispose();
    isRecording.dispose();
    _inputText.dispose();
    if (_keyboardHandler case final handler?) {
      HardwareKeyboard.instance.removeHandler(handler);
    }
    super.dispose();
  }

  void attachListeners() {
    composingStatus.addListener(() {
      widget.sendMessageConfig?.textFieldConfig?.onMessageTyping
          ?.call(composingStatus.value);
    });
  }

  // Attaches a hardware keyboard handler to handle Enter key events.
  // This is only applicable for web platforms.
  // It checks if the Enter key is pressed then sends the message
  // or inserts a new line based on whether Enter + Shift is pressed.
  bool Function(KeyEvent) _attachHardwareKeyboardHandler() {
    return (KeyEvent event) {
      if (event is! KeyDownEvent ||
          event.logicalKey != LogicalKeyboardKey.enter) {
        return false;
      }

      final pressedKeys = HardwareKeyboard.instance.logicalKeysPressed;
      final isShiftPressed = pressedKeys.any((key) =>
          key == LogicalKeyboardKey.shiftLeft ||
          key == LogicalKeyboardKey.shiftRight);
      if (!isShiftPressed) {
        // Send message on Enter
        if (_inputText.value.trim().isNotEmpty) {
          widget.onPressed();
          _inputText.value = '';
        }
      } else {
        // Shift+Enter: insert new line
        final text = widget.textEditingController.text;
        final selection = widget.textEditingController.selection;

        // Insert a newline ('\n') at the current cursor position or
        // replace selected text with it.
        final newText = text.replaceRange(
          selection.start,
          selection.end,
          '\n',
        );
        widget.textEditingController
          ..text = newText
          ..selection = TextSelection.collapsed(offset: selection.start + 1);
      }
      return true;
    };
  }

  @override
  Widget build(BuildContext context) {
    final outlineBorder = _outLineBorder;
    return Container(
      padding:
          textFieldConfig?.padding ?? const EdgeInsets.symmetric(horizontal: 6),
      margin: textFieldConfig?.margin,
      decoration: BoxDecoration(
        borderRadius: textFieldConfig?.borderRadius ??
            BorderRadius.circular(textFieldBorderRadius),
        color: sendMessageConfig?.textFieldBackgroundColor ?? Colors.white,
      ),
      child: ValueListenableBuilder<bool>(
        valueListenable: isRecording,
        builder: (_, isRecordingValue, child) {
          return Row(
            children: [
              if (isRecordingValue && controller != null && !kIsWeb)
                Expanded(
                  child: AudioWaveforms(
                    size: const Size(double.maxFinite, 50),
                    recorderController: controller!,
                    margin: voiceRecordingConfig?.margin,
                    padding: voiceRecordingConfig?.padding ??
                        EdgeInsets.symmetric(
                          horizontal: cancelRecordConfiguration == null ? 8 : 5,
                        ),
                    decoration: voiceRecordingConfig?.decoration ??
                        BoxDecoration(
                          color: voiceRecordingConfig?.backgroundColor,
                          borderRadius: BorderRadius.circular(12.0),
                        ),
                    waveStyle: voiceRecordingConfig?.waveStyle ??
                        WaveStyle(
                          extendWaveform: true,
                          showMiddleLine: false,
                          waveColor:
                              voiceRecordingConfig?.waveStyle?.waveColor ??
                                  Colors.black,
                        ),
                  ),
                )
              else
                Expanded(
                  child: TextField(
                    focusNode: widget.focusNode,
                    controller: widget.textEditingController,
                    style: textFieldConfig?.textStyle ??
                        const TextStyle(color: Colors.white),
                    maxLines: textFieldConfig?.maxLines ?? 5,
                    minLines: textFieldConfig?.minLines ?? 1,
                    keyboardType: textFieldConfig?.textInputType,
                    inputFormatters: textFieldConfig?.inputFormatters,
                    onChanged: _onChanged,
                    enabled: textFieldConfig?.enabled,
                    textCapitalization: textFieldConfig?.textCapitalization ??
                        TextCapitalization.sentences,
                    decoration: InputDecoration(
                      hintText: textFieldConfig?.hintText ??
                          PackageStrings.currentLocale.message,
                      fillColor: sendMessageConfig?.textFieldBackgroundColor ??
                          Colors.white,
                      filled: true,
                      hintStyle: textFieldConfig?.hintStyle ??
                          TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w400,
                            color: Colors.grey.shade600,
                            letterSpacing: 0.25,
                          ),
                      contentPadding: textFieldConfig?.contentPadding ??
                          const EdgeInsets.symmetric(horizontal: 6),
                      border: outlineBorder,
                      focusedBorder: outlineBorder,
                      enabledBorder: outlineBorder,
                      disabledBorder: outlineBorder,
                    ),
                  ),
                ),
              ValueListenableBuilder<String>(
                valueListenable: _inputText,
                builder: (_, inputTextValue, child) {
                  if (inputTextValue.isNotEmpty) {
                    return IconButton(
                      color: sendMessageConfig?.defaultSendButtonColor ??
                          Colors.green,
                      onPressed: (textFieldConfig?.enabled ?? true)
                          ? () {
                              widget.onPressed();
                              _inputText.value = '';
                            }
                          : null,
                      icon: sendMessageConfig?.sendButtonIcon ??
                          const Icon(Icons.send),
                    );
                  } else {
                    return Row(
                      children: [
                        if (!isRecordingValue) ...[
                          if (sendMessageConfig?.enableCameraImagePicker ??
                              true)
                            IconButton(
                              constraints: const BoxConstraints(),
                              onPressed: (textFieldConfig?.enabled ?? true)
                                  ? () => _onIconPressed(
                                        ImageSource.camera,
                                        config: sendMessageConfig
                                            ?.imagePickerConfiguration,
                                      )
                                  : null,
                              icon: imagePickerIconsConfig
                                      ?.cameraImagePickerIcon ??
                                  Icon(
                                    Icons.camera_alt_outlined,
                                    color:
                                        imagePickerIconsConfig?.cameraIconColor,
                                  ),
                            ),
                          if (sendMessageConfig?.enableGalleryImagePicker ??
                              true)
                            IconButton(
                              constraints: const BoxConstraints(),
                              onPressed: (textFieldConfig?.enabled ?? true)
                                  ? () => _onIconPressed(
                                        ImageSource.gallery,
                                        config: sendMessageConfig
                                            ?.imagePickerConfiguration,
                                      )
                                  : null,
                              icon: imagePickerIconsConfig
                                      ?.galleryImagePickerIcon ??
                                  Icon(
                                    Icons.image,
                                    color: imagePickerIconsConfig
                                        ?.galleryIconColor,
                                  ),
                            ),
                        ],
                        if ((sendMessageConfig?.allowRecordingVoice ?? false) &&
                            !kIsWeb &&
                            (Platform.isIOS || Platform.isAndroid))
                          IconButton(
                            onPressed: (textFieldConfig?.enabled ?? true)
                                ? _recordOrStop
                                : null,
                            icon: (isRecordingValue
                                    ? voiceRecordingConfig?.stopIcon
                                    : voiceRecordingConfig?.micIcon) ??
                                Icon(
                                  isRecordingValue ? Icons.stop : Icons.mic,
                                  color:
                                      voiceRecordingConfig?.recorderIconColor,
                                ),
                          ),
                        if (isRecordingValue &&
                            cancelRecordConfiguration != null)
                          IconButton(
                            onPressed: () {
                              cancelRecordConfiguration?.onCancel?.call();
                              _cancelRecording();
                            },
                            icon: cancelRecordConfiguration?.icon ??
                                const Icon(Icons.cancel_outlined),
                            color: cancelRecordConfiguration?.iconColor ??
                                voiceRecordingConfig?.recorderIconColor,
                          ),
                      ],
                    );
                  }
                },
              ),
            ],
          );
        },
      ),
    );
  }

  FutureOr<void> _cancelRecording() async {
    assert(
      defaultTargetPlatform == TargetPlatform.iOS ||
          defaultTargetPlatform == TargetPlatform.android,
      "Voice messages are only supported with android and ios platform",
    );
    if (!isRecording.value) return;
    final path = await controller?.stop();
    if (path == null) {
      isRecording.value = false;
      return;
    }
    final file = File(path);

    if (await file.exists()) {
      await file.delete();
    }

    isRecording.value = false;
  }

  Future<void> _recordOrStop() async {
    assert(
      defaultTargetPlatform == TargetPlatform.iOS ||
          defaultTargetPlatform == TargetPlatform.android,
      "Voice messages are only supported with android and ios platform",
    );
    if (!isRecording.value) {
      await controller?.record(
        sampleRate: voiceRecordingConfig?.sampleRate,
        bitRate: voiceRecordingConfig?.bitRate,
        androidEncoder: voiceRecordingConfig?.androidEncoder,
        iosEncoder: voiceRecordingConfig?.iosEncoder,
        androidOutputFormat: voiceRecordingConfig?.androidOutputFormat,
      );
      isRecording.value = true;
    } else {
      final path = await controller?.stop();
      isRecording.value = false;
      widget.onRecordingComplete(path);
    }
  }

  void _onIconPressed(
    ImageSource imageSource, {
    ImagePickerConfiguration? config,
  }) async {
    final hasFocus = widget.focusNode.hasFocus;
    try {
      widget.focusNode.unfocus();
      final XFile? image = await _imagePicker.pickImage(
        source: imageSource,
        maxHeight: config?.maxHeight,
        maxWidth: config?.maxWidth,
        imageQuality: config?.imageQuality,
        preferredCameraDevice:
            config?.preferredCameraDevice ?? CameraDevice.rear,
      );
      String? imagePath = image?.path;
      if (config?.onImagePicked != null) {
        String? updatedImagePath = await config?.onImagePicked!(imagePath);
        if (updatedImagePath != null) imagePath = updatedImagePath;
      }

      widget.onImageSelected(imagePath ?? '', '');
    } catch (e) {
      widget.onImageSelected('', e.toString());
    } finally {
      // To maintain the iOS native behavior of text field,
      // When the user taps on the gallery icon, and the text field has focus,
      // the keyboard should close.
      // We need to request focus again to open the keyboard.
      // This is not required for Android.
      // This is a workaround for the issue where the keyboard remain open and overlaps the text field.

      // https://github.com/SimformSolutionsPvtLtd/chatview/issues/266
      if (imageSource == ImageSource.gallery && Platform.isIOS && hasFocus) {
        widget.focusNode.requestFocus();
      }
    }
  }

  void _onChanged(String inputText) {
    debouncer.run(() {
      composingStatus.value = TypeWriterStatus.typed;
    }, () {
      composingStatus.value = TypeWriterStatus.typing;
    });
    _inputText.value = inputText;
  }
}



===== FILE: vendor\chatview\src\widgets\chatview_state_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/config_models/chat_view_states_configuration.dart';
import '../utils/package_strings.dart';
import '../values/enumeration.dart';

class ChatViewStateWidget extends StatelessWidget {
  const ChatViewStateWidget({
    Key? key,
    this.chatViewStateWidgetConfig,
    required this.chatViewState,
    this.onReloadButtonTap,
  }) : super(key: key);

  /// Provides configuration of chat view's different states such as text styles,
  /// widgets and etc.
  final ChatViewStateWidgetConfiguration? chatViewStateWidgetConfig;

  /// Provides current state of chat view.
  final ChatViewState chatViewState;

  /// Provides callback when user taps on reload button in error and no messages
  /// state.
  final VoidCallback? onReloadButtonTap;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: chatViewStateWidgetConfig?.widget ??
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Text(
                (chatViewStateWidgetConfig?.title
                    .getChatViewStateTitle(chatViewState))!,
                style: chatViewStateWidgetConfig?.titleTextStyle ??
                    const TextStyle(
                      fontSize: 22,
                    ),
              ),
              if (chatViewStateWidgetConfig?.subTitle != null)
                Text(
                  (chatViewStateWidgetConfig?.subTitle)!,
                  style: chatViewStateWidgetConfig?.subTitleTextStyle,
                ),
              if (chatViewState.isLoading)
                CircularProgressIndicator(
                  color: chatViewStateWidgetConfig?.loadingIndicatorColor,
                ),
              if (chatViewStateWidgetConfig?.imageWidget != null)
                (chatViewStateWidgetConfig?.imageWidget)!,
              if (chatViewStateWidgetConfig?.reloadButton != null)
                (chatViewStateWidgetConfig?.reloadButton)!,
              if (chatViewStateWidgetConfig != null &&
                  (chatViewStateWidgetConfig?.showDefaultReloadButton)! &&
                  chatViewStateWidgetConfig?.reloadButton == null &&
                  (chatViewState.isError || chatViewState.noMessages)) ...[
                const SizedBox(height: 8),
                ElevatedButton(
                  onPressed: onReloadButtonTap,
                  style: ElevatedButton.styleFrom(
                    backgroundColor:
                        chatViewStateWidgetConfig?.reloadButtonColor ??
                            const Color(0xffEE5366),
                  ),
                  child: Text(PackageStrings.currentLocale.reload),
                )
              ]
            ],
          ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\emoji_picker_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'dart:io';

import 'package:emoji_picker_flutter/emoji_picker_flutter.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';

class EmojiPickerWidget extends StatelessWidget {
  const EmojiPickerWidget({
    Key? key,
    required this.onSelected,
    this.emojiPickerSheetConfig,
  }) : super(key: key);

  /// Provides callback when user selects emoji.
  final ValueSetter<String> onSelected;

  /// Configuration for emoji picker sheet
  final Config? emojiPickerSheetConfig;

  @override
  Widget build(BuildContext context) {
    final size = MediaQuery.sizeOf(context);
    return Container(
      padding: const EdgeInsets.only(top: 10, left: 15, right: 15),
      decoration: BoxDecoration(
        color: emojiPickerSheetConfig?.emojiViewConfig.backgroundColor ??
            Colors.white,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
      ),
      height: size.height * 0.6,
      width: size.width,
      child: Column(
        children: [
          Container(
            margin: const EdgeInsets.only(bottom: 15),
            width: 35,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey,
              borderRadius: BorderRadius.circular(30),
            ),
          ),
          Expanded(
            child: EmojiPicker(
              onEmojiSelected: (Category? category, Emoji emoji) =>
                  onSelected(emoji.emoji),
              config: emojiPickerSheetConfig ??
                  Config(
                    emojiViewConfig: EmojiViewConfig(
                      columns: 7,
                      emojiSizeMax:
                          32 * ((!kIsWeb && Platform.isIOS) ? 1.30 : 1.0),
                      recentsLimit: 28,
                      backgroundColor: Colors.white,
                    ),
                    searchViewConfig: const SearchViewConfig(
                      buttonIconColor: Colors.black,
                    ),
                    categoryViewConfig: const CategoryViewConfig(
                      initCategory: Category.RECENT,
                      recentTabBehavior: RecentTabBehavior.NONE,
                    ),
                    bottomActionBarConfig: const BottomActionBarConfig(
                      backgroundColor: Colors.white,
                      buttonIconColor: Colors.black,
                      buttonColor: Colors.white,
                    ),
                  ),
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\emoji_row.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../utils/constants/constants.dart';
import 'emoji_picker_widget.dart';

class EmojiRow extends StatelessWidget {
  EmojiRow({
    Key? key,
    required this.onEmojiTap,
  }) : super(key: key);

  /// Provides callback when user taps on emoji in reaction pop-up.
  final ValueSetter<String> onEmojiTap;

  /// These are default emojis.
  final List<String> _emojiUnicodes = [
    heart,
    faceWithTears,
    astonishedFace,
    disappointedFace,
    angryFace,
    thumbsUp,
  ];

  @override
  Widget build(BuildContext context) {
    final emojiConfig = context.chatListConfig.reactionPopupConfig?.emojiConfig;
    final emojiList = emojiConfig?.emojiList ?? _emojiUnicodes;
    final size = emojiConfig?.size;
    return Row(
      children: [
        Expanded(
          child: Row(
            mainAxisSize: MainAxisSize.min,
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: List.generate(
              emojiList.length,
              (index) => GestureDetector(
                onTap: () => onEmojiTap(emojiList[index]),
                child: Text(
                  emojiList[index],
                  style: TextStyle(fontSize: size ?? 28),
                ),
              ),
            ),
          ),
        ),
        IconButton(
          constraints: const BoxConstraints(),
          icon: Icon(
            Icons.add,
            color: Colors.grey.shade600,
            size: size ?? 28,
          ),
          onPressed: () => _showBottomSheet(context),
        ),
      ],
    );
  }

  void _showBottomSheet(BuildContext context) => showModalBottomSheet<void>(
        context: context,
        builder: (newContext) => EmojiPickerWidget(
          emojiPickerSheetConfig: context.chatListConfig.emojiPickerSheetConfig,
          onSelected: (emoji) {
            Navigator.pop(newContext);
            onEmojiTap(emoji);
          },
        ),
      );
}



===== FILE: vendor\chatview\src\widgets\glassmorphism_reaction_popup.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'dart:ui';

import 'package:flutter/material.dart';

import '../models/models.dart';
import '../utils/constants/constants.dart';

class GlassMorphismReactionPopup extends StatelessWidget {
  const GlassMorphismReactionPopup({
    Key? key,
    required this.child,
    this.reactionPopupConfig,
  }) : super(key: key);

  /// Allow user to assign custom widget which is appeared in glassmorphism
  /// effect.
  final Widget child;

  /// Provides configuration for reaction pop-up appearance.
  final ReactionPopupConfiguration? reactionPopupConfig;

  Color get backgroundColor =>
      reactionPopupConfig?.glassMorphismConfig?.backgroundColor ?? Colors.white;

  double get strokeWidth =>
      reactionPopupConfig?.glassMorphismConfig?.strokeWidth ?? 2;

  Color get borderColor =>
      reactionPopupConfig?.glassMorphismConfig?.borderColor ??
      Colors.grey.shade400;

  double get borderRadius =>
      reactionPopupConfig?.glassMorphismConfig?.borderRadius ?? 30;

  @override
  Widget build(BuildContext context) {
    return Stack(
      alignment: Alignment.center,
      children: [
        Container(
          constraints:
              BoxConstraints(maxWidth: reactionPopupConfig?.maxWidth ?? 350),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: <Color>[
                backgroundColor.withAlpha(opacity),
                backgroundColor.withAlpha(opacity),
              ],
              stops: const <double>[
                0.3,
                0,
              ],
            ),
            borderRadius: BorderRadius.circular(borderRadius),
          ),
          child: ClipRRect(
            clipBehavior: Clip.hardEdge,
            borderRadius: BorderRadius.circular(borderRadius),
            child: BackdropFilter(
              filter: ImageFilter.blur(
                sigmaX: 8,
                sigmaY: 16,
              ),
              child: Padding(
                padding: reactionPopupConfig?.padding ??
                    const EdgeInsets.symmetric(vertical: 6, horizontal: 14),
                child: child,
              ),
            ),
          ),
        ),
        IgnorePointer(
          ignoring: true,
          child: Padding(
            padding: reactionPopupConfig?.margin ??
                const EdgeInsets.symmetric(horizontal: 25),
            child: CustomPaint(
              painter: _GradientPainter(
                strokeWidth: strokeWidth,
                radius: borderRadius,
                borderColor: borderColor,
              ),
              child: Container(
                constraints: BoxConstraints(
                    maxWidth: reactionPopupConfig?.maxWidth ?? maxWidth),
                padding: EdgeInsets.symmetric(
                  vertical: reactionPopupConfig?.emojiConfig?.size ?? 28,
                ),
                decoration: BoxDecoration(
                  color: Colors.transparent,
                  borderRadius: BorderRadius.all(
                    Radius.circular(borderRadius),
                  ),
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }
}

class _GradientPainter extends CustomPainter {
  _GradientPainter({
    required this.strokeWidth,
    required this.radius,
    required this.borderColor,
  });

  final double radius;
  final double strokeWidth;

  final Color borderColor;
  final Paint _paintObject = Paint();

  LinearGradient get _gradient => LinearGradient(
        begin: Alignment.bottomRight,
        end: Alignment.topLeft,
        colors: <Color>[
          borderColor.withAlpha(50),
          borderColor.withAlpha(55),
          borderColor.withAlpha(50),
        ],
        stops: const <double>[0.06, 0.95, 1],
      );

  @override
  void paint(Canvas canvas, Size size) {
    final RRect innerRect2 = RRect.fromRectAndRadius(
      Rect.fromLTRB(strokeWidth, strokeWidth, size.width - strokeWidth,
          size.height - strokeWidth),
      Radius.circular(radius - strokeWidth),
    );

    final RRect outerRect = RRect.fromRectAndRadius(
      Rect.fromLTRB(0, 0, size.width, size.height),
      Radius.circular(radius),
    );
    _paintObject.shader = _gradient.createShader(Offset.zero & size);

    final Path outerRectPath = Path()..addRRect(outerRect);
    final Path innerRectPath2 = Path()..addRRect(innerRect2);
    canvas.drawPath(
      Path.combine(
        PathOperation.difference,
        outerRectPath,
        Path.combine(
          PathOperation.intersect,
          outerRectPath,
          innerRectPath2,
        ),
      ),
      _paintObject,
    );
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => true;
}



===== FILE: vendor\chatview\src\widgets\image_message_view.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'dart:convert';
import 'dart:io';

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/config_models/image_message_configuration.dart';
import '../models/config_models/message_reaction_configuration.dart';
import 'reaction_widget.dart';
import 'share_icon.dart';

class ImageMessageView extends StatelessWidget {
  const ImageMessageView({
    Key? key,
    required this.message,
    required this.isMessageBySender,
    this.imageMessageConfig,
    this.messageReactionConfig,
    this.highlightImage = false,
    this.highlightScale = 1.2,
  }) : super(key: key);

  /// Provides message instance of chat.
  final Message message;

  /// Represents current message is sent by current user.
  final bool isMessageBySender;

  /// Provides configuration for image message appearance.
  final ImageMessageConfiguration? imageMessageConfig;

  /// Provides configuration of reaction appearance in chat bubble.
  final MessageReactionConfiguration? messageReactionConfig;

  /// Represents flag of highlighting image when user taps on replied image.
  final bool highlightImage;

  /// Provides scale of highlighted image when user taps on replied image.
  final double highlightScale;

  String get imageUrl => message.message;

  Widget get iconButton => ShareIcon(
        shareIconConfig: imageMessageConfig?.shareIconConfig,
        imageUrl: imageUrl,
      );

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      mainAxisAlignment:
          isMessageBySender ? MainAxisAlignment.end : MainAxisAlignment.start,
      children: [
        if (isMessageBySender && !(imageMessageConfig?.hideShareIcon ?? false))
          iconButton,
        Stack(
          children: [
            GestureDetector(
              onTap: () => imageMessageConfig?.onTap != null
                  ? imageMessageConfig?.onTap!(message)
                  : null,
              child: Transform.scale(
                scale: highlightImage ? highlightScale : 1.0,
                alignment: isMessageBySender
                    ? Alignment.centerRight
                    : Alignment.centerLeft,
                child: Container(
                  padding: imageMessageConfig?.padding ?? EdgeInsets.zero,
                  margin: imageMessageConfig?.margin ??
                      EdgeInsets.only(
                        top: 6,
                        right: isMessageBySender ? 6 : 0,
                        left: isMessageBySender ? 0 : 6,
                        bottom: message.reaction.reactions.isNotEmpty ? 15 : 0,
                      ),
                  height: imageMessageConfig?.height ?? 200,
                  width: imageMessageConfig?.width ?? 150,
                  child: ClipRRect(
                    borderRadius: imageMessageConfig?.borderRadius ??
                        BorderRadius.circular(14),
                    child: (() {
                      if (imageUrl.isUrl) {
                        return Image.network(
                          imageUrl,
                          fit: BoxFit.fitHeight,
                          loadingBuilder: (context, child, loadingProgress) {
                            if (loadingProgress == null) return child;
                            return Center(
                              child: CircularProgressIndicator(
                                value: loadingProgress.expectedTotalBytes !=
                                        null
                                    ? loadingProgress.cumulativeBytesLoaded /
                                        loadingProgress.expectedTotalBytes!
                                    : null,
                              ),
                            );
                          },
                        );
                      } else if (imageUrl.fromMemory) {
                        return Image.memory(
                          base64Decode(imageUrl
                              .substring(imageUrl.indexOf('base64') + 7)),
                          fit: BoxFit.fill,
                        );
                      } else {
                        return Image.file(
                          File(imageUrl),
                          fit: BoxFit.fill,
                        );
                      }
                    }()),
                  ),
                ),
              ),
            ),
            if (message.reaction.reactions.isNotEmpty)
              ReactionWidget(
                isMessageBySender: isMessageBySender,
                reaction: message.reaction,
                messageReactionConfig: messageReactionConfig,
              ),
          ],
        ),
        if (!isMessageBySender && !(imageMessageConfig?.hideShareIcon ?? false))
          iconButton,
      ],
    );
  }
}



===== FILE: vendor\chatview\src\widgets\link_preview.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:any_link_preview/any_link_preview.dart';
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';

import '../extensions/extensions.dart';
import '../models/config_models/link_preview_configuration.dart';
import '../utils/constants/constants.dart';

class LinkPreview extends StatelessWidget {
  const LinkPreview({
    Key? key,
    required this.url,
    this.linkPreviewConfig,
  }) : super(key: key);

  /// Provides url which is passed in message.
  final String url;

  /// Provides configuration of chat bubble appearance when link/URL is passed
  /// in message.
  final LinkPreviewConfiguration? linkPreviewConfig;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: linkPreviewConfig?.padding ??
          const EdgeInsets.symmetric(horizontal: 6, vertical: verticalPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (!url.isImageUrl &&
              !(context.chatBubbleConfig?.disableLinkPreview ?? false)) ...{
            Padding(
              padding: const EdgeInsets.symmetric(vertical: verticalPadding),
              child: AnyLinkPreview(
                link: url,
                removeElevation: true,
                errorBody: linkPreviewConfig?.errorBody,
                proxyUrl: linkPreviewConfig?.proxyUrl,
                onTap: _onLinkTap,
                placeholderWidget: SizedBox(
                  height: MediaQuery.of(context).size.height * 0.25,
                  width: double.infinity,
                  child: Center(
                    child: CircularProgressIndicator(
                      strokeWidth: 1,
                      color: linkPreviewConfig?.loadingColor,
                    ),
                  ),
                ),
                backgroundColor:
                    linkPreviewConfig?.backgroundColor ?? Colors.grey.shade200,
                borderRadius: linkPreviewConfig?.borderRadius,
                bodyStyle: linkPreviewConfig?.bodyStyle ??
                    const TextStyle(color: Colors.black),
                titleStyle: linkPreviewConfig?.titleStyle,
              ),
            ),
          } else if (url.isImageUrl) ...{
            Padding(
              padding: const EdgeInsets.symmetric(vertical: verticalPadding),
              child: InkWell(
                onTap: _onLinkTap,
                child: Image.network(
                  url,
                  height: 120,
                  width: double.infinity,
                  fit: BoxFit.fitWidth,
                ),
              ),
            ),
          },
          const SizedBox(height: verticalPadding),
          InkWell(
            onTap: _onLinkTap,
            child: Text(
              url,
              style: linkPreviewConfig?.linkStyle ??
                  const TextStyle(
                    color: Colors.white,
                    decoration: TextDecoration.underline,
                  ),
            ),
          ),
        ],
      ),
    );
  }

  void _onLinkTap() {
    if (linkPreviewConfig?.onUrlDetect != null) {
      linkPreviewConfig?.onUrlDetect!(url);
    } else {
      _launchURL();
    }
  }

  void _launchURL() async {
    final parsedUrl = Uri.parse(url);
    await canLaunchUrl(parsedUrl)
        ? await launchUrl(parsedUrl)
        : throw couldNotLaunch;
  }
}



===== FILE: vendor\chatview\src\widgets\message_time_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';

class MessageTimeWidget extends StatelessWidget {
  const MessageTimeWidget({
    Key? key,
    required this.messageTime,
    required this.isCurrentUser,
  }) : super(key: key);

  /// Provides message crated date time.
  final DateTime messageTime;

  /// Represents message is sending by current user.
  final bool isCurrentUser;

  @override
  Widget build(BuildContext context) {
    final chatBackgroundConfig = context.chatListConfig.chatBackgroundConfig;
    final messageTimeIconColor =
        chatBackgroundConfig.messageTimeIconColor ?? Colors.black;
    return Align(
      alignment: Alignment.centerRight,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 15, vertical: 10),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(2),
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(
                  color: messageTimeIconColor,
                ),
              ),
              child: Icon(
                isCurrentUser ? Icons.arrow_forward : Icons.arrow_back,
                size: 10,
                color: messageTimeIconColor,
              ),
            ),
            const SizedBox(width: 4),
            Text(
              messageTime.getTimeFromDateTime,
              style: chatBackgroundConfig.messageTimeTextStyle ??
                  const TextStyle(fontSize: 12),
            ),
          ],
        ),
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\message_view.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/chat_bubble.dart';
import '../models/config_models/message_configuration.dart';
import '../utils/constants/constants.dart';
import '../values/typedefs.dart';
import 'chat_view_inherited_widget.dart';
import 'image_message_view.dart';
import 'reaction_widget.dart';
import 'text_message_view.dart';
import 'voice_message_view.dart';

class MessageView extends StatefulWidget {
  const MessageView({
    Key? key,
    required this.message,
    required this.isMessageBySender,
    required this.onLongPress,
    required this.isLongPressEnable,
    this.chatBubbleMaxWidth,
    this.inComingChatBubbleConfig,
    this.outgoingChatBubbleConfig,
    this.longPressAnimationDuration,
    this.onDoubleTap,
    this.highlightColor = Colors.grey,
    this.shouldHighlight = false,
    this.highlightScale = 1.2,
    this.messageConfig,
    this.onMaxDuration,
    this.controller,
  }) : super(key: key);

  /// Provides message instance of chat.
  final Message message;

  /// Represents current message is sent by current user.
  final bool isMessageBySender;

  /// Give callback once user long press on chat bubble.
  final DoubleCallBack onLongPress;

  /// Allow users to give max width of chat bubble.
  final double? chatBubbleMaxWidth;

  /// Provides configuration of chat bubble appearance from other user of chat.
  final ChatBubble? inComingChatBubbleConfig;

  /// Provides configuration of chat bubble appearance from current user of chat.
  final ChatBubble? outgoingChatBubbleConfig;

  /// Allow users to give duration of animation when user long press on chat bubble.
  final Duration? longPressAnimationDuration;

  /// Allow user to set some action when user double tap on chat bubble.
  final ValueSetter<Message>? onDoubleTap;

  /// Allow users to pass colour of chat bubble when user taps on replied message.
  final Color highlightColor;

  /// Allow users to turn on/off highlighting chat bubble when user tap on replied message.
  final bool shouldHighlight;

  /// Provides scale of highlighted image when user taps on replied image.
  final double highlightScale;

  /// Allow user to giving customisation different types
  /// messages.
  final MessageConfiguration? messageConfig;

  /// Allow user to turn on/off long press tap on chat bubble.
  final bool isLongPressEnable;

  final ChatController? controller;

  final ValueSetter<int>? onMaxDuration;

  @override
  State<MessageView> createState() => _MessageViewState();
}

class _MessageViewState extends State<MessageView>
    with SingleTickerProviderStateMixin {
  AnimationController? _animationController;

  MessageConfiguration? get messageConfig => widget.messageConfig;

  bool get isLongPressEnable => widget.isLongPressEnable;

  @override
  void initState() {
    super.initState();
    if (isLongPressEnable) {
      _animationController = AnimationController(
        vsync: this,
        duration: widget.longPressAnimationDuration ??
            const Duration(milliseconds: 250),
        upperBound: 0.1,
        lowerBound: 0.0,
      );

      _animationController?.addStatusListener((status) {
        if (status == AnimationStatus.completed) {
          _animationController?.reverse();
        }
      });
    }
    if (widget.message.status != MessageStatus.read &&
        !widget.isMessageBySender) {
      widget.inComingChatBubbleConfig?.onMessageRead?.call(widget.message);
    }
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onLongPressStart: isLongPressEnable ? _onLongPressStart : null,
      onDoubleTap: () {
        if (widget.onDoubleTap != null) widget.onDoubleTap!(widget.message);
      },
      child: (() {
        if (isLongPressEnable) {
          return AnimatedBuilder(
            builder: (_, __) {
              return Transform.scale(
                scale: 1 - _animationController!.value,
                child: _messageView,
              );
            },
            animation: _animationController!,
          );
        } else {
          return _messageView;
        }
      }()),
    );
  }

  Widget get _messageView {
    final message = widget.message.message;
    final emojiMessageConfiguration = messageConfig?.emojiMessageConfig;
    return Padding(
      padding: EdgeInsets.only(
        bottom: widget.message.reaction.reactions.isNotEmpty ? 6 : 0,
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          (() {
                if (message.isAllEmoji) {
                  return Stack(
                    clipBehavior: Clip.none,
                    children: [
                      Padding(
                        padding: emojiMessageConfiguration?.padding ??
                            EdgeInsets.fromLTRB(
                              leftPadding2,
                              4,
                              leftPadding2,
                              widget.message.reaction.reactions.isNotEmpty
                                  ? 14
                                  : 0,
                            ),
                        child: Transform.scale(
                          scale: widget.shouldHighlight
                              ? widget.highlightScale
                              : 1.0,
                          child: Text(
                            message,
                            style: emojiMessageConfiguration?.textStyle ??
                                const TextStyle(fontSize: 30),
                          ),
                        ),
                      ),
                      if (widget.message.reaction.reactions.isNotEmpty)
                        ReactionWidget(
                          reaction: widget.message.reaction,
                          messageReactionConfig:
                              messageConfig?.messageReactionConfig,
                          isMessageBySender: widget.isMessageBySender,
                        ),
                    ],
                  );
                } else if (widget.message.messageType.isImage) {
                  return ImageMessageView(
                    message: widget.message,
                    isMessageBySender: widget.isMessageBySender,
                    imageMessageConfig: messageConfig?.imageMessageConfig,
                    messageReactionConfig: messageConfig?.messageReactionConfig,
                    highlightImage: widget.shouldHighlight,
                    highlightScale: widget.highlightScale,
                  );
                } else if (widget.message.messageType.isText) {
                  return TextMessageView(
                    inComingChatBubbleConfig: widget.inComingChatBubbleConfig,
                    outgoingChatBubbleConfig: widget.outgoingChatBubbleConfig,
                    isMessageBySender: widget.isMessageBySender,
                    message: widget.message,
                    chatBubbleMaxWidth: widget.chatBubbleMaxWidth,
                    messageReactionConfig: messageConfig?.messageReactionConfig,
                    highlightColor: widget.highlightColor,
                    highlightMessage: widget.shouldHighlight,
                  );
                } else if (widget.message.messageType.isVoice) {
                  return VoiceMessageView(
                    screenWidth: MediaQuery.of(context).size.width,
                    message: widget.message,
                    config: messageConfig?.voiceMessageConfig,
                    onMaxDuration: widget.onMaxDuration,
                    isMessageBySender: widget.isMessageBySender,
                    messageReactionConfig: messageConfig?.messageReactionConfig,
                    inComingChatBubbleConfig: widget.inComingChatBubbleConfig,
                    outgoingChatBubbleConfig: widget.outgoingChatBubbleConfig,
                  );
                } else if (widget.message.messageType.isCustom &&
                    messageConfig?.customMessageBuilder != null) {
                  return messageConfig?.customMessageBuilder!(widget.message);
                }
              }()) ??
              const SizedBox(),
          ValueListenableBuilder(
            valueListenable: widget.message.statusNotifier,
            builder: (context, value, child) {
              if (widget.isMessageBySender &&
                  widget.controller?.initialMessageList.last.id ==
                      widget.message.id &&
                  widget.message.status == MessageStatus.read) {
                if (ChatViewInheritedWidget.of(context)
                        ?.featureActiveConfig
                        .lastSeenAgoBuilderVisibility ??
                    true) {
                  return widget.outgoingChatBubbleConfig?.receiptsWidgetConfig
                          ?.lastSeenAgoBuilder
                          ?.call(
                              widget.message,
                              applicationDateFormatter(
                                  widget.message.createdAt)) ??
                      lastSeenAgoBuilder(widget.message,
                          applicationDateFormatter(widget.message.createdAt));
                }
                return const SizedBox();
              }
              return const SizedBox();
            },
          )
        ],
      ),
    );
  }

  void _onLongPressStart(LongPressStartDetails details) async {
    await _animationController?.forward();
    widget.onLongPress(
      details.globalPosition.dy,
      details.globalPosition.dx,
    );
  }

  @override
  void dispose() {
    _animationController?.dispose();
    super.dispose();
  }
}



===== FILE: vendor\chatview\src\widgets\profile_circle.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';
import 'package:chatview_utils/chatview_utils.dart';

import 'profile_image_widget.dart';

class ProfileCircle extends StatelessWidget {
  const ProfileCircle({
    Key? key,
    required this.bottomPadding,
    this.imageUrl,
    this.profileCirclePadding,
    this.circleRadius,
    this.onTap,
    this.onLongPress,
    this.defaultAvatarImage = Constants.profileImage,
    this.assetImageErrorBuilder,
    this.networkImageErrorBuilder,
    this.imageType = ImageType.network,
    this.networkImageProgressIndicatorBuilder,
  }) : super(key: key);

  /// Allow users to give  default bottom padding according to user case.
  final double bottomPadding;

  /// Allow user to pass image url, asset image of user's profile.
  /// Or
  /// Allow user to pass image data of user's profile picture in base64.
  final String? imageUrl;

  /// Field to define image type [network, asset or base64]
  final ImageType? imageType;

  /// Allow user to set whole padding of profile circle view.
  final EdgeInsetsGeometry? profileCirclePadding;

  /// Allow user to set radius of circle avatar.
  final double? circleRadius;

  /// Allow user to do operation when user tap on profile circle.
  final VoidCallback? onTap;

  /// Allow user to do operation when user long press on profile circle.
  final VoidCallback? onLongPress;

  /// Field to set default avatar image if profile image link not provided
  final String defaultAvatarImage;

  /// Error builder to build error widget for asset image
  final AssetImageErrorBuilder? assetImageErrorBuilder;

  /// Error builder to build error widget for network image
  final NetworkImageErrorBuilder? networkImageErrorBuilder;

  /// Progress indicator builder for network image
  final NetworkImageProgressIndicatorBuilder?
      networkImageProgressIndicatorBuilder;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: profileCirclePadding ??
          EdgeInsets.only(left: 6.0, right: 4, bottom: bottomPadding),
      child: InkWell(
        onLongPress: onLongPress,
        onTap: onTap,
        child: ProfileImageWidget(
          circleRadius: circleRadius ?? 16,
          imageUrl: imageUrl,
          defaultAvatarImage: defaultAvatarImage,
          assetImageErrorBuilder: assetImageErrorBuilder,
          networkImageErrorBuilder: networkImageErrorBuilder,
          imageType: imageType,
          networkImageProgressIndicatorBuilder:
              networkImageProgressIndicatorBuilder,
        ),
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\profile_image_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'dart:convert';

import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:chatview_utils/chatview_utils.dart';

class ProfileImageWidget extends StatelessWidget {
  const ProfileImageWidget({
    super.key,
    this.imageUrl,
    this.defaultAvatarImage = Constants.profileImage,
    this.circleRadius,
    this.assetImageErrorBuilder,
    this.networkImageErrorBuilder,
    this.imageType = ImageType.network,
    required this.networkImageProgressIndicatorBuilder,
  });

  /// Allow user to set radius of circle avatar.
  final double? circleRadius;

  /// Allow user to pass image url of user's profile picture.
  final String? imageUrl;

  /// Flag to check whether image is network or asset
  final ImageType? imageType;

  /// Field to set default avatar image if profile image link not provided
  final String defaultAvatarImage;

  /// Error builder to build error widget for asset image
  final AssetImageErrorBuilder? assetImageErrorBuilder;

  /// Error builder to build error widget for network image
  final NetworkImageErrorBuilder? networkImageErrorBuilder;

  /// Progress indicator builder for network image
  final NetworkImageProgressIndicatorBuilder?
      networkImageProgressIndicatorBuilder;

  @override
  Widget build(BuildContext context) {
    final radius = (circleRadius ?? 20) * 2;
    return ClipRRect(
      borderRadius: BorderRadius.circular(circleRadius ?? 20),
      child: switch (imageType) {
        ImageType.asset when (imageUrl?.isNotEmpty ?? false) => Image.asset(
            imageUrl!,
            height: radius,
            width: radius,
            fit: BoxFit.cover,
            errorBuilder: assetImageErrorBuilder ?? _errorWidget,
          ),
        ImageType.network when (imageUrl?.isNotEmpty ?? false) =>
          CachedNetworkImage(
            imageUrl: imageUrl ?? defaultAvatarImage,
            height: radius,
            width: radius,
            fit: BoxFit.cover,
            progressIndicatorBuilder:
                networkImageProgressIndicatorBuilder == null
                    ? null
                    : (context, url, progress) =>
                        networkImageProgressIndicatorBuilder!.call(
                          context,
                          url,
                          CacheNetworkImageDownloadProgress(
                            progress.originalUrl,
                            progress.totalSize,
                            progress.downloaded,
                          ),
                        ),
            errorWidget: networkImageErrorBuilder ?? _networkImageErrorWidget,
          ),
        ImageType.base64 when (imageUrl?.isNotEmpty ?? false) => Image.memory(
            base64Decode(imageUrl!),
            height: radius,
            width: radius,
            fit: BoxFit.cover,
            errorBuilder: assetImageErrorBuilder ?? _errorWidget,
          ),
        _ => const SizedBox.shrink(),
      },
    );
  }

  Widget _networkImageErrorWidget(context, url, error) {
    return const Center(
      child: Icon(
        Icons.error_outline,
        size: 18,
      ),
    );
  }

  Widget _errorWidget(context, error, stackTrace) {
    return const Center(
      child: Icon(
        Icons.error_outline,
        size: 18,
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\reaction_popup.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/config_models/reaction_popup_configuration.dart';
import 'emoji_row.dart';
import 'glassmorphism_reaction_popup.dart';

class ReactionPopup extends StatefulWidget {
  const ReactionPopup({
    Key? key,
    required this.onTap,
    required this.showPopUp,
  }) : super(key: key);

  /// Provides call back when user taps on reaction pop-up.
  final VoidCallback onTap;

  /// Represents should pop-up show or not.
  final bool showPopUp;

  @override
  ReactionPopupState createState() => ReactionPopupState();
}

class ReactionPopupState extends State<ReactionPopup>
    with SingleTickerProviderStateMixin {
  late final AnimationController _animationController = AnimationController(
    vsync: this,
    duration: reactionPopupConfig?.animationDuration ??
        const Duration(milliseconds: 180),
  );

  late final Animation<double> _scaleAnimation = CurvedAnimation(
    parent: _animationController,
    curve: Curves.easeIn,
    reverseCurve: Curves.easeInOutSine,
  );

  ReactionPopupConfiguration? get reactionPopupConfig =>
      chatListConfig.reactionPopupConfig;

  bool get showPopUp => widget.showPopUp;
  double _yCoordinate = 0.0;
  double _xCoordinate = 0.0;
  Message? _message;

  ChatController? chatController;
  ChatUser? currentUser;

  @override
  void initState() {
    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (chatViewIW != null) {
      chatController = chatViewIW!.chatController;
      currentUser = chatController?.currentUser;
    }
  }

  @override
  Widget build(BuildContext context) {
    final deviceWidth = MediaQuery.of(context).size.width;
    final toolTipWidth = deviceWidth > 450 ? 450 : deviceWidth;
    if (showPopUp) {
      _animationController.forward();
    } else {
      _animationController.reverse();
    }
    return showPopUp
        ? Positioned(
            top: _yCoordinate,
            left: _xCoordinate + toolTipWidth > deviceWidth
                ? deviceWidth - toolTipWidth
                : _xCoordinate - (toolTipWidth / 2) < 0
                    ? 0
                    : _xCoordinate - (toolTipWidth / 2),
            child: SizedBox(
              width: deviceWidth > 450 ? 450 : deviceWidth,
              child: AnimatedBuilder(
                animation: _scaleAnimation,
                builder: (context, child) => Transform.scale(
                  scale: _scaleAnimation.value,
                  child: reactionPopupConfig?.showGlassMorphismEffect ?? false
                      ? GlassMorphismReactionPopup(
                          reactionPopupConfig: reactionPopupConfig,
                          child: _reactionPopupRow,
                        )
                      : Container(
                          constraints: BoxConstraints(
                              maxWidth: reactionPopupConfig?.maxWidth ?? 350),
                          margin: reactionPopupConfig?.margin ??
                              const EdgeInsets.symmetric(horizontal: 25),
                          padding: reactionPopupConfig?.padding ??
                              const EdgeInsets.symmetric(
                                vertical: 6,
                                horizontal: 14,
                              ),
                          decoration: BoxDecoration(
                            color: reactionPopupConfig?.backgroundColor ??
                                Colors.white,
                            borderRadius: BorderRadius.circular(30),
                            boxShadow: [
                              reactionPopupConfig?.shadow ??
                                  BoxShadow(
                                    color: Colors.grey.shade400,
                                    blurRadius: 8,
                                    spreadRadius: -2,
                                    offset: const Offset(0, 8),
                                  )
                            ],
                          ),
                          child: _reactionPopupRow,
                        ),
                ),
              ),
            ),
          )
        : const SizedBox.shrink();
  }

  Widget get _reactionPopupRow => EmojiRow(
        onEmojiTap: (emoji) {
          widget.onTap();
          if (currentUser != null && _message != null) {
            if (!(reactionPopupConfig?.overrideUserReactionCallback ?? false)) {
              chatController?.setReaction(
                emoji: emoji,
                messageId: _message!.id,
                userId: currentUser!.id,
              );
            }
            reactionPopupConfig?.userReactionCallback?.call(
              _message!,
              emoji,
            );
          }
        },
      );

  void refreshWidget({
    required Message message,
    required double xCoordinate,
    required double yCoordinate,
  }) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      setState(() {
        final yPosition = yCoordinate -
            (chatViewIW!.reactionPopupKey.currentContext?.size?.height ?? 0);
        _message = message;
        _xCoordinate = xCoordinate;
        _yCoordinate = yPosition < 0 ? 0 : yPosition;
      });
    });
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
}



===== FILE: vendor\chatview\src\widgets\reaction_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/config_models/message_reaction_configuration.dart';
import '../utils/measure_size.dart';
import 'reactions_bottomsheet.dart';

class ReactionWidget extends StatefulWidget {
  const ReactionWidget({
    Key? key,
    required this.reaction,
    this.messageReactionConfig,
    required this.isMessageBySender,
  }) : super(key: key);

  /// Provides reaction instance of message.
  final Reaction reaction;

  /// Provides configuration of reaction appearance in chat bubble.
  final MessageReactionConfiguration? messageReactionConfig;

  /// Represents current message is sent by current user.
  final bool isMessageBySender;

  @override
  State<ReactionWidget> createState() => _ReactionWidgetState();
}

class _ReactionWidgetState extends State<ReactionWidget> {
  bool needToExtend = false;

  MessageReactionConfiguration? get messageReactionConfig =>
      widget.messageReactionConfig;
  final _reactionTextStyle = const TextStyle(fontSize: 13);
  ChatController? chatController;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (chatViewIW != null) {
      chatController = chatViewIW!.chatController;
    }
  }

  @override
  Widget build(BuildContext context) {
    //// Convert into set to remove reduntant values
    final reactionsSet = widget.reaction.reactions.toSet();
    return Positioned(
      bottom: 0,
      right: widget.isMessageBySender && needToExtend ? 0 : null,
      child: InkWell(
        onTap: () => chatController != null
            ? ReactionsBottomSheet().show(
                context: context,
                reaction: widget.reaction,
                chatController: chatController!,
                reactionsBottomSheetConfig:
                    messageReactionConfig?.reactionsBottomSheetConfig,
              )
            : null,
        child: MeasureSize(
          onSizeChange: (extend) => setState(() => needToExtend = extend),
          child: Container(
            padding: messageReactionConfig?.padding ??
                const EdgeInsets.symmetric(vertical: 1.7, horizontal: 6),
            margin: messageReactionConfig?.margin ??
                EdgeInsets.only(
                  left: widget.isMessageBySender ? 10 : 16,
                  right: 10,
                ),
            decoration: BoxDecoration(
              color: messageReactionConfig?.backgroundColor ??
                  Colors.grey.shade200,
              borderRadius: messageReactionConfig?.borderRadius ??
                  BorderRadius.circular(16),
              border: Border.all(
                color: messageReactionConfig?.borderColor ?? Colors.white,
                width: messageReactionConfig?.borderWidth ?? 1,
              ),
            ),
            child: Row(
              children: [
                Text(
                  reactionsSet.join(' '),
                  style: TextStyle(
                    fontSize: messageReactionConfig?.reactionSize ?? 13,
                  ),
                ),
                if (chatController?.otherUsers.isNotEmpty ?? false) ...[
                  if (!(widget.reaction.reactedUserIds.length > 3) &&
                      !(reactionsSet.length > 1))
                    ...List.generate(
                      widget.reaction.reactedUserIds.length,
                      (reactedUserIndex) => widget
                          .reaction.reactedUserIds[reactedUserIndex]
                          .getUserProfilePicture(
                        getChatUser: (userId) =>
                            chatController?.getUserFromId(userId),
                        profileCirclePadding:
                            messageReactionConfig?.profileCirclePadding,
                        profileCircleRadius:
                            messageReactionConfig?.profileCircleRadius,
                      ),
                    ),
                  if (widget.reaction.reactedUserIds.length > 3 &&
                      !(reactionsSet.length > 1))
                    Padding(
                      padding: const EdgeInsets.only(left: 2),
                      child: Text(
                        '+${widget.reaction.reactedUserIds.length}',
                        style:
                            messageReactionConfig?.reactedUserCountTextStyle ??
                                _reactionTextStyle,
                      ),
                    ),
                  if (reactionsSet.length > 1)
                    Padding(
                      padding: const EdgeInsets.only(left: 2),
                      child: Text(
                        widget.reaction.reactedUserIds.length.toString(),
                        style: messageReactionConfig?.reactionCountTextStyle ??
                            _reactionTextStyle,
                      ),
                    ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\reactions_bottomsheet.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../models/models.dart';
import 'profile_image_widget.dart';

class ReactionsBottomSheet {
  Future<void> show({
    required BuildContext context,

    /// Provides reaction instance of message.
    required Reaction reaction,

    /// Provides controller for accessing few function for running chat.
    required ChatController chatController,

    /// Provides configuration of reaction bottom sheet appearance.
    required ReactionsBottomSheetConfiguration? reactionsBottomSheetConfig,
  }) {
    return showModalBottomSheet<void>(
      context: context,
      builder: (BuildContext context) {
        return Container(
          height: MediaQuery.of(context).size.height * 0.5,
          color: reactionsBottomSheetConfig?.backgroundColor,
          child: ListView.builder(
            padding: reactionsBottomSheetConfig?.bottomSheetPadding ??
                const EdgeInsets.only(
                  right: 12,
                  left: 12,
                  top: 18,
                ),
            itemCount: reaction.reactedUserIds.length,
            itemBuilder: (_, index) {
              final reactedUser =
                  chatController.getUserFromId(reaction.reactedUserIds[index]);
              return GestureDetector(
                onTap: () {
                  reactionsBottomSheetConfig?.reactedUserCallback?.call(
                    reactedUser,
                    reaction.reactions[index],
                  );
                },
                child: Container(
                  margin: reactionsBottomSheetConfig?.reactionWidgetMargin ??
                      const EdgeInsets.only(bottom: 8),
                  padding: reactionsBottomSheetConfig?.reactionWidgetPadding ??
                      const EdgeInsets.all(8),
                  decoration:
                      reactionsBottomSheetConfig?.reactionWidgetDecoration ??
                          BoxDecoration(
                            color: Colors.white,
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.shade200,
                                offset: const Offset(0, 20),
                                blurRadius: 40,
                              )
                            ],
                            borderRadius: const BorderRadius.all(
                              Radius.circular(
                                10,
                              ),
                            ),
                          ),
                  child: Row(
                    children: [
                      ProfileImageWidget(
                        circleRadius:
                            reactionsBottomSheetConfig?.profileCircleRadius ??
                                16,
                        imageUrl: reactedUser.profilePhoto,
                        imageType: reactedUser.imageType,
                        defaultAvatarImage: reactedUser.defaultAvatarImage,
                        assetImageErrorBuilder:
                            reactedUser.assetImageErrorBuilder,
                        networkImageErrorBuilder:
                            reactedUser.networkImageErrorBuilder,
                        networkImageProgressIndicatorBuilder:
                            reactedUser.networkImageProgressIndicatorBuilder,
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          reactedUser.name,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style:
                              reactionsBottomSheetConfig?.reactedUserTextStyle,
                        ),
                      ),
                      Text(
                        reaction.reactions[index],
                        style: TextStyle(
                          fontSize:
                              reactionsBottomSheetConfig?.reactionSize ?? 14,
                        ),
                      )
                    ],
                  ),
                ),
              );
            },
          ),
        );
      },
    );
  }
}



===== FILE: vendor\chatview\src\widgets\reply_icon.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';

class ReplyIcon extends StatelessWidget {
  const ReplyIcon({
    Key? key,
    required this.animationValue,
    this.replyIconSize = 25,
  }) : super(key: key);

  /// Represents scale animation value of icon when user swipes for reply.
  final double animationValue;

  /// Allow user to set color of icon which is appeared when user swipes for reply.
  final double replyIconSize;

  @override
  Widget build(BuildContext context) {
    final swipeToReplyConfig = context.chatListConfig.swipeToReplyConfig;
    return Stack(
      alignment: Alignment.center,
      children: [
        Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(replyIconSize),
            color: animationValue >= 1.0
                ? swipeToReplyConfig?.replyIconBackgroundColor ??
                    Colors.grey.shade300
                : Colors.transparent,
          ),
          height: replyIconSize,
          width: replyIconSize,
          child: CircularProgressIndicator(
            value: animationValue,
            backgroundColor: Colors.transparent,
            strokeWidth: 1.5,
            color: swipeToReplyConfig?.replyIconProgressRingColor ??
                Colors.grey.shade300,
          ),
        ),
        Transform.scale(
          scale: animationValue,
          child: Icon(
            Icons.reply_rounded,
            color: swipeToReplyConfig?.replyIconColor ?? Colors.black,
            size: replyIconSize - 5,
          ),
        ),
      ],
    );
  }
}



===== FILE: vendor\chatview\src\widgets\reply_message_type_view.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:audio_waveforms/audio_waveforms.dart';
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../models/config_models/send_message_configuration.dart';
import '../utils/package_strings.dart';
import '../values/typedefs.dart';

class ReplyMessageTypeView extends StatelessWidget {
  const ReplyMessageTypeView({
    super.key,
    required this.message,
    this.customMessageReplyViewBuilder,
    this.sendMessageConfig,
  });

  /// Provides reply message instance of chat.
  final ReplyMessage message;

  /// Provides builder callback to build the custom view of the reply message view.
  final CustomMessageReplyViewBuilder? customMessageReplyViewBuilder;

  /// Provides configuration for send message
  final SendMessageConfiguration? sendMessageConfig;

  @override
  Widget build(BuildContext context) {
    return switch (message.messageType) {
      MessageType.voice => Row(
          children: [
            Icon(
              Icons.mic,
              color: sendMessageConfig?.micIconColor,
            ),
            const SizedBox(width: 4),
            if (message.voiceMessageDuration != null)
              Text(
                message.voiceMessageDuration!.toHHMMSS(),
                style: TextStyle(
                  fontSize: 12,
                  color: sendMessageConfig?.replyMessageColor ?? Colors.black,
                ),
              ),
          ],
        ),
      MessageType.image => Row(
          children: [
            Icon(
              Icons.photo,
              size: 20,
              color:
                  sendMessageConfig?.replyMessageColor ?? Colors.grey.shade700,
            ),
            Text(
              PackageStrings.currentLocale.photo,
              style: TextStyle(
                color: sendMessageConfig?.replyMessageColor ?? Colors.black,
              ),
            ),
          ],
        ),
      MessageType.custom when customMessageReplyViewBuilder != null =>
        customMessageReplyViewBuilder!(message),
      MessageType.custom || MessageType.text => Text(
          message.message,
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
          style: TextStyle(
            fontSize: 12,
            color: sendMessageConfig?.replyMessageColor ?? Colors.black,
          ),
        ),
    };
  }
}



===== FILE: vendor\chatview\src\widgets\reply_message_view.dart =====
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/models.dart';
import '../utils/constants/constants.dart';
import '../utils/package_strings.dart';
import '../values/typedefs.dart';
import 'chat_textfield_view_builder.dart';
import 'reply_message_type_view.dart';

class ReplyMessageView extends StatefulWidget {
  const ReplyMessageView({
    super.key,
    required this.sendMessageConfig,
    required this.messageConfig,
    required this.builder,
    required this.onChange,
  });

  /// Provides configuration for sending message.
  final SendMessageConfiguration? sendMessageConfig;

  /// Provides configuration for message view.
  final MessageConfiguration? messageConfig;

  /// Provides a callback for the view when replying to message
  final CustomViewForReplyMessage? builder;

  /// Provides a callback when reply message changes.
  final ValueSetter<ReplyMessage> onChange;

  @override
  State<ReplyMessageView> createState() => ReplyMessageViewState();
}

class ReplyMessageViewState extends State<ReplyMessageView> {
  final ValueNotifier<ReplyMessage> replyMessage =
      ValueNotifier(const ReplyMessage());

  ChatUser? currentUser;

  ChatUser? get repliedUser => replyMessage.value.replyTo.isNotEmpty
      ? context.chatViewIW?.chatController
          .getUserFromId(replyMessage.value.replyTo)
      : null;

  String get _replyTo => replyMessage.value.replyTo == currentUser?.id
      ? PackageStrings.currentLocale.you
      : repliedUser?.name ?? '';

  @override
  void initState() {
    replyMessage.addListener(_handleReplyMessageChange);
    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (chatViewIW != null) {
      currentUser = chatViewIW!.chatController.currentUser;
    }
  }

  @override
  Widget build(BuildContext context) {
    final replyTitle = "${PackageStrings.currentLocale.replyTo} $_replyTo";

    return ChatTextFieldViewBuilder<ReplyMessage>(
      valueListenable: replyMessage,
      builder: (_, state, child) {
        if (state.message.isEmpty) {
          return const SizedBox.shrink();
        }

        return widget.builder?.call(context, state) ??
            Container(
              decoration: BoxDecoration(
                color: widget.sendMessageConfig?.textFieldBackgroundColor ??
                    Colors.white,
                borderRadius: const BorderRadius.vertical(
                  top: Radius.circular(14),
                ),
              ),
              margin: const EdgeInsets.only(
                bottom: 17,
                right: 0.4,
                left: 0.4,
              ),
              padding: const EdgeInsets.fromLTRB(
                leftPadding,
                leftPadding,
                leftPadding,
                30,
              ),
              child: Container(
                margin: const EdgeInsets.only(bottom: 2),
                padding: const EdgeInsets.symmetric(
                  vertical: 4,
                  horizontal: 6,
                ),
                decoration: BoxDecoration(
                  color: widget.sendMessageConfig?.replyDialogColor ??
                      Colors.grey.shade200,
                  borderRadius: const BorderRadius.all(Radius.circular(12)),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Expanded(
                          child: Text(
                            replyTitle,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: TextStyle(
                              color:
                                  widget.sendMessageConfig?.replyTitleColor ??
                                      Colors.deepPurple,
                              fontWeight: FontWeight.bold,
                              letterSpacing: 0.25,
                            ),
                          ),
                        ),
                        IconButton(
                          constraints: const BoxConstraints(),
                          padding: EdgeInsets.zero,
                          icon: Icon(
                            Icons.close,
                            color: widget.sendMessageConfig?.closeIconColor ??
                                Colors.black,
                            size: 16,
                          ),
                          onPressed: onClose,
                        ),
                      ],
                    ),
                    ReplyMessageTypeView(
                      message: state,
                      customMessageReplyViewBuilder:
                          widget.messageConfig?.customMessageReplyViewBuilder,
                      sendMessageConfig: widget.sendMessageConfig,
                    ),
                  ],
                ),
              ),
            );
      },
    );
  }

  @override
  void dispose() {
    replyMessage
      ..removeListener(_handleReplyMessageChange)
      ..dispose();
    super.dispose();
  }

  void _handleReplyMessageChange() {
    widget.onChange.call(replyMessage.value);
  }

  void onClose() {
    replyMessage.value = const ReplyMessage();
  }
}



===== FILE: vendor\chatview\src\widgets\reply_message_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:audio_waveforms/audio_waveforms.dart';
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../models/config_models/replied_message_configuration.dart';
import '../utils/constants/constants.dart';
import '../utils/package_strings.dart';
import 'chat_view_inherited_widget.dart';
import 'vertical_line.dart';

class ReplyMessageWidget extends StatelessWidget {
  const ReplyMessageWidget({
    Key? key,
    required this.message,
    this.repliedMessageConfig,
    this.onTap,
  }) : super(key: key);

  /// Provides message instance of chat.
  final Message message;

  /// Provides configurations related to replied message such as textstyle
  /// padding, margin etc. Also, this widget is located upon chat bubble.
  final RepliedMessageConfiguration? repliedMessageConfig;

  /// Provides call back when user taps on replied message.
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final chatController = ChatViewInheritedWidget.of(context)?.chatController;
    final currentUser = chatController?.currentUser;
    final replyBySender = message.replyMessage.replyBy == currentUser?.id;
    final textTheme = Theme.of(context).textTheme;
    final replyMessage = message.replyMessage.message;
    final messagedUser =
        chatController?.getUserFromId(message.replyMessage.replyBy);
    final replyBy =
        replyBySender ? PackageStrings.currentLocale.you : messagedUser?.name;
    return GestureDetector(
      onTap: onTap,
      child: Container(
        margin: repliedMessageConfig?.margin ??
            const EdgeInsets.only(
              right: horizontalPadding,
              left: horizontalPadding,
              bottom: 4,
            ),
        constraints:
            BoxConstraints(maxWidth: repliedMessageConfig?.maxWidth ?? 280),
        child: Column(
          crossAxisAlignment:
              replyBySender ? CrossAxisAlignment.end : CrossAxisAlignment.start,
          children: [
            Text(
              "${PackageStrings.currentLocale.repliedBy} $replyBy",
              style: repliedMessageConfig?.replyTitleTextStyle ??
                  textTheme.bodyMedium!
                      .copyWith(fontSize: 14, letterSpacing: 0.3),
            ),
            const SizedBox(height: 6),
            IntrinsicHeight(
              child: Row(
                mainAxisAlignment: replyBySender
                    ? MainAxisAlignment.end
                    : MainAxisAlignment.start,
                children: [
                  if (!replyBySender)
                    VerticalLine(
                      verticalBarWidth: repliedMessageConfig?.verticalBarWidth,
                      verticalBarColor: repliedMessageConfig?.verticalBarColor,
                      rightPadding: 4,
                    ),
                  Flexible(
                    child: Opacity(
                      opacity: repliedMessageConfig?.opacity ?? 0.8,
                      child: message.replyMessage.messageType.isImage
                          ? Container(
                              height: repliedMessageConfig
                                      ?.repliedImageMessageHeight ??
                                  100,
                              width: repliedMessageConfig
                                      ?.repliedImageMessageWidth ??
                                  80,
                              decoration: BoxDecoration(
                                image: DecorationImage(
                                  image: NetworkImage(replyMessage),
                                  fit: BoxFit.fill,
                                ),
                                borderRadius:
                                    repliedMessageConfig?.borderRadius ??
                                        BorderRadius.circular(14),
                              ),
                            )
                          : Container(
                              constraints: BoxConstraints(
                                maxWidth: repliedMessageConfig?.maxWidth ?? 280,
                              ),
                              padding: repliedMessageConfig?.padding ??
                                  const EdgeInsets.symmetric(
                                    vertical: 8,
                                    horizontal: 12,
                                  ),
                              decoration: BoxDecoration(
                                borderRadius: _borderRadius(
                                  replyMessage: replyMessage,
                                  replyBySender: replyBySender,
                                ),
                                color: repliedMessageConfig?.backgroundColor ??
                                    Colors.grey.shade500,
                              ),
                              child: message.replyMessage.messageType.isVoice
                                  ? Row(
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        Icon(
                                          Icons.mic,
                                          color: repliedMessageConfig
                                                  ?.micIconColor ??
                                              Colors.white,
                                        ),
                                        const SizedBox(width: 2),
                                        if (message.replyMessage
                                                .voiceMessageDuration !=
                                            null)
                                          Text(
                                            message.replyMessage
                                                .voiceMessageDuration!
                                                .toHHMMSS(),
                                            style:
                                                repliedMessageConfig?.textStyle,
                                          ),
                                      ],
                                    )
                                  : Text(
                                      replyMessage,
                                      style: repliedMessageConfig?.textStyle ??
                                          textTheme.bodyMedium!
                                              .copyWith(color: Colors.black),
                                    ),
                            ),
                    ),
                  ),
                  if (replyBySender)
                    VerticalLine(
                      verticalBarWidth: repliedMessageConfig?.verticalBarWidth,
                      verticalBarColor: repliedMessageConfig?.verticalBarColor,
                      leftPadding: 4,
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  BorderRadiusGeometry _borderRadius({
    required String replyMessage,
    required bool replyBySender,
  }) =>
      replyBySender
          ? repliedMessageConfig?.borderRadius ??
              (replyMessage.length < 37
                  ? BorderRadius.circular(replyBorderRadius1)
                  : BorderRadius.circular(replyBorderRadius2))
          : repliedMessageConfig?.borderRadius ??
              (replyMessage.length < 29
                  ? BorderRadius.circular(replyBorderRadius1)
                  : BorderRadius.circular(replyBorderRadius2));
}



===== FILE: vendor\chatview\src\widgets\reply_popup_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../utils/package_strings.dart';

class ReplyPopupWidget extends StatelessWidget {
  const ReplyPopupWidget({
    Key? key,
    required this.sentByCurrentUser,
    required this.onUnsendTap,
    required this.onReplyTap,
    required this.onReportTap,
    required this.onMoreTap,
    this.buttonTextStyle,
    this.topBorderColor,
  }) : super(key: key);

  /// Represents message is sent by current user or not.
  final bool sentByCurrentUser;

  /// Provides call back when user tap on unsend button.
  final VoidCallback onUnsendTap;

  /// Provides call back when user tap on reply button.
  final VoidCallback onReplyTap;

  /// Provides call back when user tap on report button.
  final VoidCallback onReportTap;

  /// Provides call back when user tap on more button.
  final VoidCallback onMoreTap;

  /// Allow user to set text style of button are showed in reply snack bar.
  final TextStyle? buttonTextStyle;

  /// Allow user to set color of top border of reply snack bar.
  final Color? topBorderColor;

  @override
  Widget build(BuildContext context) {
    final textStyle =
        buttonTextStyle ?? const TextStyle(fontSize: 14, color: Colors.black);
    final deviceWidth = MediaQuery.of(context).size.width;
    return Container(
      height: deviceWidth > 500 ? deviceWidth * 0.05 : deviceWidth * 0.13,
      decoration: BoxDecoration(
        border: Border(
            top: BorderSide(
                color: topBorderColor ?? Colors.grey.shade400, width: 1)),
      ),
      child: Row(
        children: [
          Expanded(
            child: InkWell(
              onTap: onReplyTap,
              child: Text(
                PackageStrings.currentLocale.reply,
                textAlign: TextAlign.center,
                style: textStyle,
              ),
            ),
          ),
          if (sentByCurrentUser)
            Expanded(
              child: InkWell(
                onTap: onUnsendTap,
                child: Text(
                  PackageStrings.currentLocale.unsend,
                  textAlign: TextAlign.center,
                  style: textStyle,
                ),
              ),
            ),
          if (!sentByCurrentUser)
            Expanded(
              child: InkWell(
                onTap: onReportTap,
                child: Text(
                  PackageStrings.currentLocale.report,
                  textAlign: TextAlign.center,
                  style: textStyle,
                ),
              ),
            ),
          Expanded(
            child: InkWell(
              onTap: onMoreTap,
              child: Text(
                PackageStrings.currentLocale.more,
                textAlign: TextAlign.center,
                style: textStyle,
              ),
            ),
          ),
        ],
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\scroll_to_bottom_button.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';

import '../extensions/extensions.dart';

class ScrollToBottomButton extends StatefulWidget {
  const ScrollToBottomButton({super.key});

  @override
  ScrollToBottomButtonState createState() => ScrollToBottomButtonState();
}

class ScrollToBottomButtonState extends State<ScrollToBottomButton> {
  bool isButtonVisible = false;
  ScrollController? scrollController;

  @override
  void initState() {
    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      scrollController = chatViewIW?.chatController.scrollController;
      scrollController?.addListener(_updateScrollButtonVisibility);
    });
  }

  void _updateScrollButtonVisibility() {
    if (!mounted) return;

    final double currentOffset = scrollController?.offset ?? 0;
    final double buttonDisplayOffset =
        chatListConfig.scrollToBottomButtonConfig?.buttonDisplayOffset ?? 300;
    final bool isOffsetCrossedLimit = currentOffset > buttonDisplayOffset;
    if (isOffsetCrossedLimit) {
      if (!isButtonVisible) {
        setState(() {
          isButtonVisible = true;
        });
      }
    } else {
      if (isButtonVisible) {
        setState(() {
          isButtonVisible = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final scrollToBottomButtonConfig =
        chatListConfig.scrollToBottomButtonConfig;
    return TweenAnimationBuilder<double>(
      tween: Tween(begin: 0, end: isButtonVisible ? 1.0 : 0.0),
      duration: const Duration(milliseconds: 200),
      curve: Curves.easeInOut,
      builder: (context, scale, child) {
        return Transform.scale(
          scale: scale,
          child: InkWell(
            onTap: () {
              scrollToBottomButtonConfig?.onClick?.call();
              final scrollController =
                  chatViewIW?.chatController.scrollController;
              scrollController?.animateTo(
                0,
                duration: scrollToBottomButtonConfig?.scrollAnimationDuration ??
                    const Duration(milliseconds: 200),
                curve: Curves.linear,
              );
            },
            child: Container(
              decoration: BoxDecoration(
                borderRadius: scrollToBottomButtonConfig?.borderRadius ??
                    BorderRadius.circular(50),
                border: scrollToBottomButtonConfig?.border ??
                    Border.all(color: Colors.grey),
                color:
                    scrollToBottomButtonConfig?.backgroundColor ?? Colors.white,
              ),
              padding: const EdgeInsets.all(4),
              child: scrollToBottomButtonConfig?.icon ??
                  const Icon(
                    Icons.keyboard_arrow_down_rounded,
                    color: Colors.grey,
                    weight: 10,
                    size: 30,
                  ),
            ),
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    scrollController?.removeListener(_updateScrollButtonVisibility);
    super.dispose();
  }
}



===== FILE: vendor\chatview\src\widgets\selected_image_view_widget.dart =====
import 'dart:io';

import 'package:flutter/material.dart';

import '../models/config_models/send_message_configuration.dart';
import '../utils/constants/constants.dart';
import 'chat_textfield_view_builder.dart';

class SelectedImageViewWidget extends StatefulWidget {
  const SelectedImageViewWidget({
    super.key,
    required this.sendMessageConfig,
  });

  /// Provides configuration for selected image view appearance.
  final SendMessageConfiguration? sendMessageConfig;

  @override
  State<SelectedImageViewWidget> createState() =>
      SelectedImageViewWidgetState();
}

class SelectedImageViewWidgetState extends State<SelectedImageViewWidget> {
  ValueNotifier<List<String>> selectedImages = ValueNotifier<List<String>>([]);

  @override
  Widget build(BuildContext context) {
    final mqSize = MediaQuery.sizeOf(context);
    return ChatTextFieldViewBuilder<List<String>>(
      valueListenable: selectedImages,
      builder: (context, images, child) {
        if (widget.sendMessageConfig?.selectedImageViewBuilder != null) {
          return widget.sendMessageConfig?.selectedImageViewBuilder
                  ?.call(images, onImageRemove) ??
              const SizedBox.shrink();
        } else if (images.isEmpty) {
          return const SizedBox.shrink();
        }
        return Container(
          width: mqSize.width,
          margin: const EdgeInsets.only(bottom: 10),
          padding: const EdgeInsets.symmetric(
            vertical: 4,
            horizontal: 6,
          ),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(
              textFieldBorderRadius,
            ),
          ),
          child: SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Row(
              children: List.generate(
                images.length,
                (index) {
                  final imagePath = images[index];
                  return SizedBox(
                    height: widget.sendMessageConfig?.selectedImageViewHeight ??
                        mqSize.height / 6,
                    child: Container(
                      margin: widget.sendMessageConfig?.selectedImageMargin ??
                          const EdgeInsets.symmetric(
                            horizontal: 10,
                          ),
                      child: Stack(
                        children: [
                          ClipRRect(
                            borderRadius: BorderRadius.all(
                              Radius.circular(
                                widget.sendMessageConfig?.imageBorderRadius ??
                                    12,
                              ),
                            ),
                            child: Image.file(
                              File(imagePath),
                              height: mqSize.height / 8,
                            ),
                          ),
                          Positioned(
                            right: -10,
                            top: -10,
                            child: IconButton(
                              iconSize: widget
                                      .sendMessageConfig?.removeImageIconSize ??
                                  18,
                              icon: widget.sendMessageConfig?.removeImageIcon ??
                                  Icon(
                                    Icons.cancel,
                                    color: widget.sendMessageConfig
                                            ?.removeImageIconColor ??
                                        Colors.white,
                                    weight: 1,
                                  ),
                              onPressed: () => onImageRemove(imagePath),
                            ),
                          ),
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    selectedImages.dispose();
    super.dispose();
  }

  void onImageRemove(String imagePath) {
    final imageList = selectedImages.value;
    selectedImages.value = List.from(imageList..remove(imagePath));
  }
}



===== FILE: vendor\chatview\src\widgets\send_message_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'dart:io' if (kIsWeb) 'dart:html';

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/config_models/message_configuration.dart';
import '../models/config_models/send_message_configuration.dart';
import '../utils/constants/constants.dart';
import '../values/typedefs.dart';
import 'chatui_textfield.dart';
import 'reply_message_view.dart';
import 'scroll_to_bottom_button.dart';
import 'selected_image_view_widget.dart';

class SendMessageWidget extends StatefulWidget {
  const SendMessageWidget({
    Key? key,
    required this.onSendTap,
    this.sendMessageConfig,
    this.sendMessageBuilder,
    this.messageConfig,
    this.replyMessageBuilder,
  }) : super(key: key);

  /// Provides call back when user tap on send button on text field.
  final StringMessageCallBack onSendTap;

  /// Provides configuration for text field appearance.
  final SendMessageConfiguration? sendMessageConfig;

  /// Allow user to set custom text field.
  final ReplyMessageWithReturnWidget? sendMessageBuilder;

  /// Provides configuration of all types of messages.
  final MessageConfiguration? messageConfig;

  /// Provides a callback for the view when replying to message
  final CustomViewForReplyMessage? replyMessageBuilder;

  @override
  State<SendMessageWidget> createState() => SendMessageWidgetState();
}

class SendMessageWidgetState extends State<SendMessageWidget> {
  final _textEditingController = TextEditingController();

  final _focusNode = FocusNode();

  final GlobalKey<ReplyMessageViewState> _replyMessageTextFieldViewKey =
      GlobalKey();

  final GlobalKey<SelectedImageViewWidgetState> _selectedImageViewWidgetKey =
      GlobalKey();
  ReplyMessage _replyMessage = const ReplyMessage();

  ChatUser? currentUser;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (chatViewIW != null) {
      currentUser = chatViewIW!.chatController.currentUser;
    }
  }

  @override
  Widget build(BuildContext context) {
    final scrollToBottomButtonConfig =
        chatListConfig.scrollToBottomButtonConfig;
    return Align(
      alignment: Alignment.bottomCenter,
      child: widget.sendMessageBuilder != null
          ? widget.sendMessageBuilder!(_replyMessage)
          : SizedBox(
              width: MediaQuery.of(context).size.width,
              child: Stack(
                children: [
                  // This has been added to prevent messages from being
                  // displayed below the text field
                  // when the user scrolls the message list.
                  Positioned(
                    right: 0,
                    left: 0,
                    bottom: 0,
                    child: Container(
                      height: MediaQuery.of(context).size.height /
                          ((!kIsWeb && Platform.isIOS) ? 24 : 28),
                      color:
                          chatListConfig.chatBackgroundConfig.backgroundColor ??
                              Colors.white,
                    ),
                  ),
                  Positioned(
                    right: 0,
                    left: 0,
                    bottom: 0,
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        if (chatViewIW?.featureActiveConfig
                                .enableScrollToBottomButton ??
                            true)
                          Align(
                            alignment: scrollToBottomButtonConfig
                                    ?.alignment?.alignment ??
                                Alignment.bottomCenter,
                            child: Padding(
                              padding: scrollToBottomButtonConfig?.padding ??
                                  EdgeInsets.zero,
                              child: const ScrollToBottomButton(),
                            ),
                          ),
                        Padding(
                          key: chatViewIW?.chatTextFieldViewKey,
                          padding: EdgeInsets.fromLTRB(
                            bottomPadding4,
                            bottomPadding4,
                            bottomPadding4,
                            _bottomPadding,
                          ),
                          child: Stack(
                            alignment: Alignment.bottomCenter,
                            children: [
                              ReplyMessageView(
                                key: _replyMessageTextFieldViewKey,
                                sendMessageConfig: widget.sendMessageConfig,
                                messageConfig: widget.messageConfig,
                                builder: widget.replyMessageBuilder,
                                onChange: (value) => _replyMessage = value,
                              ),
                              if (widget.sendMessageConfig
                                      ?.shouldSendImageWithText ??
                                  false)
                                SelectedImageViewWidget(
                                  key: _selectedImageViewWidgetKey,
                                  sendMessageConfig: widget.sendMessageConfig,
                                ),
                              ChatUITextField(
                                focusNode: _focusNode,
                                textEditingController: _textEditingController,
                                onPressed: _onPressed,
                                sendMessageConfig: widget.sendMessageConfig,
                                onRecordingComplete: _onRecordingComplete,
                                onImageSelected: (images, messageId) {
                                  if (widget.sendMessageConfig
                                          ?.shouldSendImageWithText ??
                                      false) {
                                    if (images.isNotEmpty) {
                                      _selectedImageViewWidgetKey.currentState
                                          ?.selectedImages.value = [
                                        ...?_selectedImageViewWidgetKey
                                            .currentState?.selectedImages.value,
                                        images
                                      ];

                                      FocusScope.of(context)
                                          .requestFocus(_focusNode);
                                    }
                                  } else {
                                    _onImageSelected(images, '');
                                  }
                                },
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
    );
  }

  void _onRecordingComplete(String? path) {
    if (path != null) {
      widget.onSendTap.call(
        path,
        _replyMessage,
        MessageType.voice,
      );
      onCloseTap();
    }
  }

  void _onImageSelected(String imagePath, String error) {
    debugPrint('Call in Send Message Widget');
    if (imagePath.isNotEmpty) {
      widget.onSendTap.call(
        imagePath,
        _replyMessage,
        MessageType.image,
      );
      onCloseTap();
    }
  }

  void _onPressed() {
    final messageText = _textEditingController.text.trim();
    _textEditingController.clear();
    if (messageText.isEmpty) return;

    if (_selectedImageViewWidgetKey.currentState?.selectedImages.value
        case final selectedImages?) {
      for (final image in selectedImages) {
        _onImageSelected(image, '');
      }
      _selectedImageViewWidgetKey.currentState?.selectedImages.value = [];
    }

    widget.onSendTap.call(
      messageText.trim(),
      _replyMessage,
      MessageType.text,
    );
    onCloseTap();
  }

  void assignReplyMessage(Message message) {
    if (currentUser == null) {
      return;
    }
    FocusScope.of(context).requestFocus(_focusNode);
    _replyMessage = ReplyMessage(
      message: message.message,
      replyBy: currentUser!.id,
      replyTo: message.sentBy,
      messageType: message.messageType,
      messageId: message.id,
      voiceMessageDuration: message.voiceMessageDuration,
    );

    if (_replyMessageTextFieldViewKey.currentState == null) {
      setState(() {});
    } else {
      _replyMessageTextFieldViewKey.currentState!.replyMessage.value =
          _replyMessage;
    }
  }

  void onCloseTap() {
    if (_replyMessageTextFieldViewKey.currentState == null) {
      setState(() {
        _replyMessage = const ReplyMessage();
      });
    } else {
      _replyMessageTextFieldViewKey.currentState?.onClose();
    }
  }

  double get _bottomPadding => (!kIsWeb && Platform.isIOS)
      ? (_focusNode.hasFocus
          ? bottomPadding1
          : View.of(context).viewPadding.bottom > 0
              ? bottomPadding2
              : bottomPadding3)
      : bottomPadding3;

  @override
  void dispose() {
    _textEditingController.dispose();
    _focusNode.dispose();
    super.dispose();
  }
}



===== FILE: vendor\chatview\src\widgets\share_icon.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../models/config_models/image_message_configuration.dart';

class ShareIcon extends StatelessWidget {
  const ShareIcon({
    Key? key,
    this.shareIconConfig,
    required this.imageUrl,
  }) : super(key: key);

  /// Provides configuration of share icon which is showed in image preview.
  final ShareIconConfiguration? shareIconConfig;

  /// Provides image url of image message.
  final String imageUrl;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      onPressed: () => shareIconConfig?.onPressed != null
          ? shareIconConfig?.onPressed!(imageUrl)
          : null,
      padding: shareIconConfig?.margin ?? const EdgeInsets.all(8.0),
      icon: shareIconConfig?.icon ??
          Container(
            alignment: Alignment.center,
            padding: shareIconConfig?.padding ?? const EdgeInsets.all(4),
            decoration: BoxDecoration(
              color: shareIconConfig?.defaultIconBackgroundColor ??
                  Colors.grey.shade300,
              shape: BoxShape.circle,
            ),
            child: Icon(
              Icons.send,
              color: shareIconConfig?.defaultIconColor ?? Colors.black,
              size: 16,
            ),
          ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\suggestions\suggestion_item.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../../extensions/extensions.dart';
import '../../models/config_models/reply_suggestions_config.dart';

class SuggestionItem extends StatelessWidget {
  const SuggestionItem({
    super.key,
    required this.suggestionItemData,
  });

  final SuggestionItemData suggestionItemData;

  @override
  Widget build(BuildContext context) {
    final suggestionsConfig =
        context.suggestionsConfig ?? const ReplySuggestionsConfig();
    final suggestionsListConfig = suggestionsConfig.itemConfig;
    final theme = Theme.of(context);
    return GestureDetector(
      onTap: () {
        suggestionsConfig.onTap?.call(suggestionItemData);
        if (suggestionsConfig.autoDismissOnSelection) {
          context.chatViewIW?.chatController.removeReplySuggestions();
        }
      },
      child: Container(
        padding: suggestionItemData.config?.padding ??
            suggestionsListConfig?.padding ??
            const EdgeInsets.all(6),
        decoration: suggestionItemData.config?.decoration ??
            suggestionsListConfig?.decoration ??
            BoxDecoration(
              color: Colors.white,
              borderRadius: const BorderRadius.all(Radius.circular(8)),
              border: Border.all(
                color: theme.primaryColor,
              ),
            ),
        child: Text(
          suggestionItemData.text,
          style: suggestionItemData.config?.textStyle ??
              suggestionsListConfig?.textStyle,
        ),
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\suggestions\suggestion_list.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'dart:math' as math;

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../../extensions/extensions.dart';
import '../../models/config_models/suggestion_list_config.dart';
import '../../utils/constants/constants.dart';
import 'suggestion_item.dart';

class SuggestionList extends StatefulWidget {
  const SuggestionList({super.key});

  @override
  State<SuggestionList> createState() => _SuggestionListState();
}

class _SuggestionListState extends State<SuggestionList>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  List<SuggestionItemData> suggestions = [];
  bool isSuggestionListEmpty = false;

  @override
  void initState() {
    super.initState();

    _controller = AnimationController(
      duration: suggestionListAnimationDuration,
      vsync: this,
    )..addListener(updateSuggestionsOnAnimation);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final newSuggestions = chatViewIW?.chatController.newSuggestions;
      newSuggestions?.addListener(animateSuggestionList);
    });
  }

  void updateSuggestionsOnAnimation() {
    if (isSuggestionListEmpty && _controller.value == 0) {
      suggestions = [];
    } else if (chatViewIW?.chatController.newSuggestions.value.isNotEmpty ??
        false) {
      suggestions = chatViewIW?.chatController.newSuggestions.value ?? [];
    }
  }

  @override
  void activate() {
    super.activate();
    final newSuggestions = chatViewIW?.chatController.newSuggestions;
    newSuggestions?.addListener(animateSuggestionList);
  }

  void animateSuggestionList() {
    final newSuggestions = chatViewIW?.chatController.newSuggestions;
    if (newSuggestions != null) {
      isSuggestionListEmpty = newSuggestions.value.isEmpty;
      isSuggestionListEmpty ? _controller.reverse() : _controller.forward();
    }
  }

  @override
  Widget build(BuildContext context) {
    final suggestionsItemConfig = suggestionsConfig?.itemConfig;
    final suggestionsListConfig =
        suggestionsConfig?.listConfig ?? const SuggestionListConfig();
    return Container(
      decoration: suggestionsListConfig.decoration,
      padding:
          suggestionsListConfig.padding ?? const EdgeInsets.only(left: 8.0),
      margin: suggestionsListConfig.margin,
      // TODO: Switch to SizeTransition once support for
      // `fixedCrossAxisSizeFactor` is provided.
      child: ClipRect(
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Align(
              alignment: const AlignmentDirectional(-1.0, -1.0),
              heightFactor: math.max(_controller.value, 0.0),
              widthFactor: 1,
              child: suggestionsConfig?.suggestionItemType.isScrollType ?? false
                  ? SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        children: _suggestionListWidget(
                          suggestionsItemConfig,
                        ),
                      ),
                    )
                  : Wrap(
                      runSpacing:
                          suggestionsConfig?.spaceBetweenSuggestionItemRow ??
                              10,
                      alignment: WrapAlignment.end,
                      children: _suggestionListWidget(suggestionsItemConfig),
                    ),
            );
          },
        ),
      ),
    );
  }

  List<Widget> _suggestionListWidget(
      SuggestionItemConfig? suggestionsItemConfig) {
    final suggestionsListConfig =
        suggestionsConfig?.listConfig ?? const SuggestionListConfig();
    return List.generate(
      suggestions.length,
      (index) {
        final suggestion = suggestions[index];
        return suggestion.config?.customItemBuilder?.call(index, suggestion) ??
            suggestionsItemConfig?.customItemBuilder?.call(index, suggestion) ??
            Padding(
              padding: EdgeInsets.only(
                right: index == suggestions.length
                    ? 0
                    : suggestionsListConfig.itemSeparatorWidth,
              ),
              child: SuggestionItem(
                suggestionItemData: suggestion,
              ),
            );
      },
    );
  }

  @override
  void deactivate() {
    final newSuggestions = chatViewIW?.chatController.newSuggestions;
    newSuggestions?.removeListener(animateSuggestionList);
    super.deactivate();
  }

  @override
  void dispose() {
    _controller
      ..removeListener(updateSuggestionsOnAnimation)
      ..dispose();
    super.dispose();
  }
}



===== FILE: vendor\chatview\src\widgets\suggestions\suggestions_config_inherited_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';

import '../../models/config_models/reply_suggestions_config.dart';

/// This widget for alternative of excessive amount of passing arguments
/// over widgets.
class SuggestionsConfigIW extends InheritedWidget {
  const SuggestionsConfigIW({
    super.key,
    required super.child,
    this.suggestionsConfig,
  });

  /// The [suggestionsConfig] is used to provide the configuration for suggestion reply
  final ReplySuggestionsConfig? suggestionsConfig;

  /// This is used to access the [suggestionsConfig] from the widget tree.
  static SuggestionsConfigIW? of(BuildContext context) =>
      context.dependOnInheritedWidgetOfExactType<SuggestionsConfigIW>();

  @override
  bool updateShouldNotify(covariant SuggestionsConfigIW oldWidget) => false;
}



===== FILE: vendor\chatview\src\widgets\swipe_to_reply.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import 'reply_icon.dart';

class SwipeToReply extends StatefulWidget {
  const SwipeToReply({
    Key? key,
    required this.onSwipe,
    required this.child,
    this.isMessageByCurrentUser = true,
  }) : super(key: key);

  /// Provides callback when user swipes chat bubble from left side.
  final VoidCallback onSwipe;

  /// Allow user to set widget which is showed while user swipes chat bubble.
  final Widget child;

  /// A boolean variable that indicates if the message is sent by the current user.
  ///
  /// This is `true` if the message is authored by the sender (the current user),
  /// and `false` if it is authored by someone else.
  final bool isMessageByCurrentUser;

  @override
  State<SwipeToReply> createState() => _SwipeToReplyState();
}

class _SwipeToReplyState extends State<SwipeToReply> {
  double paddingValue = 0;
  double trackPaddingValue = 0;
  double initialTouchPoint = 0;
  bool isCallBackTriggered = false;

  late bool isMessageByCurrentUser = widget.isMessageByCurrentUser;

  final paddingLimit = 50;
  final double replyIconSize = 25;

  @override
  Widget build(BuildContext context) {
    return !(chatViewIW?.featureActiveConfig.enableSwipeToReply ?? true)
        ? widget.child
        : GestureDetector(
            onHorizontalDragStart: (details) =>
                initialTouchPoint = details.globalPosition.dx,
            onHorizontalDragEnd: (details) => setState(
              () {
                paddingValue = 0;
                isCallBackTriggered = false;
              },
            ),
            onHorizontalDragUpdate: _onHorizontalDragUpdate,
            child: Stack(
              alignment: isMessageByCurrentUser
                  ? Alignment.centerRight
                  : Alignment.centerLeft,
              fit: StackFit.passthrough,
              children: [
                ReplyIcon(
                  replyIconSize: replyIconSize,
                  animationValue: paddingValue > replyIconSize
                      ? (paddingValue) / (paddingLimit)
                      : 0.0,
                ),
                Padding(
                  padding: EdgeInsets.only(
                    right: isMessageByCurrentUser ? paddingValue : 0,
                    left: isMessageByCurrentUser ? 0 : paddingValue,
                  ),
                  child: widget.child,
                ),
              ],
            ),
          );
  }

  void _onHorizontalDragUpdate(DragUpdateDetails details) {
    final swipeDistance = isMessageByCurrentUser
        ? (initialTouchPoint - details.globalPosition.dx)
        : (details.globalPosition.dx - initialTouchPoint);
    if (swipeDistance >= 0 && trackPaddingValue < paddingLimit) {
      setState(() {
        paddingValue = swipeDistance;
      });
    } else if (paddingValue >= paddingLimit) {
      if (!isCallBackTriggered) {
        widget.onSwipe();
        isCallBackTriggered = true;
      }
    } else {
      setState(() {
        paddingValue = 0;
      });
    }
    trackPaddingValue = swipeDistance;
  }
}



===== FILE: vendor\chatview\src\widgets\text_message_view.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/chat_bubble.dart';
import '../models/config_models/link_preview_configuration.dart';
import '../models/config_models/message_reaction_configuration.dart';
import '../utils/constants/constants.dart';
import 'link_preview.dart';
import 'reaction_widget.dart';

class TextMessageView extends StatelessWidget {
  const TextMessageView({
    Key? key,
    required this.isMessageBySender,
    required this.message,
    this.chatBubbleMaxWidth,
    this.inComingChatBubbleConfig,
    this.outgoingChatBubbleConfig,
    this.messageReactionConfig,
    this.highlightMessage = false,
    this.highlightColor,
  }) : super(key: key);

  /// Represents current message is sent by current user.
  final bool isMessageBySender;

  /// Provides message instance of chat.
  final Message message;

  /// Allow users to give max width of chat bubble.
  final double? chatBubbleMaxWidth;

  /// Provides configuration of chat bubble appearance from other user of chat.
  final ChatBubble? inComingChatBubbleConfig;

  /// Provides configuration of chat bubble appearance from current user of chat.
  final ChatBubble? outgoingChatBubbleConfig;

  /// Provides configuration of reaction appearance in chat bubble.
  final MessageReactionConfiguration? messageReactionConfig;

  /// Represents message should highlight.
  final bool highlightMessage;

  /// Allow user to set color of highlighted message.
  final Color? highlightColor;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final textMessage = message.message;
    return Stack(
      clipBehavior: Clip.none,
      children: [
        Container(
          constraints: BoxConstraints(
              maxWidth: chatBubbleMaxWidth ??
                  MediaQuery.of(context).size.width * 0.75),
          padding: _padding ??
              const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 10,
              ),
          margin: _margin ??
              EdgeInsets.fromLTRB(
                  5, 0, 6, message.reaction.reactions.isNotEmpty ? 15 : 2),
          decoration: BoxDecoration(
            color: highlightMessage ? highlightColor : _color,
            borderRadius: _borderRadius(textMessage),
          ),
          child: textMessage.isUrl
              ? LinkPreview(
                  linkPreviewConfig: _linkPreviewConfig,
                  url: textMessage,
                )
              : Text(
                  textMessage,
                  style: _textStyle ??
                      textTheme.bodyMedium!.copyWith(
                        color: Colors.white,
                        fontSize: 16,
                      ),
                ),
        ),
        if (message.reaction.reactions.isNotEmpty)
          ReactionWidget(
            key: key,
            isMessageBySender: isMessageBySender,
            reaction: message.reaction,
            messageReactionConfig: messageReactionConfig,
          ),
      ],
    );
  }

  EdgeInsetsGeometry? get _padding => isMessageBySender
      ? outgoingChatBubbleConfig?.padding
      : inComingChatBubbleConfig?.padding;

  EdgeInsetsGeometry? get _margin => isMessageBySender
      ? outgoingChatBubbleConfig?.margin
      : inComingChatBubbleConfig?.margin;

  LinkPreviewConfiguration? get _linkPreviewConfig => isMessageBySender
      ? outgoingChatBubbleConfig?.linkPreviewConfig
      : inComingChatBubbleConfig?.linkPreviewConfig;

  TextStyle? get _textStyle => isMessageBySender
      ? outgoingChatBubbleConfig?.textStyle
      : inComingChatBubbleConfig?.textStyle;

  BorderRadiusGeometry _borderRadius(String message) => isMessageBySender
      ? outgoingChatBubbleConfig?.borderRadius ??
          (message.length < 37
              ? BorderRadius.circular(replyBorderRadius1)
              : BorderRadius.circular(replyBorderRadius2))
      : inComingChatBubbleConfig?.borderRadius ??
          (message.length < 29
              ? BorderRadius.circular(replyBorderRadius1)
              : BorderRadius.circular(replyBorderRadius2));

  Color get _color => isMessageBySender
      ? outgoingChatBubbleConfig?.color ?? Colors.purple
      : inComingChatBubbleConfig?.color ?? Colors.grey.shade500;
}



===== FILE: vendor\chatview\src\widgets\type_indicator_widget.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'dart:math';

import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/material.dart';

import '../extensions/extensions.dart';
import '../models/chat_bubble.dart';
import '../models/config_models/profile_circle_configuration.dart';
import '../models/config_models/type_indicator_configuration.dart';
import '../utils/constants/constants.dart';
import 'profile_circle.dart';

class TypingIndicator extends StatefulWidget {
  const TypingIndicator({
    Key? key,
    this.showIndicator = false,
    this.chatBubbleConfig,
    this.typeIndicatorConfig,
  }) : super(key: key);

  /// Allow user to turn on/off typing indicator.
  final bool showIndicator;

  /// Provides configurations related to chat bubble such as padding, margin, max
  /// width etc.
  final ChatBubble? chatBubbleConfig;

  /// Provides configurations related to typing indicator appearance.
  final TypeIndicatorConfiguration? typeIndicatorConfig;

  @override
  State<TypingIndicator> createState() => _TypingIndicatorState();
}

class _TypingIndicatorState extends State<TypingIndicator>
    with TickerProviderStateMixin {
  late AnimationController _appearanceController;

  late Animation<double> _indicatorSpaceAnimation;

  late Animation<double> _largeBubbleAnimation;

  late AnimationController _repeatingController;
  final List<Interval> _dotIntervals = const [
    Interval(0.25, 0.8),
    Interval(0.35, 0.9),
    Interval(0.45, 1.0),
  ];

  final List<AnimationController> _jumpControllers = [];
  final List<Animation> _jumpAnimations = [];

  ProfileCircleConfiguration? profileCircleConfiguration;

  ChatBubble? get chatBubbleConfig => widget.chatBubbleConfig;

  double get indicatorSize => widget.typeIndicatorConfig?.indicatorSize ?? 10;

  double get indicatorSpacing =>
      widget.typeIndicatorConfig?.indicatorSpacing ?? 4;

  Color? get flashingCircleDarkColor =>
      widget.typeIndicatorConfig?.flashingCircleDarkColor ??
      const Color(0xFF939497);

  Color? get flashingCircleBrightColor =>
      widget.typeIndicatorConfig?.flashingCircleBrightColor ??
      const Color(0xFFadacb0);

  @override
  void initState() {
    super.initState();
    if (mounted) _initializeAnimationController();
  }

  void _initializeAnimationController() {
    _appearanceController = AnimationController(
      vsync: this,
    )..addListener(() {
        setState(() {});
      });

    _indicatorSpaceAnimation = CurvedAnimation(
      parent: _appearanceController,
      curve: const Interval(0.0, 0.4, curve: Curves.easeOut),
      reverseCurve: const Interval(0.0, 1.0, curve: Curves.easeOut),
    ).drive(
      Tween<double>(
        begin: 0.0,
        end: 60.0,
      ),
    );

    _largeBubbleAnimation = CurvedAnimation(
      parent: _appearanceController,
      curve: const Interval(0.3, 1.0, curve: Curves.elasticOut),
      reverseCurve: const Interval(0.5, 1.0, curve: Curves.easeOut),
    );

    _repeatingController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    );

    for (int i = 0; i < 3; i++) {
      _jumpControllers.add(
        AnimationController(
          vsync: this,
          duration: const Duration(milliseconds: 500),
          reverseDuration: const Duration(milliseconds: 500),
        ),
      );
      _jumpAnimations.add(
        CurvedAnimation(
          parent: _jumpControllers[i],
          curve: Interval((0.2 * i), 0.7, curve: Curves.easeOutSine),
          reverseCurve: Interval((0.2 * i), 0.7, curve: Curves.easeOut),
        ).drive(
          Tween<double>(
            begin: 0,
            end: 10,
          ),
        ),
      );
    }

    if (widget.showIndicator) {
      _showIndicator();
    }
  }

  @override
  void didUpdateWidget(TypingIndicator oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (widget.showIndicator != oldWidget.showIndicator) {
      if (widget.showIndicator) {
        _showIndicator();
      } else {
        _hideIndicator();
      }
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (chatViewIW != null) {
      profileCircleConfiguration = chatViewIW!.profileCircleConfiguration;
    }
  }

  @override
  void dispose() {
    _appearanceController.dispose();
    _repeatingController.dispose();
    for (var element in _jumpControllers) {
      element.dispose();
    }
    super.dispose();
  }

  void _showIndicator() {
    _appearanceController
      ..duration = const Duration(milliseconds: 750)
      ..forward();
    _repeatingController.repeat();
    for (int i = 0; i < 3; i++) {
      _jumpControllers[i].repeat(reverse: true);
    }
  }

  void _hideIndicator() {
    _appearanceController
      ..duration = const Duration(milliseconds: 150)
      ..reverse();
    _repeatingController.stop();
    for (int i = 0; i < 3; i++) {
      _jumpControllers[i].stop();
    }
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _indicatorSpaceAnimation,
      builder: (context, child) {
        return SizedBox(
          height: _indicatorSpaceAnimation.value,
          child: child,
        );
      },
      child: Stack(
        children: [
          _buildAnimatedBubble(
            animation: _largeBubbleAnimation,
            left: 5,
            bottom: 12,
            bubble: _buildStatusBubble(),
          ),
        ],
      ),
    );
  }

  Widget _buildAnimatedBubble({
    required Animation<double> animation,
    required double left,
    required double bottom,
    required Widget bubble,
  }) {
    return Positioned(
      left: left,
      bottom: bottom,
      child: AnimatedBuilder(
        animation: animation,
        builder: (context, child) {
          return Transform.scale(
            scale: animation.value,
            alignment: Alignment.centerLeft,
            child: child,
          );
        },
        child: Row(
          children: [
            ProfileCircle(
              bottomPadding: 0,
              imageUrl: profileCircleConfiguration?.profileImageUrl,
              imageType: profileCircleConfiguration?.imageType,
              assetImageErrorBuilder:
                  profileCircleConfiguration?.assetImageErrorBuilder,
              networkImageErrorBuilder:
                  profileCircleConfiguration?.networkImageErrorBuilder,
              defaultAvatarImage:
                  profileCircleConfiguration?.defaultAvatarImage ??
                      Constants.profileImage,
              networkImageProgressIndicatorBuilder: profileCircleConfiguration
                  ?.networkImageProgressIndicatorBuilder,
            ),
            bubble,
          ],
        ),
      ),
    );
  }

  Widget _buildStatusBubble() {
    return Container(
      padding: chatBubbleConfig?.padding ??
          const EdgeInsets.fromLTRB(
              leftPadding3, 0, leftPadding3, leftPadding3),
      margin: chatBubbleConfig?.margin ?? const EdgeInsets.fromLTRB(5, 0, 6, 2),
      decoration: BoxDecoration(
        borderRadius: chatBubbleConfig?.borderRadius ??
            BorderRadius.circular(replyBorderRadius2),
        color: chatBubbleConfig?.color ?? Colors.grey.shade500,
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 10.0),
        child: Row(
          children: [
            _bubbleJumpAnimation(2, 0),
            _bubbleJumpAnimation(1, 1),
            _bubbleJumpAnimation(0, 2),
          ],
        ),
      ),
    );
  }

  Widget _bubbleJumpAnimation(int value, int index) {
    return AnimatedBuilder(
      animation: _jumpAnimations[value],
      builder: (context, child) {
        final circleFlashPercent =
            _dotIntervals[index].transform(_repeatingController.value);
        final circleColorPercent = sin(pi * circleFlashPercent);
        return Transform.translate(
          offset: Offset(0, _jumpAnimations[value].value),
          child: Container(
            width: indicatorSize,
            height: indicatorSize,
            margin: EdgeInsets.symmetric(horizontal: indicatorSpacing),
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: Color.lerp(flashingCircleDarkColor,
                  flashingCircleBrightColor, circleColorPercent),
            ),
          ),
        );
      },
    );
  }
}



===== FILE: vendor\chatview\src\widgets\vertical_line.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import 'package:flutter/material.dart';

class VerticalLine extends StatelessWidget {
  const VerticalLine({
    Key? key,
    this.leftPadding = 0,
    this.rightPadding = 0,
    this.verticalBarColor,
    this.verticalBarWidth,
  }) : super(key: key);

  /// Allow user to set color of bar
  final Color? verticalBarColor;

  /// Allow user to set left padding.
  final double leftPadding;

  /// Allow user to set left padding.
  final double rightPadding;

  /// Allow user to set width of bar.
  final double? verticalBarWidth;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: verticalBarWidth ?? 2.5,
      color: verticalBarColor ?? Colors.grey.shade300,
      margin: EdgeInsets.only(
        left: leftPadding,
        right: rightPadding,
      ),
    );
  }
}



===== FILE: vendor\chatview\src\widgets\voice_message_view.dart =====
/*
 * Copyright (c) 2022 Simform Solutions
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'dart:async';

import 'package:audio_waveforms/audio_waveforms.dart';
import 'package:chatview_utils/chatview_utils.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../models/chat_bubble.dart';
import '../models/config_models/message_reaction_configuration.dart';
import '../models/config_models/voice_message_configuration.dart';
import 'reaction_widget.dart';

class VoiceMessageView extends StatefulWidget {
  const VoiceMessageView({
    Key? key,
    required this.screenWidth,
    required this.message,
    required this.isMessageBySender,
    this.inComingChatBubbleConfig,
    this.outgoingChatBubbleConfig,
    this.onMaxDuration,
    this.messageReactionConfig,
    this.config,
  }) : super(key: key);

  /// Provides configuration related to voice message.
  final VoiceMessageConfiguration? config;

  /// Allow user to set width of chat bubble.
  final double screenWidth;

  /// Provides message instance of chat.
  final Message message;
  final ValueSetter<int>? onMaxDuration;

  /// Represents current message is sent by current user.
  final bool isMessageBySender;

  /// Provides configuration of reaction appearance in chat bubble.
  final MessageReactionConfiguration? messageReactionConfig;

  /// Provides configuration of chat bubble appearance from other user of chat.
  final ChatBubble? inComingChatBubbleConfig;

  /// Provides configuration of chat bubble appearance from current user of chat.
  final ChatBubble? outgoingChatBubbleConfig;

  @override
  State<VoiceMessageView> createState() => _VoiceMessageViewState();
}

class _VoiceMessageViewState extends State<VoiceMessageView> {
  late PlayerController controller;
  late StreamSubscription<PlayerState> playerStateSubscription;

  final ValueNotifier<PlayerState> _playerState =
      ValueNotifier(PlayerState.stopped);

  PlayerState get playerState => _playerState.value;

  PlayerWaveStyle playerWaveStyle = const PlayerWaveStyle(scaleFactor: 70);

  @override
  void initState() {
    super.initState();
    controller = PlayerController()
      ..preparePlayer(
        path: widget.message.message,
        noOfSamples: widget.config?.playerWaveStyle
                ?.getSamplesForWidth(widget.screenWidth * 0.5) ??
            playerWaveStyle.getSamplesForWidth(widget.screenWidth * 0.5),
      ).whenComplete(() => widget.onMaxDuration?.call(controller.maxDuration));
    playerStateSubscription = controller.onPlayerStateChanged
        .listen((state) => _playerState.value = state);
  }

  @override
  void dispose() {
    playerStateSubscription.cancel();
    controller.dispose();
    _playerState.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      clipBehavior: Clip.none,
      children: [
        Container(
          decoration: widget.config?.decoration ??
              BoxDecoration(
                borderRadius: BorderRadius.circular(12),
                color: widget.isMessageBySender
                    ? widget.outgoingChatBubbleConfig?.color
                    : widget.inComingChatBubbleConfig?.color,
              ),
          padding: widget.config?.padding ??
              const EdgeInsets.symmetric(horizontal: 8),
          margin: widget.config?.margin ??
              EdgeInsets.symmetric(
                horizontal: 8,
                vertical: widget.message.reaction.reactions.isNotEmpty ? 15 : 0,
              ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              ValueListenableBuilder<PlayerState>(
                builder: (context, state, child) {
                  return IconButton(
                    onPressed: _playOrPause,
                    icon:
                        state.isStopped || state.isPaused || state.isInitialised
                            ? widget.config?.playIcon ??
                                const Icon(
                                  Icons.play_arrow,
                                  color: Colors.white,
                                )
                            : widget.config?.pauseIcon ??
                                const Icon(
                                  Icons.stop,
                                  color: Colors.white,
                                ),
                  );
                },
                valueListenable: _playerState,
              ),
              AudioFileWaveforms(
                size: Size(widget.screenWidth * 0.50, 60),
                playerController: controller,
                waveformType: WaveformType.fitWidth,
                playerWaveStyle:
                    widget.config?.playerWaveStyle ?? playerWaveStyle,
                padding: widget.config?.waveformPadding ??
                    const EdgeInsets.only(right: 10),
                margin: widget.config?.waveformMargin,
                animationCurve: widget.config?.animationCurve ?? Curves.easeIn,
                animationDuration: widget.config?.animationDuration ??
                    const Duration(milliseconds: 500),
                enableSeekGesture: widget.config?.enableSeekGesture ?? true,
              ),
            ],
          ),
        ),
        if (widget.message.reaction.reactions.isNotEmpty)
          ReactionWidget(
            isMessageBySender: widget.isMessageBySender,
            reaction: widget.message.reaction,
            messageReactionConfig: widget.messageReactionConfig,
          ),
      ],
    );
  }

  void _playOrPause() {
    assert(
      defaultTargetPlatform == TargetPlatform.iOS ||
          defaultTargetPlatform == TargetPlatform.android,
      "Voice messages are only supported with android and ios platform",
    );
    if (playerState.isInitialised ||
        playerState.isPaused ||
        playerState.isStopped) {
      controller.startPlayer();
      controller.setFinishMode(finishMode: FinishMode.pause);
    } else {
      controller.pausePlayer();
    }
  }
}



